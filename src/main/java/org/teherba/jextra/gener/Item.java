/*  An Item of the generated LR(1) Parser Table
    @(#) $Id: Item.java 427 2010-06-01 09:08:17Z gfis $
    Copyright (c) 2005 Dr. Georg Fischer <punctum@punctum.com>
    2005-02-17, Georg Fischer: copied from Rule.java
*/
/*
 * Copyright 2006 Dr. Georg Fischer <punctum at punctum dot kom>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.teherba.jextra.gener;
import  org.teherba.jextra.Parm;
import  org.teherba.jextra.gener.Production;
import  org.teherba.jextra.gener.State;
import  org.teherba.jextra.scan.Symbol;

/** An Item of the generated LR(1) Parser Table
 *  <ul>
 *  <li>marked symbol (in the right side of a production)</li>
 *  <li>position of that symbol in the right side of a production</li>
 *  <li>action: shift, reduce, accept (error is generated by Parser.delta)</li>
 *  <li>successor for shift, production just recognized for reduce</li>
 *  </ul>
 *  @author Dr. Georg Fischer
 */
public class Item implements Comparable {
    public final static String CVSID = "@(#) $Id: Item.java 427 2010-06-01 09:08:17Z gfis $";
    
    /** sequential numbers of next object to be constructed */
    private static int sequence = 1;

    /** the marked symbol;
     *  if EOP is marked, the marker is at the end of the production,
     *  and the action is REDUCE (or ACCEPT if the left side is the axiom), 
     *  otherwise its SHIFT
     */
    private Symbol markedSymbol;

    /** backreference to the state that contains this item */
    private State refState;

    /** the position of the marker in the right side 
     *  (list of members) of the <em>production</em>
     *  (0, 1 to prod.length() - 1)
     */
    private int position;
    
    /** parser action code: shift a symbol and enter corresponding state */
    public static final int SHIFT   = 1;
    /** parser action code: reduce, replace the right side of a production on the stack by its left side */
    public static final int REDUCE  = 2;
    /** parser action code: a whole sentence of the language was recognized */
    public static final int ACCEPT  = 3;
    /** parser action code: syntax error (generated by Parser.delta) */
    public static final int ERROR   = 4;
    /** legible descriptions of parser actions */
    private static String [] parserActions = new String[] { ""
            , "SHIFT"
            , "REDUCE"
            , "ACCEPT"
            , "ERROR" 
            };
    
    /** one of the action codes for the parser (SHIFT, REDUCE, ACCEPT, ERROR) */
    private int action;
    
    /** the following state for SHIFT */
    private State successor;

    /** <em>position</em> defines the marker before a symbol of this production;
     *  reduce to this production for REDUCE or ACCEPT
     */
    private Production production;

    /** No-args Constructor - creates a new default item
     */
    public Item() {
        this(null, 0, ERROR, null, null);
    }
    
    /** Constructor - creates a new item
     *  @param symbol number of the marked symbol in the symbol table
     *  @param pos position in the right side of the production (starting at 0)
     *  @param act  action to be performed by the parser
     *  @param next follower state, shift to this state 
     *  @param prod reduce to this production
     */
    public Item(Symbol symbol, int pos, int act, State next, Production prod) {
        markedSymbol = symbol;
        position     = pos;
        action       = act;
        successor    = next;
        production   = prod;
        refState     = null;
    }
    
    /** Constructor - creates a new item with unknown successor state
     *  @param pos position in the right side of the production (starting at 0)
     *  @param prod reduce to this production
     */
    public Item(int pos, Production prod) {
        this(prod.getMember(pos), pos, REDUCE, null, prod);
        if (prod.getMember(pos).compareTo(Production.EOP) != 0) {
            action = SHIFT;
            // state still unknown
        }
    }

    /** Gets the marked symbol 
     *  @return symbol at the marked position in the right side
     */
    public Symbol getMarkedSymbol() {
        return markedSymbol;
    }

    /** Gets the position of the marker in the right side
     *  of the production
     *  @return position (starting at 0)
     */
    public int getPosition() {
        return position;
    }

    /** Gets the parser's action for this item
     *  @return code for the action: SHIFT, REDUCE ...
     */
    public int getAction() {
        return action;
    }

    /** Gets the following state for SHIFT items
     *  @return successor state when shifting the marked symbol
     */
    public State getSuccessor() {
        return successor;
    }

    /** Gets the state which contains this item
     *  @return state containing this item
     */
    public State getState() {
        return refState;
    }

    /** Sets the state which contains this item
     *  @param state state containing this item
     */
    public void setState(State state) {
        refState = state;
    }

    /** Gets the production which should be reduced to
     *  @return reduce this production
     */
    public Production getProduction() {
        return production;
    }

    /** Moves the marker in <em>this</em> until the end,
     *  or until a state is found which is not yet computed,
     *  and switches the state in each step.
     *  @return final item with new state, same production and 
     *  position of the EOP symbol, or with a null state
     */
    public Item shiftToEOP() {
        Item nextItem = this;
        State  state  = refState;
        Symbol symbol = markedSymbol;
        while (state != null && ! symbol.equals(Production.EOP)) {
            nextItem = state.delta(symbol);
            if (nextItem != null) {
                state = nextItem.getSuccessor();
                symbol = nextItem.getMarkedSymbol();
            } else { // symbol was not found in state 
                Parm.alert(1);
            }
            state  = nextItem.getState();
            symbol = nextItem.getMarkedSymbol();
        } // while shifting
        return nextItem;
    }

    /** Compares this object (item1) with the specified object (item2).
     *  Ordering is by marked symbol, production, position.
     *  @param obj2 item on the right side
     *  @return -1, 0, +1 if item1 < = > item2
     */
    public int compareTo(Object obj2) {
        Item item2 = (Item) obj2;
        int result = this.getMarkedSymbol().compareTo(item2.getMarkedSymbol()); 
                // order 1 by marked symbols
        if (result == 0) {
            result = this.production.compareTo(item2.getProduction()); 
                    // order 2 by productions
            if (result == 0) { // order 3 by position
                if (this.position < item2.getPosition()) {
                    result = -1;
                } else if (this.position > item2.getPosition()) {
                    result =  1;
                }
                // else 'result' is already 0
            } // discriminate by positions
        } // discriminate by productions
        return result;
    }
    
    /** Returns a human readable description of the object
     *  @return "@ symbol -> successor" or "@ symbol =: leftside" 
     */
    public String legible() {
        return "@" + markedSymbol.legible() 
                + ((successor  != null) ? " -> " + successor.getId () : "")
                + ((production != null) ? " =: " + production.getLeftSide().getEntity() : "")
                ;
    }

    /** Returns an XML description of the object
     *  @return XML element representing the item
     */
    public String toString() {
        return Parm.getIndent() + "<item mark=\"" + markedSymbol.getEntity() + "\""
                + " pos=\""  + position + "\""
                + " act=\""  + parserActions[action] + "\"" 
                + ((successor  != null) ? (" successor=\""  + successor .getId() + "\"") : "")
                + ">" 
                + ((production != null) ? (production.legible(position)) : "")
                + "</item>" + Parm.getNewline()
                ;
    }

    /** Test Frame
     */     
    public static void main (String args[]) { 
    } // main
} // Item
