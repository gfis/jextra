&(ALONG   )
      SUBROUTINE ALONG(STATEQ,POSQ,STATE,PROD)
C     WALK THROUGH THE STATES AND MOVE THE MARKER BEHIND A PRODUCTION
C     GF 20.08.80 : WITH CALL 'DELTA'
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (STAS)
      INTEGER I
     = ,ACTION  ! RESULT OF 'DELTA'
     = ,POS      ! TEMPORARY POSIT OF THE MARKER
     = ,POSQ     ! START WITH THIS POSIT AND MOVE THE MARKER,THE END
     = ,PROD     ! RESULTING PRODUCTION
     = ,STATE    ! THE STATE THAT HAS THE MARKER AT THE END, OR 0
     = ,STATEQ   ! THIS STATE HAS AN ITEM WITH THE MARKER BEFORE 'POSQ'
     = ,SUCPRO  ! RESULT OF 'DELTA', NEXT 'STATE'
     = ,SYMBOL   !  = MEM(POS)
C
      STATE = STATEQ ! BEGIN WITH THIS 'STATE'
      POS = POSQ
      SYMBOL = MEM(POS)
1     IF(SYMBOL   .LE. 1) GOTO 2 ! DUMMY SYMBOL NOT YET REACHED
        CALL DELTA (STATE,SYMBOL,  ACTION,SUCPRO)
        STATE = SUCPRO
        IF (ACTION .NE. SHIFT) GOTO 7
          IF (STATE .LT. 0)  !,BE PROCESSED,'STASUC'
     =      STATE = 0
          IF (STATE .EQ. 0)! SUCCESSOR NOT YET COMPUTED
     =      GOTO 101
          POS = POS + 1
          SYMBOL = MEM(POS)
          GOTO 100 ! THIS MEMBER WAS FOUND
7       CONTINUE ! SHIFT
        ! 'POS' WAS NOT FOUND IN 'STATE' :
        CALL ASSERT(1,STATE,POS)
        STATE = 0
        GOTO 101
C
100     CONTINUE !      LEAVE
      GOTO 1
2     CONTINUE ! WHILE DUMMY SYMBOL NOT REACHED
      PROD = MEMNUC(POS)
      ! 'STATE' IS ALREADY O.K.
C
101   CONTINUE !     DONE
      RETURN! ALONG
      END
&END
&(ASSERT  )
      SUBROUTINE ASSERT(NUM,VAR1,VAR2)
C     PRINT AN ERROR- OR OTHER MESSAGE OF THE EXTRA-SYSTEM
C     GF 21.07.80
C
      %INCLUDE (PARS)
      INTEGER PARASK
      INTEGER INDEX
      INTEGER I
     = ,MAX   ! NO MORE CALLS ARE ALLOWED
     = ,NOW   ! HOW OFTEN WAS 'ASSERT' CALLED
     = ,NUM      ! THE NUMBER OF THE MESSAGE
     = ,P1       ! LENGTH OF
     = ,P2       ! LENGTH OF THE 2ND PORTION OF TEXT
     = ,T(40)   ! BUFFER FOR THE TEXTS
     = ,VAR1     ! 1ST VARIABLE,BE INSERTED IN THE TEXT
     = ,VAR2     ! 2ND ...
      DATA MAX /0/
      %INCLUDE (ENDS)
C
      IF (MAX .GT. 0) GOTO 10
        MAX = PARASK('ASSERT',1,6,32)
10    CONTINUE
        OPEN (UNIT=UASS,NAME='DL1:[20,21]ASSTEX.DIR'
     =    ,ACCESS='DIRECT',TYPE='OLD',ASSOCIATE VARIABLE=I
     =    ,RECORD SIZE=20
     =  )
C=    1: ALONG : IN STATE @ POSIT @ NOT FOUND
C=    2: HAPPEN: CANNOT ALLOCATE STRING, STRHIB=@, FSYM=@
C=    3: EMITT : SYMBOL @ IN STATE @ NOT FOUND
C=    4: PARSE : TEST-TRACE STATE=@, ITEM=@
C=    5: SETALL: TOO MUCH SET-ELEMENTS, FSET=@, SETHIB=@
C=    6: PREDEL: STATE @ IS NOT A PREDECESSOR OF STATE @
C=    7: HAMAP : CANNOT ALLOCATE SYMBOL, SYMHIB=@, FSTR=@
C=    8: SPEINS: CANNOT ALLOCATE SYMBOL, SYMHIB=@, FSTR=@
C=    9: PARADD: MORE THAN @ PARAMETERS @
C=   10: DELTA : INVALID MEMBER AT POSITION @
C=   11: PREINS: CANNOT ALLOCATE PREDECESSOR @ OF STATE @
C=   12: STAALL: CANNOT ALLOCATE STATE @ REACHED,SYMBOL @
C=   13: SETDEL: @ NOT FOUND IN LIST, TAIL=@
C=   16: PROCHA: CANNOT ALLOCATE PRODUCTION OF @, FMEM=@
C=   17: PROCHA: SAME PRODUCTION @ FOR @  IN THE GRAMMAR
C=   18: INFLIS: CYCLE IN LIST, AHIB=@, FA=@
C=   19: PROCHA: CANNOT ALLOCATE MEMBER, LEFT=@, FMEM=@'
C=   20: SEPUSH: CANNOT APPEND,TAIL @, VALUE @
C=   21: ITEALL: CANNOT ALLOCATE ITEM FOR STATE @, ITEHIB=@
C=   22: ITEINS: IN STATE @ CANNOT INSERT POSIT @
C=   23: PREINS: STATE @ IS ALREADY A PREDECESSOR OF STATE @
C=   24: RECEIV: 'ALONG' DOES NOT YIELD PRODUCTION @, BUT @
C=   25: LITRAC: ELEMENT @ ALREADY MARKED, TAIL=@
C=   27: STAFRE: STATE @ NOT IN REACHING LIST OF SYMBOL @
C=   28: SPEINS: CANNOT ALLOCATE STRING, FSTR=@, STRHIB=@
C=   29: SCAN  : IN LINE @, COLUMN @ END OF FILE IN COMMENT
C=   30: SCAN  : IN LINE @, COLUMN @ END OF FILE IN STRING
C=   33: LITRAC: 128 LOOP CYCLES, AHEAD=@, ATAIL=@
C=   38: PARSE : STACK OVERFLOW IN STATE @, SYMBOL @
C=   39: PARSE : IN STATE @ NONTERMINAL @ NOT FOUND
C=   42: PARSER: PARSE COMPLETE. @ ERRORS. @
C=   43: PREINS: IN STATE @ PREDECESSOR @ NOT FOUND
C=   50: GRAMAR: INVALID SYMBOL @: ''@''
C=   55: GRAMAR: NO NUMBER AFTER ''->'', SYMBOL=@, ENTITY=@'
C=   56: GRAMAR: CANNOT ALLOCATE MEMBER @, SYMBOL=@
C=   57: GRAMAR: CANNOT ALLOCATE MEMBER @, SYMBOL=@
C=   60: CLEARE: STATE @ CONTAINS AT LEAST A 2ND REDUCTION @
C=   62: SEPANT: @ IS NO ATTRIBUTE OF RECORD @
C=   63: SEMARI: INVALID OPERATION @
C=   64: SEMARI: '*@' NOT ALLOWED HERE, REPLACED BY '*@'
C=   91: SEMWRI: INCREASE 'SEMHIB' (=@) @
C=   92: SEMA30: COMBINED SYMBOL @ MUST NOT BE AN ACCU WITH INCARNATION
C=   93: SEMA24: RE-INPUT NOT ALLOWED AT POSITION @ @
C=   94: SEMA27: ATTRIBUTE @ NOT ALLOWED HERE @
C=   95: SEMA13: RE-INPUT NOT ALLOWED AT POSITION @ @
C=   96: SEMA14: RE-INPUT NOT ALLOWED AT POSITION @ @
C=   97: SEMGET: SON NUMBER @ IS NOT AN IDENTIFIER/NUMBER/STRING@
C=  125: TRANS : ASSIGNMENT TO NON-EXISTING ACCU-INCARNATION @:@
C=  126: TRANS-ATIN: @ HAS NO ATTRIBUTE @
C=  127: TRANS : EXTRA-ERROR, 'ACIN' IN PRODUCTION @, POSITION @
C=  128: TRANS-SYAT: @ HAS NO ATTRIBUTE @
C=  129: TRAPIM: INCREASE 'TRAHIB' (=@), FTRA = @
C=  130: CLEARE: @ REDUCE- AND @ SHIFT-ITEMS DELETED
C=  131: TRANS : 'ACCU' IN PRODUCTION @, POSITION @
C=  132: TRANS : 'ATTR' IN PRODUCTION @, POSITION @
C=  133: TRATTR: EMPTY SON @, ATTRIBUTE @ IS UNDEFINED
C=  134: TRATTR: @ IS NO ENTITY, ATTRIBUTE @ IS UNDEFINED
C=  135: SEMARI: ONLY ONE OPERAND FOR DYADIC OPERATION @ @
C=  136: PUTCON: CONFLICT FOR @ IN STATE @
C=  138: TRADO : LOOP-CHECK, ACT = @, FTRA = @
C=  139: SEPANT: INVALID ACTION NUMBER @ @
C=  140: STASYM: CANNOT FIND SYMBOL FOR STATE @@
C=  141: TARGET: ANCHOR NOT FOUND, ACT=@, FSTK=@
C=  145: LINEXT: COLUMNS 1-5 OF CONTINUATION LINE NOT BLANK @@
C=  146: LINEXT: MORE THAN @ CONTINUATION LINES @
C=  147: TREXPA: INCREASE STKHIB (=@)@
C=  148: PARSER: SYNTACTICAL ERROR BETWEEN @ AND @
C=  149: ITEMA8-PAG: INCREASE DIRHIB. I2=@, STATE=@
C=  150: ITEMA1-PAG: INCREASE ITEHIB. STATE=@, FITE=@
C=  151: ITEMA1-PAG: TEST-INFORMATION: STATE @ HAS @ ITEMS
C=  152: ITEMA2: TEST-INFORMATION: STATE=@, STAITE()=@
C=  153: DIRWRI: TEST-INFORMATION: LOW=@, HIGH=@
C=  154: PARSER: TEST PANIC-MODE    FSTK=@, STATE=@
C=  158: ITEMA8-PAG: TEST-INFORMATION: STATE @ HAS @ ITEMS
C=  159: ITEMA9: TEST-INFORMATION: STATE=@, STAITE()=@
C=  161: ITEMA1-NOPAG: TEST-INFORMATION: STATE @ HAS @ ITEMS
C=  168: ITEMA8-NOPAG: TEST-INFORMATION: STATE @ HAS @ ITEMS
C=  175: SEMA08: CANNOT ALLOCATE MEMBER, FMEM=@, ENTITY=@
C=  176: OUTPRO: LOOP-CHECK, I=@, NUC(I)=@
C=  185: PUTCON: FOLLOWING CONFLICTS WERE DETECTED:@@
C=  195: PUTCON: INCREASE PREHIB (=@)
C=  196: PUTCON: FOLLOWING TERMINALS CONTAIN UNDERSCORES: @@
C=  197: PUTCON: CONFLICT FOR SYMBOL @:@
C=  198: PUTCON: FOLLOWING SYMBOLS WERE NOT REACHED @@
C=  199: RECEXP @,@
C=  200: RECEXP @,@
      I = 29647
      IF (PARASK('TRASSE',1,6,0) .NE. 0)
     =  WRITE (UPRI,11) I
11      FORMAT(1X,I1)
      NOW = NOW + 1
      IF (NOW .GT. MAX) GOTO 1
        I = NUM
        READ (UASS'I) (T(P1),P1=1,40)
        P1 = INDEX(T,1,80,'@')
        P2 = INDEX(T,P1+1,80,'@')
        ! <---P1------>
        ! <------P2------------------>
        !    LEFT     @     MIDDLE   @    RIGHT
        CALL ZZWC ('---',1,3,0)
        CALL ZZWI (NUM,3)
        CALL ZZWC ('-',1,1,0)
        CALL ZZWC (T,2,P1-1,0)
        IF (VAR1 .EQ. 0) GOTO 3
          IF (VAR1 .GE. 0) GOTO 4
            CALL PUTSYM(-VAR1)
          GOTO 5
4         CONTINUE
            CALL ZZWI (VAR1,0)
5         CONTINUE
          CALL ZZWC (T,P1+1,P2-1,0)
          IF (VAR2 .EQ. 0) GOTO 6
            IF (VAR2 .GE. 0 ) GOTO 7
              CALL PUTSYM(-VAR2)
            GOTO 8
7           CONTINUE
              CALL ZZWI (VAR2,0)
8           CONTINUE
            CALL ZZWC (T,P2+1,80,0)
6         CONTINUE ! VAR2 .EQ. 0
3       CONTINUE ! VAR1 .EQ. 0
        CALL ZZWS (0)
        CLOSE (UNIT=UASS)
      GOTO 2
1     CONTINUE ! NOW .GT. MAX
        WRITE(UPRI,9) MAX
9       FORMAT(' ---201-ASSERT: MORE THAN ',I3,' ASSERTIONS - STOP')
        STOP
2     CONTINUE ! NOW .LE.  MAX
      RETURN ! ASSERT
      END
&END
&(ASSLOA  )
      PROGRAM ASSLOA
C     LOAD 'ASSERT'-TEXTS ON A DIRECT-FILE
C     GF 07.08.80
C
      INTEGER I,J
     = ,NUM     ! WRITE THE TEXT TO THIS RECORD OF 'UASS'
     = ,MAXNUM  ! HIGHEST POSSIBLE RECORD-NUMBER
     = ,LINE(40) ! BUFFER FOR THE TEXTS
     = ,UASS     ! WRITE THE TEXTS TO THIS DIRECT-FILE
     = ,ULIN     ! READ THE TEXTS FROM THIS FILE
      DATA UASS/1/, ULIN/4/, LINE/40*'  '/
      DATA MAXNUM /200/
C
      OPEN (UNIT=ULIN,NAME='DL1:[20,21]ASSERT.FTN'
     = ,TYPE='OLD'
     = )
      OPEN (UNIT=UASS,NAME='DL1:[20,21]ASSTEX.DIR'
     = ,TYPE='NEW',ACCESS='DIRECT',RECORD SIZE=20
     = ,ASSOCIATE VARIABLE=NUM,MAXREC=MAXNUM
     = )
      CALL ZZCC('UNDEF : @,@',1,11,LINE,1,80)
      NUM = 1
      DO 1 I = 1,MAXNUM
        WRITE (UASS'NUM) (LINE(J),J=1,40)
1     CONTINUE
2     CONTINUE
      READ (ULIN,3,END=5) (LINE(J),J=1,40)
3     FORMAT (40A2)
      IF (LINE(1) .NE. 'C=') GOTO 2
      DECODE (7,6,LINE) NUM
6     FORMAT (2X,I5)
      WRITE (UASS'NUM) (LINE(J),J=5,40)
      GOTO 2
5     CONTINUE
      STOP
      END
&END
&(ASSLOATB)
ASSLOA/CP/FP=BOFOR/LB:ASSLOA
BOFOR/LB
&END
&(BLODAT  )
      BLOCK DATA BLODAT
C     FOR THE EXTRA PARSER-GENERATOR
C     GF 19.07.80: 'SYMPRO' INIT('PROHIB') FOR 'TRACCU', 'TRATTR'
C
      %INCLUDE (PARS)
      %INCLUDE (BUCS)
      %INCLUDE (CODS)
      %INCLUDE (DIRS)
      %INCLUDE (ITES)
      %INCLUDE (LINS)
      %INCLUDE (MEMS)
      %INCLUDE (PRES)
      %INCLUDE (PRIS)
      %INCLUDE (PROS)
      %INCLUDE (PRESEMS)
      %INCLUDE (MEMSETS)
      %INCLUDE (SLOS)
      INTEGER DIR(&DIRH)
      EQUIVALENCE (SLOT(1,1),DIR(1))
      %INCLUDE (SPAS)
C----------------------------------------------------------------
      INTEGER HIGH8(4)
      COMMON /SPES/ HIGH8
      %INCLUDE (STAS)
      %INCLUDE (STAT1) ! STATICS FOR 'SEMANT'
C--------------------------------------------
      INTEGER TRAFS(15)
      COMMON /STAT2/ TRAFS ! STATICS FOR 'TRAFOR'
      %INCLUDE (STKS)
      %INCLUDE (STASTRS)
      %INCLUDE (SYMS)
      %INCLUDE (TARS)
      %INCLUDE (SETTRAS)
      %INCLUDE (TRES)
C
C-------------------------------------------------------------
C     PARS
      DATA UPRI /&UPRI/
      DATA ULIN /&ULIN/
      DATA UTAR /&UTAR/
      DATA UPAR /&UPAR/
      DATA UASS /&UASS/
      DATA PARHIB /&PARH/
      DATA PARLAS /1/
      DATA PARME(1) /1/
      DATA PARVAL(1) /0/
      DATA PARM(1,1) /'X'/
C----------------------------------------------------------------
C     BUCS
      DATA BUCHIB /&BUCH/
      DATA BUCKET /&BUCH * &SYMH/
C------------------------------------------------------------
C     DIRS
      DATA UDIR/&UDIR/
      DATA DIRHIB /&DIRH/
C-----------------------------------------------------------
C     ITES
C     DATA ITEACT(&ITEH) /4/ ! ERROR
      DATA ITESYM(&ITEH) /&SYMH/ ! FOR MERGING IN 'LACOPY'
      DATA ITEHIB/&ITEH/
      DATA SHIFT,REDUCE,ACCEPT,ERROR
     =     / 1  ,  2   ,  3   ,  4 /
C-------------------------------------------------------------
C     LINS
      DATA LINENO/0/
C-----------------------------------------------------------
C     MEMS
      DATA MEM /&MEMH * 0/
      DATA FMEM /2/
      DATA MEMHIB/&MEMH/
      DATA EOP/1/
C-----------------------------------------------------------
C     PRES
      DATA PREHIB/&PREH/
C-------------------------------------------------------------
C     PRIS
      DATA FPRI /2/ ! POSITION 1 = CARRIAGE CONTROL
      %PARAMETER PRIH2=PRIH*2-1
      DATA PRIHIB /&PRIH2/
      DATA PRIBUF /&PRIH * '  '/
C-----------------------------------------------------------
C     PROS
      DATA PROHIB/&PROH/
C-----------------------------------------------------------
C     SEMS
      DATA SEMHIB/&SEMH/
      DATA
     =  ACCO,ACIN,ACMA,ACTA  ! ACCUMULATOR
     = ,ATCO,ATIN,ATMA,SYAT  ! ATTRIBUTE
     = ,SOCO,REIN,UNCH,SOTA  ! SON, MEMBER
     = ,SYCO,SYIN,SYMA,SEPR  ! NEW SYMBOL
     = ,ACCU,ATTR,EOSY,EOS   ! MISCELLANEOUS
     = /   1,   2,   3,   4
     = ,   5,   6,   7,   8
     = ,   9,  10,  11,  12
     = ,  13,  14,  15,  16
     = ,  17,  18,  19,  20
     = /
C               DESL DESU PNOSEM      FSEM
C                 |    |          |     |
C                 V    V          V     V
      %PARAMETER SEMH5=SEMH-5
      DATA SEM /  0 ,  0 ,  11  , 20 ,  20 , &SEMH5 *20/
      DATA SEMSYM /&SEMH * 0/
      DATA PNOSEM /4/ ! -> EOS
      DATA FSEM   /5/ ! -> THEREAFTER
C-----------------------------------------------------------
C     SETS
      DATA SETHIB/&SETH/
C-----------------------------------------------------------
C     SLOS
      DATA SLOFUL /&SLOH * 0/
      DATA FSLO /1/
      DATA SLOHIB /&SLOH/
C----------------------------------------------------------
C     SPAS
      DATA SPAHIB/&SPAH/
C-----------------------------------------------------------
C     STAS
      DATA STAITE /&STAH * 0/
      DATA FNUM /2/ ! = 'FSTA' AT BEGINNING
      DATA STAHIB/&STAH/
C----------------------------------------------------------
C     STAT1
      DATA DESL /1/
      DATA BUPROD /0/
      DATA INGRAM /1/ ! START WITH PARSING GRAMMAR
      DATA NEWNUM /7952/
C-----------------------------------------------------------
C     STKS
      DATA STKHIB/&STKH/
C-----------------------------------------------------------
C     STRS
      %PARAMETER STRH2=2*STRH
      DATA STRHIB/&STRH2/
      DATA FSTR /2/
C-----------------------------------------------------------
C     SYMS
      DATA FSYM /2/
      DATA SYMPOS(1) /1/
C     DATA SYMEND(1) /1/
      DATA SYMHIB/&SYMH/
      DATA SYMPRO /&SYMH * &PROH/
      DATA SYMPOS(2) /2/ ! FOR 'HAMAP', 'HAPSE': SYMPOS(FSYM)=FSTR
C-------------------------------------------------------------
C     TARS
      DATA FTAR /1/ ! POSITION 1 = CARRIAGE CONTROL
      %PARAMETER TARH2=TARH*2-1
      DATA TARHIB /&TARH2/
      DATA TARBUF /&TARH * '  '/
C-----------------------------------------------------------
C     TRAS
      DATA TRAHIB/&TRAH/
      DATA TVOID,TKEYW,TSPEC,TCALL,TCOMT
     =    ,TGOTO,TIDEN,TNUMB,TSTRI
     =    /    1,    2,    3,    4,    5
     =    ,    6,    7,    8,    9
     =    /
      DATA TRASYM/&TRAH * 0/  ! (NOT PRINTED BY 'TRADUM')
C-------------------------------------------------------------
C     TRES
      DATA UTRE /&UTRE/
      DATA FTRE /1/
      DATA TREHIB /&TREH/
      DATA TRECNO /1/
C-------------------------------------------------------------
      END
&END
&(BOFOG   )
      PROGRAM BOFOG
C     EXTENSIBLE TRANSLATOR MAIN PROGRAM
C     GF 12.07.80 : WITH OPEN ULIN, PARADD WITHOUT PARAMETERS
C     GF 27.12.80: DIRECT(7) = OPEN READONLY
C
      INTEGER PARASK
      EXTERNAL SCANS
      INTEGER I
     = ,WHAT    ! PARAMETER FOR 'PREPAR'
C
      CALL PARADD
      IF (PARASK('GENER',1,5,1) .NE. 0) GOTO 2
        WHAT = 6
        GOTO 1
2     CONTINUE
C---------------------------------------------------------
      WHAT = 1
      CALL PREPAR (WHAT)
      CALL GRAMAR
C---------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL DIRECT (5) ! OPEN
      CALL REORG ! META-GRAMMAR
C-------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
C------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL PARSER (SCANS) ! USER-GRAMMAR
C------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL REORG ! USER-GRAMMAR
C-----------------------------------------------------
      WHAT = WHAT + 1
      CALL DIRECT (4) ! WRITE ALL
      CALL DIRECT (6) ! CLOSE
      CALL PREPAR (WHAT)
C******************************************************
1     CONTINUE
      WHAT = WHAT + 1
      CALL DIRECT (5) ! OPEN
      CALL DIRECT (3) ! READ ALL
      CALL PREPAR (WHAT)
      I = PARASK('OUTSTA',1,6,0)
      IF (I .EQ. 0) GOTO 3
        CALL OUTSTA (I)
        STOP
3     CONTINUE
      CALL PARSER (SCANS) ! USER-PROGRAM
C-----------------------------------------------------
      CALL DIRECT (6) ! CLOSE
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL TARGET
C---------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR(WHAT)
C---------------------------------------------------------
      STOP
      END
&END
&(BOFOGTB )
BOFOG/CP/FP,BOFOG/CR/-SP=BOFOG/MP
ACTFIL=5
UNITS=7
MAXBUF=520
//
&END
&(BOFOL   )
      PROGRAM BOFOL
C     CLEAR REDUCE-ITEMS MAIN PROGRAM
C     GF 04.04.81
C
      INTEGER PARASK
      EXTERNAL SCANS
      INTEGER I
     = ,WHAT    ! PARAMETER FOR 'PREPAR'
C
      CALL PARADD
      CALL DIRECT (5) ! OPEN
      CALL DIRECT (3) ! READ ALL
      CALL SPAINI
C-----------------------------------------------------
      CALL CLEARE
C-----------------------------------------------------
      CALL DIRECT (4) ! WRITE ALL
      CALL DIRECT (6) ! CLOSE
      STOP
      END
&END
&(BOFOLTB )
BOFOL/CP/FP,BOFOL/CR/-SP=BOFOL/MP
ACTFIL=5
UNITS=7
MAXBUF=520
//
&END
&(BOFOR   )
      PROGRAM BOFOR
C     EXTENSIBLE TRANSLATOR MAIN PROGRAM
C     GF 12.07.80 : WITH OPEN ULIN, PARADD WITHOUT PARAMETERS
C     GF 27.12.80: DIRECT(7) = OPEN READONLY
C     GF 14.03.81: FOR RUN ONLY (WITHOUT GENERATION)
C
      INTEGER PARASK
      EXTERNAL SCANS
      INTEGER I
     = ,WHAT    ! PARAMETER FOR 'PREPAR'
C
      CALL PARADD
      IF (0.NE.0) GOTO 2
        WHAT = 6
        GOTO 1
2     CONTINUE
C---------------------------------------------------------
      WHAT = 1
      CALL PREPAR (WHAT)
      CALL GRAMAR
C---------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL DIRECT (5) ! OPEN
      CALL REORG ! META-GRAMMAR
C-------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
C------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL PARSER (SCANS) ! USER-GRAMMAR
C------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL REORG ! USER-GRAMMAR
C-----------------------------------------------------
      WHAT = WHAT + 1
      CALL DIRECT (4) ! WRITE ALL
      CALL DIRECT (6) ! CLOSE
      CALL PREPAR (WHAT)
C******************************************************
1     CONTINUE
      WHAT = WHAT + 1
      CALL DIRECT (5) ! OPEN
      CALL DIRECT (3) ! READ ALL
      IF (PARASK('DIRECT',1,6,0) .NE. 0)
     =  CALL ASSERT (156,WHAT,0)
      CALL PREPAR (WHAT)
      I = PARASK('OUTSTA',1,6,0)
      IF (I .EQ. 0) GOTO 3
        CALL OUTSTA (I)
        STOP
3     CONTINUE
      CALL PARSER (SCANS) ! USER-PROGRAM
C-----------------------------------------------------
      CALL DIRECT (6) ! CLOSE
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL TARGET
C---------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR(WHAT)
C---------------------------------------------------------
      STOP
      END
&END
&(BOFORTB )
BOFOR/CP/FP,BOFOR/CR/-SP=BOFOR/MP
ACTFIL=5
UNITS=7
MAXBUF=520
//
&END
&(BUCS    )
C-------GF 03.07.80 ---------------------------------- B U C S
      INTEGER BUCHIB
      INTEGER BUCKET(&BUCH)
      COMMON /BUCS/
     =  BUCHIB      ! HIGH BOUND OF 'BUCKET'
     = ,BUCKET  ! -> CHAIN OF SYMBOLS WITH SAME HASH-CODE
&END
&(CLEARE  )
      SUBROUTINE CLEARE
C     CLEAR REDUCE- AND SHIFT-ITEMS
C     GF 16.07.80
C      GF 04.04.81: DO NOT 'CLEARE' ITEMS FOR IDENTIFIERS/KEYWORDS
C
C     ALL ITEMS FOR THE 1ST REDUCTION ARE DELETED FROM THE STATES
C     AND REPLACED BY AN ITEM WITH DUMMY LOOK-AHEAD 'EOP'
C     (EVEN THE 1ST MAY NOT EXIST, OR MAY BE THE ONLY ONE)
C
C     FOR SHIFT-ITEMS FOR THE SAME SYMBOL ALL BUT THE 1ST
C     MARKED PRODUCTION ARE DELETED, IF PARAMETER 'CLEASH' = 1
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (PROS)
      %INCLUDE (STAS)
      %INCLUDE (STASTRS)
      %INCLUDE (SYMS)
      INTEGER PARASK
      INTEGER ZZCR
      INTEGER I1,I2   ! -> 2 SUCCESSIVE ITEMS
     = ,CLEASH  ! = 'SHIFT' (0) IFF SHIFT-ITEMS ARE (NOT) TO BE CLEARED
     = ,DERED   ! NUMBER OF DELETED REDUCE-ITEMS
     = ,DESHI   ! ... SHIFT-ITEMS
     = ,GOT     ! RESULT OF 'ITEMA2'
     = ,MAXITE  ! MAX. NO. OF ITEMS IN A STATE BEFORE DELETION
     = ,NUMITE  ! NUMBER OF ITEMS IN A PARITCULAR STATE
      INTEGER POS  ! -> 1ST CHARACTER OF 'SYMBOL'
     = ,RED     ! THE 1ST REDUCTION
     = ,RED2    ! AN EVENTUALLY PRESENT 2ND REDUCTION
     = ,STATE   ! ONE OF ALL STATES IN THE PARSING TABLE
     = ,STATEA  ! A SUCCESSOR OF 'STATE'
     = ,SUMITE  ! NUMBER OF ITEMS IN ALL STATES BEFORE DELETION
     = ,SYMBOL  ! IS THIS SYMBOL A KEYWORD OR IDENTIFIER ?
C
      DERED = 0
      DESHI = 0
      MAXITE = 0
      SUMITE = 0
      CLEASH = PARASK ('CLEASH',1,6,1) ! 1 => CLEASH = SHIFT
      DO 1 STATE = 2,FSTA
        IF (STAITE(STATE) .EQ. 0) GOTO 2 ! STATE EXISTS
          NUMITE = 0
          RED = 0  ! 1ST DOES NOT EXIST
          RED2 = 0 ! 2ND DOES NOT EXIST
          STATEA=0 ! SUCCESSOR DOES NOT YET EXIST
          CALL ITEMA2 (STATE,  I1,I2,GOT)
3         IF(I2 .GE. ITEHIB) GOTO 4 ! FOR ALL ITEMS 'I2'
            NUMITE = NUMITE + 1
            IF (ITEACT(I2) .NE. REDUCE) GOTO 5
            SYMBOL = ITESYM(ITEM)
            POS = SYMPOS(SYMBOL)
            IF (ZZCR (STRNG,POS,POS,'A',1,1) .GE. 0) GOTO 5
C             HERE IT IS NO IDENTIFIER OR KEYWORD
              IF (RED .NE. 0) GOTO 6 ! 1ST RED IN THE STATE
                RED = ITESUC(I2)
6             CONTINUE
              IF (ITESUC(I2) .NE. RED)
     =          GOTO 100 ! KEEP
              DERED = DERED + 1 ! WILL BE DELETED
            GOTO 7
5           CONTINUE ! .NE. REDUCE
            IF (ITEACT(I2) .NE. CLEASH) GOTO 8
              IF (ITESUC(I2) .EQ. STATEA) GOTO 9
                STATEA = ITESUC(I2)
                GOTO 100 ! KEEP
9             CONTINUE
              DESHI = DESHI + 1 ! WILL BE DELETED
            GOTO 7
8           CONTINUE
            GOTO 100 ! KEEP
7           CONTINUE
C
101         CONTINUE ! DELETE:
            ITE(I1) = ITE(I2)
            ITE(I2) = FITE
            FITE = I2
            I2 = I1
C
100         CONTINUE ! KEEP:
            I1 = I2
            I2 = ITE(I1)
          GOTO 3
4         CONTINUE ! ALL ITEMS
C
          IF (NUMITE .GT. MAXITE) MAXITE = NUMITE
          SUMITE = SUMITE + NUMITE
C
          IF (RED .EQ. 0) GOTO 10
C           INSERT 'RED' WITH DUMMY LA 'EOP'
            DERED = DERED - 1
            I1 = 1
            I2 = ITE(I1)
            CALL ITEALL (EOP,PROMON(RED)+PROLNG(RED),REDUCE,RED, I1,I2)
            IF (RED2 .EQ. 0) GOTO 11
              CALL ASSERT(60,STATE,RED2)
C               STATE @ CONTAINS AT LEAST A 2ND REDUCTION @
11          CONTINUE
10        CONTINUE ! RED .NE. 0
          CALL ITEMA9 (STATE,GOT)
2       CONTINUE ! STATE EXISTS
1     CONTINUE ! ALL STATES
C
      CALL INFSTO (6,MAXITE,SUMITE)
      CALL ASSERT (130,DERED,DESHI)
C       @ REDUCE- AND @ SHIFT-ITEMS DELETED
      RETURN
      END
&END
&(CODASS  )
      SUBROUTINE CODASS(CHARN,CHARS,CHARE,CODE)
C     ASSIGN A 'CODE' FOR ALL CHARACTERS OF 'CHARS'
C
      %INCLUDE(PARS)
      %INCLUDE(CODS)
      INTEGER I
     = ,CHARS   ! 1ST POS IN 'CHARS'
     = ,CHARE   ! LAST ...
     = ,CHARN (1) ! ASSIGN 'CODE' TO THESE CHARACTERS
     = ,CODE    ! CODE TO BE ASSIGNED
     = ,TABPOS   ! CORRESPONDS,THE FIXED VALUE OF THE CHARACTER IN 'CH2'
C
      CODE = FCOD
      FCOD = FCOD + 1
      DO 2 I = CHARS,CHARE
        CALL ZZCI(CHARN,I,TABPOS)
        TABPOS = TABPOS + 1
        CODTAB(TABPOS) = CODE
2     CONTINUE
      RETURN ! CODASS
      END
&END
&(CODGET  )
      SUBROUTINE CODGET
C     GET THE CODE OF THE NEXT CHARACTER IN THE INPUT
C
      %INCLUDE (PARS)
      %INCLUDE (CODS)
      %INCLUDE (LINS)
C
      CALL ZZCI (LINE,FLIN,SC)
      FLIN = FLIN + 1
      SC = SC + 1
      SC = CODTAB(SC)
      RETURN
      END
&END
&(CODINI  )
      SUBROUTINE CODINI(CODE)
C     INITIALIZE THE CODE-TABLE
C
      %INCLUDE(PARS)
      %INCLUDE(CODS)
      INTEGER I
     = ,TABPOS
     = ,CODE
C
      CODHIB = &CODH
      CODE = 1
      DO 1 I = 1,CODHIB
        CODTAB(I) = CODE ! CLEAR TABLE WITH CODE 'INVALID'
1     CONTINUE
      FCOD = CODE + 1
      RETURN ! CODINI
      END
&END
&(CODS    )
C-------GF 03.07.80------------------------------- C O D S
      INTEGER FCOD,CODHIB,SC
      INTEGER CODTAB(&CODH)
      COMMON /CODS/
     =  FCOD      ! NEXT CODE TO BE ASSIGNED
     = ,CODHIB      ! HIGH BOUND OF 'CODTAB'
     = ,CODTAB      ! SCANNER TRANSLATES IN THESE CODES
     = ,SC      ! THE NEXT CHARACTER FOR THE SCANNER
&END
&(COMPIL  )
      PROGRAM COMPIL
C     READ A TKB-LISTING AND EXTRACT ALL MODULS WHICH REFER
C     THE SPECIFIED COMMON-BLOCKS, GENERATE A COMMAND-FILE
C     GF 30.07.80
C
      %INCLUDE (PARS)
      INTEGER USOR,SORBUF(66)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      INTEGER ZZCR
      INTEGER NAME(3),I,L
      INTEGER J
C
      UPAR = 5
1     CONTINUE
      USOR = 4
      UTAR = 3
      OPEN (UNIT=USOR,NAME='SY:BOFOG.MAP',TYPE='OLD'
     = )
      I = 100
      CALL HAINIT
      CALL SPEINI
C
11    CONTINUE
C     READ THE DESIRED COMMON-BLOCK-NAME
      WRITE (UPAR,2)
2     FORMAT('$COMMON-Block-Name: ')
      READ (UPAR,3,END=13) NAME
3     FORMAT(3A2)
      IF(NAME(1) .EQ. '  ') GOTO 8
      REWIND USOR
4     CONTINUE
      READ (USOR,5,END=7) SORBUF
5     FORMAT(66A2)
      IF (ZZCR(SORBUF,1,6,NAME,1,6) .NE. 0) GOTO 4
6     CONTINUE
      READ (USOR,5,END=7) SORBUF
      IF(SORBUF(1) .NE. '  ') GOTO 4
      CALL SPEINS (SORBUF,48,53,I)
      GOTO 6
C
7     CONTINUE ! END OF FILE
      GOTO 11
C
8     CONTINUE ! LAST NAME READ
      I = SYMLNK(SPEH)
      OPEN (UNIT=UTAR,NAME='SY:COMPIL.CMD',TYPE='NEW'
     = )
9     IF(I .GE. SYMHIB - 1) GOTO 12
        CALL ZZCC(STRNG,SYMPOS(I),SYMEND(I),NAME,1,6)
        WRITE (UTAR,10) NAME
10      FORMAT(' INC X.FTN=BOFOR/LB:',3A2
     =        /' F4P X=X/TR:NAMES'
     =        /' LBR BOFOR=X/RP'
     = )
        CALL ZZWC (STRNG,SYMPOS(I),SYMEND(I),8)
        I = SYMLNK(I)
      GOTO 9
12    CONTINUE
        CALL ZZWS (0)
      CLOSE (UNIT=USOR)
      CLOSE (UNIT=UTAR)
      GOTO 1
13    CONTINUE
      STOP
      END
&END
&(COMPILTB)
COMPIL/CP/FP=BOFOR/LB:COMPIL:BLODAT,BOFOR/LB
&END
&(COUNT   )
      SUBROUTINE COUNT (COUNTR)
C     RETURN VALUES 1,2,3,... FOR SUCCESSIVE CALLS IN 'COUNTR'
C
      INTEGER COUNTR
     = ,FCOU ! INTERNAL NEXT VALUE
      COUNTR = FCOU
      FCOU = FCOU + 1
      RETURN ! COUNT
C---------------------------------------------------------
      ENTRY COUNTS
C
C     (RE-) SET THE INTERNAL COUNTER TO 1
      FCOU = 1
      RETURN ! COUNTS
      END
&END
&(DELTA   )
      SUBROUTINE DELTA (STATE,SYMBOL,  ACTION,SUCPRO)
C     COMPUTES THE TRANSITION-FUNCTION OF THE PUSHDOWN-AUTOMATON
C     RETURNS THE 1ST 'ITEM' IN 'STATE' WITH 'ITESYM(ITEM) = SYMBOL'
C     'ITEACT(ITEM) = ERROR' IF NO SUCH 'ITEM' EXISTS
C     GF 14.03.81: WITH 'ITEACT' INCORPORATED
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (STAS)
      %INCLUDE (STKS)
      %INCLUDE (SYMS)
      INTEGER PARASK
      INTEGER I,J
     = ,ACTION  ! THE RESULTING PARSER ACTION
     = ,GOT     ! RESULT OF 'ITEMA1'
     = ,ITEM     ! -> 1ST ITEM IN 'STATE' THAT HAS 'ITESYM(ITEM)=SYMBOL
     = ,MEMB    ! THE MEMBER AT 'ITEPOS(ITEM)'
     = ,POS     ! = 'ITEPOS(ITEM)'
     = ,SUCPRO  ! THE RESULTING SUCCESSOR RESP. PRODUCTION
     = ,STATE
     = ,SYMBOL
C
      CALL ITEMA1 (STATE,  ITEM,GOT)
1     IF(ITEM .GE. ITEHIB) GOTO 2
        IF (ITESYM(ITEM) .EQ. SYMBOL)
     =    GOTO 100
        ITEM = ITE(ITEM) ! TRY NEXT
      GOTO 1
2     CONTINUE ! ALL ITEMS
C     HERE THE SYMBOL WAS NOT FOUND - ERROR
      ACTION = ERROR
C     PERHAPS WE MAY 'ASSUME' A REDUCTION ?
      I = STAITE(STATE)
      SUCPRO = ITEPOS(I)
      IF (MEM(SUCPRO) .NE. EOP) GOTO 4
        ACTION = REDUCE
        ITEM = I
4     CONTINUE
      GOTO 3
C     HERE IT WAS FOUND
100   CONTINUE
      POS = ITEPOS(ITEM)
      MEMB = MEM(POS)
      IF (MEMB .LE. EOFILE) GOTO 6 ! 'EOFILE' OR 'EOP'=REDUCE
        ACTION = SHIFT
        GOTO 3
6     CONTINUE
      IF (MEMB .NE. EOP) GOTO 7
        ACTION = REDUCE
        GOTO 3
7     CONTINUE
      IF (MEMB .NE. EOFILE)
     =  CALL ASSERT (10,MEMB,POS)
C         INVALID MEMBER @ AT POSITION @
        ACTION = ACCEPT
        IF (0.EQ.0) GOTO 3
      IF (PARASK('DELTA',1,5,0) .EQ. 0) GOTO 3
        CALL ZZWC('STACK: ',1,7,0)
        J = FSTK - 1
        DO 5 I = 2,J
          CALL ZZWC('|',1,1,0)
          CALL ZZWI (STKSTA(I),4)
          CALL ZZWC(',',1,1,0)
          CALL PUTSYM (STKSYM(I))
5       CONTINUE
        CALL ZZWC (', ',1,2,0)
        CALL PUTSYM (SYMBOL)
        CALL PUTACT (ITEM)
        CALL ZZWS(0)
3     CONTINUE ! PARASK('DELTA')
      SUCPRO = ITESUC(ITEM)
      CALL ITEMA8 (STATE,GOT)
      RETURN! DELTA
      END
&END
&(DIRECT  )
      SUBROUTINE DIRECT (CODE)
C     ACCESS TO THE DIRECT-FILE 'UDIR'
C     GF 24.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (BUCS)
      %INCLUDE (DIRS)
      %INCLUDE (SEMS)
      %INCLUDE (STAS)
      %INCLUDE (STASTRS)
      %INCLUDE (SYMS)
      %INCLUDE (TRES)
      INTEGER PARASK
      INTEGER I
     = ,CODE    ! 1: READ OVL, 2: WRITE OVL, 3: READ ALL, 4: WRITE ALL
     =          ! 5: OPEN, 6: CLOSE
     = ,LENGTH  ! FOR TRANSMIT "ALL", SEE BELOW
      COMMON /STAT3/ LENGTH
C
      FDIR = STAHIB
      IF (CODE .GE. 5) GOTO 4
      IF (CODE .LE. 2) GOTO 4
C       READ/WRITE ALL: DETERMINE 'LENGTH' BY A TRICK
C       DEC-TKB ALLOCATES COMMONS IN ALPHABETICAL ORDER
C       'BUCHIB' IS FIRST, 'TRE(TREHIB)' IS LAST
        TRE(TREHIB-1) = -29647
        TRE(TREHIB)   = -29647
        DO 1 I = 1,32767 ! IF THERE WERE MORE SPACE FOR COMMONS - ?
C                THE EXTRA-IMPLEMENTOR WOULD HAVE BEEN LUCKY !!
          IF (BUCKET(I) .NE. -29647 .OR. BUCKET(I-1) .NE. -29647) GOTO 2
            LENGTH = I
            GOTO 3
2         CONTINUE
1       CONTINUE
3       CONTINUE
4     CONTINUE
      IF (PARASK('DIRECT',1,6,0) .NE. 0)
     =  CALL ASSERT (155,FDIR,LENGTH)
      GOTO (101,102,103,104,105,106,107),CODE
C----------------------------------------------------------------
101   CONTINUE
      CALL DIRREA (SYMPOS,SYMHIB)
      CALL DIRREA (SYMLNK,SYMHIB)
      CALL DIRREA (SEM   ,2*SEMHIB) ! 'SEMSYM' IS ADJACENT
      CALL DIRREA (STRNG ,STRHIB/2   )
      SYMLNK(1) = 1 ! SYMBOLS ARE PRINTABLE
      GOTO 99
C----------------------------------------------------------------
102   CONTINUE
      CALL DIRWRI (SYMPOS,SYMHIB)
      CALL DIRWRI (SYMLNK,SYMHIB)
      CALL DIRWRI (SEM   ,2*SEMHIB) ! 'SEMSYM' IS ADJACENT
      CALL DIRWRI (STRNG ,STRHIB/2   )
      SYMLNK(1) = 0 ! SYMBOLS ARE NOT PRINTABLE
      GOTO 99
C----------------------------------------------------------------
103   CONTINUE
      CALL DIRREA (BUCKET,LENGTH)
      IF (PARASK('DIRECT',1,6,0) .NE. 0)
     =  CALL ASSERT (157,LENGTH,0)
      GOTO 99
C----------------------------------------------------------------
104   CONTINUE
      CALL DIRWRI (BUCKET,LENGTH)
      GOTO 99
C----------------------------------------------------------------
105   CONTINUE
      DIRHIB = PARASK ('DIRHIB',1,6,256)
      IF (PARASK('DAIO',1,4,1) .NE. 0) GOTO 1051
      OPEN (UNIT=UDIR,NAME='SY:DIRECT.DAT',TYPE='UNKNOWN'
     = ,ACCESS='DIRECT',RECORD SIZE=DIRHIB/2,ASSOCIATE VARIABLE=FDIR
     = ,MAXREC=32767/DIRHIB+STAHIB
     = ,SHARED)
      GOTO 99
1051  CONTINUE ! WITH 'DAIO'
      OPEN (UNIT=UDIR,NAME='SY:DIRECT.DAT',TYPE='UNKNOWN'
     = ,ACCESS='DIRECT',RECORD SIZE=DIRHIB/2,ASSOCIATE VARIABLE=FDIR
     = ,MAXREC=32767/DIRHIB+STAHIB
     = ,SHARED,BUFFERCOUNT=-1)
      GOTO 99
C----------------------------------------------------------------
106   CONTINUE
      CLOSE (UNIT=UDIR)
      GOTO 99
C----------------------------------------------------------------
107   CONTINUE
C----------------------------------------------------------------
99    CONTINUE
      RETURN
      END
&END
&(DIRREA  )
      SUBROUTINE DIRREA (ARRAY,LNG)
C     READ DIRECT-FILE
C     GF 24.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (DIRS)
      INTEGER PARASK
      INTEGER I
     = ,LNG     ! NUMBER OF ELEMENTS IN 'ARRAY'
     = ,ARRAY(1) ! TRANSMIT FROM/TO THIS ARRAY
C
      HIGH = 0
1     CONTINUE
        HIGH = HIGH + DIRHIB
        IF (HIGH .LE. LNG) GOTO 6
C         HERE IS 'HIGH .GT. LNG' - DUPLICATE SOME ELEMENTS
          HIGH = LNG
6       CONTINUE
        LOW = HIGH - DIRHIB + 1
        IF (LOW .LT. 0)
     =    CALL ASSERT (162,LNG,DIRHIB)
        IF (PARASK('DAIO',1,4,1) .NE. 0) GOTO 2
        READ  (UDIR'FDIR) (ARRAY(I),I=LOW,HIGH)
        GOTO 3
2       CONTINUE
          DECB(1) = UDIR
          DECB(2) = 1
          FDIR4 = FDIR
          FDIR = FDIR + 1
          CALL DAREAD (DECB,ARRAY(LOW),FDIR4,1)
          CALL DAWAIT (DECB)
          IF (DECB(5) .NE. 0) CALL ASSERT (10,DECB(5),0)
3       CONTINUE
      IF (HIGH .LT. LNG) GOTO 1
      RETURN
      END
&END
&(DIRS    )
C-------GF 18.09.80--------------------------------------- D I R S
      INTEGER FDIR,DIRHIB,LOW,HIGH
      INTEGER DECB(5)
      INTEGER*4 FDIR4
      COMMON /AAAAAA/  ! BEFORE ALL OTHER COMMONS
     =  FDIR    ! NEXT FREE RECORD (=ASSOCIATE VARIABLE)
     = ,DIRHIB  ! LENGTH OF A RECORD IN INTEGER-ELEMENTS
     = ,LOW     ! -> ARRAY-ELEMENT WHICH COMES IN LOW BUFFER
     = ,HIGH    ! ... HIGH ...
     = ,DECB    ! DATA-EVENT CONTROL BLOCK FOR 'DAIO'
     = ,FDIR4   ! BLOCK NUMBER FOR 'DAIO'
&END
&(DIRWRI  )
      SUBROUTINE DIRWRI (ARRAY,LNG)
C     WRITE DIRECT-FILE
C     GF 24.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (DIRS)
      INTEGER PARASK
      INTEGER I
     = ,LNG     ! NUMBER OF ELEMENTS IN 'ARRAY'
     = ,ARRAY(1) ! TRANSMIT FROM/TO THIS ARRAY
C
      HIGH = 0
1     CONTINUE
        HIGH = HIGH + DIRHIB
        IF (HIGH .LE. LNG) GOTO 6
C         HERE IS 'HIGH .GT. LNG' - DUPLICATE SOME ELEMENTS
          HIGH = LNG
6       CONTINUE
        LOW = HIGH - DIRHIB + 1
        IF (PARASK('DAIO',1,4,1) .NE. 0) GOTO 4
        WRITE  (UDIR'FDIR) (ARRAY(I),I=LOW,HIGH)
        GOTO 5
4       CONTINUE
          DECB(1) = UDIR
          DECB(2) = 1
          FDIR4 = FDIR
          FDIR = FDIR + 1
          CALL DAWRTE (DECB,ARRAY(LOW),FDIR4,1)
          CALL DAWAIT (DECB)
          IF (DECB(5) .NE. 0) CALL ASSERT (9,DECB(5),0)
5       CONTINUE
        IF (PARASK('DIRWRI',1,6,0) .EQ. 0) GOTO 2
          CALL ASSERT (153,LOW,HIGH)
          DO 3 I=LOW,HIGH
            ARRAY(I) = 07952
3         CONTINUE
2       CONTINUE
      IF (HIGH .LT. LNG) GOTO 1
      RETURN
      END
&END
&(EMITT   )
      SUBROUTINE EMITT (STATEZ,PRODZ,APPLY)
C     CALLS 'APPLY(STATEB,STATEZ,PRODZ)' FOR ALL 'STATEB' THAT GIVE
C       LOOK-AHEAD SYMBOLS,REDUCTION 'PRODZ' IN 'STATEZ'
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (PRES)
      %INCLUDE (PROS)
      %INCLUDE (SETS)
      %INCLUDE (STAS)
      INTEGER I
     = ,ACTION  ! RESULT OF 'DELTA'
     = ,ITEM     ! -> AN ITEM IN 'STATEB'
     = ,LEFT     ! THE LEFT SIDE OF 'PRODZ'
     = ,PRED     ! -> PREDECESSORS OF 'STATEB'
     = ,PRODZ    ! THIS PRODUCTION IN 'STATEZ' GETS THE SYMBOLS
     = ,STATE    ! A STATE IN THE TARGET SET
     = ,STATEB   ! THIS STATE EMITTS THE SYMBOLS
     = ,STATEZ   ! THIS STATE GETS THE SYMBOLS
     = ,SUCPRO  ! RESULT OF 'DELTA'
     = ,TARGET   ! ->,AN ELEMENT OF THE SET GENERATED,MOVING BACK 1
     = ,TEMP     ! FOR INTERCHANGING SOURCE AND TARGET
C
      ! EMITTH = EMITTT, EMITSH = EMITST
      CALL SEPUSH(STAMAR,STATEZ,EMITST,EMITSB) ! START WITH 'STATEZ
      STAMAR(STATEZ) = STAMAR(STATEZ) - EMITSB
        ! DO NOT MARK IN 'EMITS'-SET
C
      ! MOVE THE MARKER BACK 'PROLNG' POSITS IN A TREE OF STATES
      I = 1
1     IF(I .GT. PROLNG(PRODZ)) GOTO 2
        ! GENERATE TARGET = PRE(SOURCE)
3       IF(EMITSH .EQ. EMITST) GOTO 4
          CALL SETPOP(STAMAR,STATEB,EMITSH,0)
          PRED = STAPRE(STATEB)
5         IF(PRED .GE. PREHIB) GOTO 6
            ! COPY PREDECESSORS INTO TARGET SET
            CALL SEPUSH(STAMAR,PRESTA(PRED),EMITTT,EMITTB)
            PRED = PRE(PRED)
          GOTO 5
6         CONTINUE ! ALL PREDECESSORS
        GOTO 3
4       CONTINUE ! ALL IN SOURCE SET
C
        ! UNMARK ALL STATES IN TARGET SET
        TARGET = EMITTH
7       IF(TARGET .EQ. EMITTT) GOTO 8
          STATE = SETELE(TARGET)
          STAMAR(STATE) = STAMAR(STATE) - EMITTB
          TARGET = SET(TARGET)
        GOTO 7
8       CONTINUE ! UNMARK
C
        ! INTERCHANGE TARGET AND SOURCE SETS (THE LATTER IS EMPTY)
        TEMP = EMITSH
        EMITSH = EMITTH!
        EMITTH = TEMP!
        TEMP = EMITST
        EMITST = EMITTT!
        EMITTT = TEMP!
        I = I + 1
      GOTO 1
2     CONTINUE ! I = 1 ... PROLNG
C
      ! NOW THE MARKER IS BEFORE THE 1ST MEMBER OF 'PRODZ' IN ALL STATES
      !   IN THE SOURCE SET. SHIFT THE LEFT SIDE AND GENERATE A TARGET S
      LEFT = PROLEF(PRODZ)
9     IF(EMITSH .EQ. EMITST) GOTO 10
        CALL SETPOP(STAMAR,STATEB,EMITSH,0)
        CALL DELTA (STATEB,LEFT,  ACTION,SUCPRO)
        IF (ACTION .NE. SHIFT) GOTO 12
            CALL SEPUSH(STAMAR,SUCPRO,EMITTT,EMITTB)
            GOTO 100
12      CONTINUE ! ALL ITEMS
C       CALL ASSERT(3,LEFT,STATEB)
C       CALL ASSERT(3,ACTION,SUCPRO)
C
100     CONTINUE !        LEAVE:
      GOTO 9
10    CONTINUE ! ALL IN SOURCE SET
C
      ! NOW CALL 'APPLY' AND UNMARK THE STATES IN THE TARGET SET
14    IF(EMITTH .EQ. EMITTT) GOTO 15
        CALL SETPOP(STAMAR,STATEB,EMITTH,EMITTB)
        CALL SEPUSH(STAMAR,STATEB,LAPUTT,LAPUTB)
      GOTO 14
15    CONTINUE ! ALL IN TARGET SET
      RETURN! EMITT
      END
&END
&(ENDS    )
C--------------------------------------------------------- E N D S
&END
&(EXTRA   )
      PROGRAM EXTRA
C     EXTENSIBLE TRANSLATOR MAIN PROGRAM
C     GF 12.07.80 : WITH OPEN ULIN, PARADD WITHOUT PARAMETERS
C     GF 27.12.80: DIRECT(7) = OPEN READONLY
C
      INTEGER PARASK
      EXTERNAL SCANS
      INTEGER I
     = ,WHAT    ! PARAMETER FOR 'PREPAR'
C
      CALL PARADD
      IF (PARASK('GENER',1,5,0) .NE. 0) GOTO 2
        WHAT = 6
        GOTO 1
2     CONTINUE
C---------------------------------------------------------
      WHAT = 1
      CALL PREPAR (WHAT)
      CALL GRAMAR
C---------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL DIRECT (5) ! OPEN
      CALL REORG ! META-GRAMMAR
C-------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
C------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL PARSER (SCANS) ! USER-GRAMMAR
C------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL REORG ! USER-GRAMMAR
C-----------------------------------------------------
      WHAT = WHAT + 1
      CALL DIRECT (4) ! WRITE ALL
      CALL DIRECT (6) ! CLOSE
      CALL PREPAR (WHAT)
C******************************************************
1     CONTINUE
      WHAT = WHAT + 1
      CALL DIRECT (5) ! OPEN
      CALL DIRECT (3) ! READ ALL
      CALL PREPAR (WHAT)
      I = PARASK('OUTSTA',1,6,0)
      IF (I .EQ. 0) GOTO 3
        CALL OUTSTA (I)
        STOP
3     CONTINUE
      CALL PARSER (SCANS) ! USER-PROGRAM
C-----------------------------------------------------
      CALL DIRECT (6) ! CLOSE
      WHAT = WHAT + 1
      CALL PREPAR (WHAT)
      CALL TARGET
C---------------------------------------------------------
      WHAT = WHAT + 1
      CALL PREPAR(WHAT)
C---------------------------------------------------------
      STOP
      END
&END
&(GRAMAR  )
      SUBROUTINE GRAMAR
C     READ AND INTERPRET THE META-GRAMMAR
C     GF 12.07.80 : INT PARASK, TEST,MEMHIB=... DELETED
C     GF 19.07.80: WITHOUT 'SETS', 'GRASYB', 'FMEM'-CHECK FOR 'SEMWRI'
C           PARAMETER 'GRANOU' SETS NO 'UNCH'
C     GF 27.07.80: WITH 'EOSTMT,AXIOM'
C     GF 01.08.80: ']' TERMINATES 'RULE' TOO
C
      %INCLUDE(PARS)
      %INCLUDE(MEMS)
      %INCLUDE(PROS)
      %INCLUDE(SEMS)
      %INCLUDE(STRS)
      %INCLUDE(SYMS)
      INTEGER PARASK
      INTEGER I
     = ,ADDSUB   ! = 1(0) : ADD (SUBTRACT) A PRODUCTION
     = ,ENTITY   ! RESULT OF 'SCAN'
     = ,LEFT     ! THE LEFT SIDE OF A PRODUCTION
     = ,LNG      ! THE LENGTH OF A PRODUCTION
     = ,MON      ! -> MEMBER NUMBER ONE OF A PRODUCTION
     = ,PROD     ! -> A PRODUCTION
     = ,SEMA     ! -> THE SEMANTICS FOR A PRODUCTION
     = ,SYMBOL   ! RESULT OF 'SCAN'
     = ,SINGLE   ! = 1 (0) IF (EVERY PRODUCTION IS (NOT) PROCESS
      INTEGER TEST
C
      SINGLE = PARASK('SINGLE',1,6,0)
      TEST = PARASK('GRAMAR',1,6,0)
      CALL SCAINI
      CALL SCAN(I,EOFILE)
      CALL SCAN(I,IDENT)
      CALL SCAN(I,NUMBER)
      CALL SCAN(I,STRIN)
      CALL SPEINS('=>',1,2,ARROW)
      CALL SPEINS('|' ,1,1,BAR)
      CALL SPEINS('=' ,1,1,EQUALS)
      CALL SPEINS('-' ,1,1,MINUS)
      CALL SPEINS('.' ,1,1,PERIOD)
      CALL SPEINS(']' ,1,1,BUS)
      CALL SPEINS('[' ,1,1,SUB)
      CALL SPEINS('#' ,1,1,NUMSIG)
      CALL SPEINS('(' ,1,1,OPENP)
      CALL SPEINS(')' ,1,1,CLOSP)
      CALL SPEINS('+' ,1,1,PLUS)
      CALL SPEINS('*' ,1,1,TIMES)
      CALL SPEINS('/' ,1,1,DIVIDE)
      CALL SPEINS(';' ,1,1,I)
      CALL SCAN (I,EOSTMT)
      AXIOM = FSYM
C
      SYMBOL = 0
2     IF(SYMBOL .EQ. SUB .OR. SYMBOL .EQ. EOFILE) GOTO 1
C       PROCESS THE REST OF THE INTERFACE TO THE SCANNER
        CALL SCAN(SYMBOL,ENTITY)
        IF (SYMBOL .NE. STRIN) GOTO 3
          CALL SPEINS(STRNG,SYMPOS(ENTITY),SYMEND(ENTITY),I)
3       CONTINUE ! STRIN
      GOTO 2
1     CONTINUE ! SKIP INTERFACE
      GOTO 100
101   CONTINUE
        CALL ASSERT(50,ENTITY,-ENTITY)
100   CONTINUE
        CALL SCAN (SYMBOL,ENTITY)
        IF (TEST .NE. 0)
     =    WRITE(UPRI,20) SYMBOL,ENTITY
20        FORMAT(' --- GRAMAR-SCAN ',2I6)
130   CONTINUE
5       IF (SYMBOL .GT. BUS) GOTO 107 ! LIDEN
          GOTO (101,101,101,101,101
     =     ,106,107,108,109,110,111,112,113,114,115),SYMBOL
C           EOF IDE NUM STR  =>  |   =   -   .   ]
109   CONTINUE
        CALL SPEINS(STRNG,SYMPOS(ENTITY),SYMEND(ENTITY),I)
        ENTITY = I
108   CONTINUE
107   CONTINUE
        ! STORE THE ENTITY IN 'MEM'
        IF (FMEM .GE. MEMHIB) GOTO 7
          MEM(FMEM) = ENTITY
          FMEM = FMEM + 1
        GOTO 8 ! NO 'MEM'-OVERFLOW
7       CONTINUE
          CALL ASSERT(57,FMEM,ENTITY)
8       CONTINUE
        GOTO 100
C
112   CONTINUE
        ADDSUB = 1
131   CONTINUE
        FMEM = FMEM - 1 ! DELETE LEFT SIDE
        LEFT = MEM(FMEM)
        MON = FMEM
        SEMA = 0
        GOTO 100
113   CONTINUE
        ADDSUB = 0
        GOTO 131
110   CONTINUE
        CALL SCAN(SYMBOL,ENTITY)
        IF (SYMBOL .NE. NUMSIG) GOTO 9
          CALL SCAN(SYMBOL,ENTITY)
          IF (SYMBOL .NE. NUMBER) GOTO 11
            CALL SYMNUM(ENTITY,SEMA)
11        CONTINUE ! NUMBER
        GOTO 10 ! = NUMSIG
9       CONTINUE
          CALL ASSERT(55,SYMBOL,NUMSIG)
10      CONTINUE
12      IF(SYMBOL .EQ. PERIOD .OR. SYMBOL .EQ. BAR
     =    .OR. SYMBOL .EQ. BUS
     =  ) GOTO 13
          CALL SCAN(SYMBOL,ENTITY)
        GOTO 12
13      CONTINUE
        GOTO 130
111   CONTINUE
114   CONTINUE
115   CONTINUE ! ']'
        LNG = FMEM - MON
        CALL PROCHA(ADDSUB,LEFT,MON,LNG,PROD)
        IF (SINGLE .NE. 1) GOTO 14
C         CALL REORG
14      CONTINUE
        IF (SEMA .LE. 0) GOTO 15
          PROSEM(PROD) = FSEM
          CALL SEMWRI(0,SEPR,SEMA)
          CALL SEMWRI(0,EOS,0)
          SEMA = 0
        GOTO 18 ! SEMA .LE. 0
15      CONTINUE
          PROSEM(PROD) = PNOSEM + PARASK('GRANOU',1,6,0)
18      CONTINUE
        MON = FMEM
        IF (SYMBOL .NE. BUS)
     =    GOTO 100 ! FOR ']' FALL THROUGH
106   CONTINUE
        RETURN
      END
&END
&(HAINIT  )
      SUBROUTINE HAINIT
C     INITIALIZE 'STRS' AND 'BUCS'
C
      %INCLUDE (PARS)
      %INCLUDE (BUCS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      INTEGER I
C
      FSTR = 2
      SYMPOS(FSYM) = FSTR ! ALWAYS, FOR 'HAMAP'
      DO 7 I = 1, BUCHIB
        BUCKET(I) = SYMHIB ! ALL LISTS ARE EMPTY
7     CONTINUE !,BUCHIB
      RETURN ! HAINIT
      END
&END
&(HAMAP   )
      SUBROUTINE HAMAP(SYMBOL)
C     MAP THE SYMBOL STORED BY PREVIOUS CALLS OF 'HAPSE'
C     GF 12.07.80 : WITH PARASK('HAMAP')
C
      %INCLUDE (PARS)
      %INCLUDE (BUCS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      INTEGER PARASK
      INTEGER I
     = ,BUC      ! THE RESULT OF THE HASHING FUNCTION
     = ,POE     ! -> LAST CHARACTER
     = ,POS
     = ,LNG
     = ,BF15
     = ,BF31
     = ,SYMBOL
      INTEGER ZZCR
C
      POS = SYMPOS(FSYM) ! THE TAIL OF 'STRNG'
      LNG = FSTR - POS
      POE = POS + LNG - 1
      ! MAP A STRING TO A NUMBER IN (1:BUCHIB)
      ! GLOBAL: 'POS,LNG,BUCHIB'
      BF31 = LNG
      CALL ZZCI (STRNG,POS,BF15)
      BF31 = BF31 + BF15
      CALL ZZCI (STRNG,POE,BF15)
      BF31 = BF31 + BF15
      BF15 = BUCHIB - 1
      BUC = MOD(BF31,BF15) + 1
      SYMBOL = BUCKET(BUC)
2     IF(SYMBOL .GE. SYMHIB) GOTO 3 ! LOOK FOR THE SAME STRING
        IF (ZZCR (STRNG,POS,POE
     =           ,STRNG,SYMPOS(SYMBOL),SYMEND(SYMBOL)) .NE. 0)
     =  GOTO 4
          FSTR = SYMPOS(FSYM) ! DELETE THE TAIL
          GOTO 101 ! DONMAP
4       CONTINUE ! FOUND
        SYMBOL = SYMLNK(SYMBOL) ! TRY NEXT IN THE LIST
      GOTO 2
3     CONTINUE ! WHILE .GE. SYMHIB
      ! THE NEW STRING WAS NOT FOUND, ALLOCATE A NEW SYMBOL
      IF (FSYM .GE. SYMHIB) GOTO 5
        SYMBOL = FSYM
        FSYM = FSYM + 1!
        SYMPOS(FSYM) = FSTR
C       SYMEND(SYMBOL) = POE ! 'SYMPOS' IS ALREADY O.K.
        ! PREFIX THE NEW SYMBOL TO THE LIST
        SYMLNK(SYMBOL) = BUCKET(BUC)
        BUCKET(BUC) = SYMBOL
      GOTO 6 ! NO 'SYM'-OVERFLOW
5     CONTINUE
        CALL ASSERT(7,SYMHIB,FSTR)
6     CONTINUE
C
101   CONTINUE!      DONMAP:
      IF(PARASK('HAMAP',1,5,0) .EQ. 0) GOTO 7
        CALL ZZWC (' HAMAP: ',1,7,0)
        CALL PUTSYM (SYMBOL)
        CALL ZZWS (0)
7     CONTINUE
      RETURN ! HAMAP
      END
&END
&(HAPSE   )
      SUBROUTINE HAPSE (CHARN,CHARS,CHARE)
C     APPEND A STRING TO THE SYMBOL IN SPE
C
      %INCLUDE (PARS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      INTEGER CHARS,CHARE,CHARN(1)
     = ,LNGPEN  ! THE LENGTH OF THE STRING TO BE APPENDED
C
      LNGPEN = CHARE - CHARS + 1
      IF (LNGPEN .LE. 0)
     =  RETURN
      IF (FSTR + LNGPEN .GT. STRHIB) GOTO 8
        CALL ZZCC (CHARN,CHARS,CHARE,STRNG,FSTR,FSTR+LNGPEN-1)
        FSTR = FSTR + LNGPEN
      GOTO 9
8     CONTINUE
        CALL ASSERT(2,STRHIB,FSYM)
9     CONTINUE
      RETURN ! HAPSE
      END
&END
&(HEADER  )
      SUBROUTINE HEADER (FILE,FILNG,PAGE)
C     WRITES A HEADER ON THE LISTING FILE
C     GF 27.07.80
C
      %INCLUDE (PARS)
      INTEGER I
     = ,FILE(10)  ! THE NAME OF THE SOURCE-FILE
     = ,FILNG   ! LENGTH OF THE FILE-NAME 'FILE'
     = ,PAGE      ! CURRENT PAGE-NUMBER OF THE LISTING
     = ,TEXT(4)   ! STORE TIME HERE
     = ,TEXD(5)   ! STORE DATE HERE
      CALL TIME (TEXT)
      CALL DATE (TEXD)
      WRITE (UPRI,1) TEXT,TEXD,PAGE
1     FORMAT('1BOFOR PRECOMPILER V01-03        '
     = ,4A2,4X,4A2,A1,10X,'PAGE',I3
     = )
      CALL ZZWC(FILE,1,FILNG,0)
      CALL ZZWS (0)
      CALL ZZWC(' ',1,1,0)
      CALL ZZWS (0)
      RETURN
      END
&END
&(INDEX   )
      INTEGER FUNCTION INDEX (CHARN,CHARS,CHARE,SEARCH)
C     -> PL/1, 2ND PARAMETER ONLY 1 CHARACTER
C     GF 21.07.80
C
      INTEGER ZZCR
      INTEGER CHARN(1),CHARS,CHARE ! CHARACTERS WITH START- AND END-POS.
      INTEGER SEARCH ! LOOK FOR THIS CHARACTER
      INTEGER I
C
      DO 1 I = CHARS,CHARE
        IF (ZZCR(CHARN,I,I,SEARCH,1,1) .NE. 0) GOTO 1
          INDEX = I
          GOTO 99
1     CONTINUE
C     'SEARCH' WAS NOT FOUND HERE
      INDEX = 0
99    CONTINUE
      RETURN
      END
&END
&(INFOUT  )
      SUBROUTINE INFOUT
C     INFORM ABOUT STORAGE AND CPU-TIME USED BY THE GENERATOR
C     GF 26.07.80: WITH 'INFMAX'
C
      %INCLUDE (PARS)
      %INCLUDE (INFS)
      INTEGER PARASK
      INTEGER I
     = ,A(1)     ! POINTERS OF THE LINKED LIST
     = ,AHIB     ! HBOUND(A,1)
     = ,FA       ! -> 1ST FREE ELEMENT IN THE LIST
     = ,NAME(3)      ! FOR 'INSTAR'
     = ,NUM      ! ACCUMULATED NUMBER IN 'INFLIS'
     = ,ORD      ! STORE IN 'INFORM(ORD)'
     = ,VAL
     = ,VALMAX  ! PARAMETER OF 'INFSTO'
      INTEGER SECNDS ! RSX-11M LIBRARY FUNCTION
      SECNDS(I) = 0 ! STATEMENT-FUNCTION
C
      WRITE(UPRI,2) (INFORM(I),INFMAX(I),I=1,9)
2       FORMAT(' -------------------------------------'
     = / ' STATISTICS FOR THE GRAMMAR'
     = /1X,I5,3H (<,I5,1H),' SYMBOLS'
     = /1X,I5,3H (<,I5,1H),' PRODUCTIONS'
     = /1X,I5,3H (<,I5,1H),' MEMBERS '
     = /1X,I5,3H (<,I5,1H),' CHARACTERS IN THE HASHTABLE'
     = /1X,I5,3H (<,I5,1H),' STATES'
     = /1X,I5,3H (<,I5,1H),' ITEMS'
     = /1X,I5,3H (<,I5,1H),' PREDECESSOR STATES'
     = /1X,I5,3H (<,I5,1H),' NUCLEUS ENTRIES'
     = /1X,I5,3H (<,I5,1H),' SEMANTIC ACTIONS'
     = /       ' -------------------------------------')
C$      WRITE(UPRI,1) (INFNUM(I),INFSUM(I),I=1,&INFH)
C$1     FORMAT(' NUMBER OF CALLS AND ELAPSED SECONDS'
C$     = /1X,I5,' * STASUC: ',F7.3
C$     = /1X,I5,' * LAGAR : ',F7.3
C$     = /1X,I5,' * STAGAR: ',F7.3
C$     = /1X,I5,' * LAGET : ',F7.3
C$     = /1X,I5,' * LAPUT : ',F7.3
C$     = /1X,I5,' * XXXXX : ',F7.3
C$     = /1X,I5,' * REORG : ',F7.3
C$     = /1X,I5,' * XXXXX : ',F7.3
C$     = /1X,I5,' * XXXXX : ',F7.3
C$     = /1X,I5,' * XXXXX : ',F7.3
C$     = /1X,I5,' * XXXXX : ',F7.3
C$     = /1X,I5,' * XXXXX : ',F7.3
C$     =  )
      RETURN ! INFOUT
C-------------------------------------------------------------------
      ENTRY INFLIS (ORD,A,FA,AHIB)
C     STORE THE NUMBER OF OCCUPIED ELEMENTS
C
      NUM = AHIB - 1
      I = FA
3     IF(I .GE. AHIB) GOTO 4
        I = A(I)
        NUM = NUM - 1
        IF (NUM .GE. 0) GOTO 5 ! LIST HAS A CYCLE
          CALL ASSERT(18,AHIB,FA)
          RETURN
5       CONTINUE ! CYCLE
      GOTO 3
4     CONTINUE ! WHILE .GE. AHIB
      INFORM(ORD) = NUM
      INFMAX(ORD) = AHIB
      RETURN ! INFLIS
C-------------------------------------------------------------------
      ENTRY INFSTO (ORD,VAL,VALMAX)
C     STORE A VALUE
C
      INFORM(ORD) = VAL
      INFMAX(ORD) = VALMAX
      RETURN ! INFSTO
C-------------------------------------------------------------------
      ENTRY INSTAR (NAME,ORD)
C     START THE TIME-MEASUREMENT
      INFNUM(ORD) = INFNUM(ORD) + 1
      INFBEG(ORD) = 0
      INFBEG(ORD) = SECNDS(INFBEG(ORD))
      IF (PARASK('INSTAR',1,6,1) .EQ. 0) RETURN
      CALL ZZWC(NAME,1,6,0)
      CALL ZZWS (0)
      RETURN ! INSTAR
C-------------------------------------------------------------------
      ENTRY INSTOP (ORD)
C     STOP THE TIME-MEASUREMENT
C
      INFSUM(ORD) = INFSUM(ORD) + SECNDS(INFBEG(ORD))
C      = MILLISECONDS
      RETURN ! INSTOP
      END
&END
&(INFS    )
      %PARAMETER INFH=10
      INTEGER INFORM(&INFH)
      INTEGER INFMAX(&INFH)
      INTEGER INFNUM(&INFH)
      INTEGER    INFBEG(&INFH),INFSUM(&INFH)
      COMMON /INFS/
     =  INFORM  ! STORE STATISTICS IN THIS ARRAY
     = ,INFMAX  ! 'INFORM' IS ALWAYS < 'INFMAX'
     = ,INFBEG  ! CPU-TIME AT THE BEGINNING
     = ,INFSUM  ! CUMMULATIVE CPU-TIME
     = ,INFNUM  ! NUMBER OF CALLS OF 'INFTIM(ORD)'
&END
&(ITEACT  )
      INTEGER FUNCTION ITEACT (ITEM)
C     REPLACES AN ARRAY
C     GF 29.08.80
C
      %INCLUDE (PARS)
        INTEGER FITE,ITEHIB,ACCEPT,REDUCE,SHIFT,ERROR
        INTEGER ITE(&ITEH),ITESYM(&ITEH),ITEPOS(&ITEH)
        INTEGER ITESUC(&ITEH)
        COMMON /ITES/
     =  FITE
     = ,ITEHIB
     = ,ACCEPT  ! PARSER ACTION, OCCURS ONLY ONCE IN STATE 3
     = ,REDUCE  !       <= 'SHIFT'
     = ,SHIFT   !       >= 'REDUCE'
     = ,ERROR   ! GENERATED BY 'DELTA'
     = ,ITE     ! -> NEXT ITEM IN A STATE
     = ,ITESYM  ! THE MARKED SYMBOL
     = ,ITEPOS  ! THE MARKER IS BEFORE THIS MEMBER
     = ,ITESUC  ! SHIFT: SUCCESSOR, REDUCE: PRODUCTION
      %INCLUDE (MEMS)
      %INCLUDE (SYMS)
      INTEGER ITEM
     = ,POS     ! -> 'MEM'
C
      IF (ITEM .NE. ITEHIB) GOTO 1
        ITEACT = ERROR
        GOTO 99
1     CONTINUE
      POS = ITEPOS(ITEM)
      IF (MEM(POS) .NE. EOP) GOTO 2
        ITEACT = REDUCE
        GOTO 99
2     CONTINUE
      IF (MEM(POS) .NE. EOFILE) GOTO 3
        ITEACT = ACCEPT
        GOTO 99
3     CONTINUE
        ITEACT = SHIFT
99    CONTINUE
      RETURN
      END
&END
&(ITEALL  )
      SUBROUTINE ITEALL (SYMBOL,POSIT,ACTION,SUCPRO,  I1,I2)
C     ALLOCATE AN ITEM
C     GF 20.08.80
C     GF 28.12.80: WITH 'SPAFRE'
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (SPAS)
      INTEGER
     =  ACTION  ! SET THIS ACTION IN 'ITEACT'
     = ,I1      ! -> BEFORE THE NEW ITEM
     = ,I2      ! INSERT BETWEEN 'I1' AND 'I2'
     = ,ITEM    ! -> THE NEW ITEM
     = ,POSIT   ! = 'ITEPOS'
     = ,SUCPRO  ! = 'ITESUC'
     = ,SYMBOL  ! = 'ITESYM'
C
      IF (FITE .LT. ITEHIB) GOTO 14
        IF (SPATES .LT. 0) GOTO 52
          CALL SPAFRE
        IF (FITE .LT. ITEHIB) GOTO 14
52        CONTINUE
          CALL ASSERT (21,ITEHIB,0)
          RETURN
14    CONTINUE
        ITEM = FITE
        FITE = ITE(ITEM)
        ITESYM(ITEM) = SYMBOL
        ITEPOS(ITEM) = POSIT
C       ITEACT(ITEM) = ACTION
        ITESUC(ITEM) = SUCPRO
        ITE   (ITEM) = I2
        I2 = ITEM
        ITE(I1) = I2
      RETURN
      END
&END
&(ITEFRE  )
      SUBROUTINE ITEFRE (  I1,I2)
C     FREE (DELETE) A SINGLE ITEM
C     GF 20.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      INTEGER I1,I2 ! DELETE 'I2'. 'I1,I2' MAY BE IDENTICAL
C
      ITE(I1) = ITE(I2)
      ITE(I2) = FITE
      FITE = I2
      I2 = I1
      RETURN
      END
&END
&(ITEINS  )
      SUBROUTINE ITEINS(STATE,POSIT,SYMEX,ITEMEX)
C     INSERT AN ITEM IN A STATE
C     GF 11.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (MEMSETS)
      %INCLUDE (STAS)
      INTEGER D
     = ,DIFF1    !,COMPARE THE SYMBOLS
     = ,DIFF2    !,COMPARE THE ACTIONS
     = ,DIFF3    !,COMPARE THE POSITS
     = ,GOT     ! RESULT OF 'ITEMA2'
     = ,I1       ! -> ONE ELEMENT BEFORE THE ELEMENT INSPECTED
     = ,I2       ! THE CURRENT ITEM INSPECTED
     = ,ITEM     ! -> THE ITEM FINALLY INSERTED
     = ,ITEMA    ! -> THE ITEM WHERE A SYMBOL OCCURED FIRST
     = ,ITEMEX   ! .LE. 0 IF (THE ITEM DID NOT EXIST IN 'STATE'
     = ,POSIT ! INSERT AN ITEM WITH THE MARKER BEFORE THIS POSITION
     = ,STATE    ! INSERT THE ITEM IN THIS STATE
     = ,SYMA     ! THE MARKED SYMBOL OF THE ITEM 'ITEMA'
     = ,SYMBOL   ! THE MARKED SYMBOL
     = ,SYMEX    ! .LE. 0 IF (THE MARKED SYMBOL DID NOT EXIST IN 'STATE'
C
      ITEMEX = 0
      SYMBOL = MEM(POSIT)
      SYMEX = SYMBOL
      CALL ITEMA2 (STATE,  I1,I2,GOT)
      ITEMA = I2
      SYMA = ITESYM(ITEMA)!
5     IF(I1 .GE. ITEHIB) GOTO 6
        DIFF1 = SYMBOL - ITESYM(I2)
        IF (DIFF1 .GE. 0) GOTO 7 ! SYMBOL .GE.
C$ENB     CALL SEPUSH(STAMAR,STATE,LAPUTT,LAPUTB)
          GOTO 100
C       GOTO 8 ! SYMBOL .GE.
7       CONTINUE
        IF (DIFF1 .NE. 0) GOTO 9 ! SYMBOL =
          SYMEX = 0
          DIFF2 = SHIFT - ITEACT(I2)
          IF (DIFF2 .GE. 0) GOTO 10 ! SHIFT .GE. REDUCE
            CALL SEPUSH(STAMAR,STATE,SPLITT,SPLITB)
            GOTO 100
C         GOTO 13 ! SHIFT .GE. REDUCE
10        CONTINUE
          ! ACTION = (SHIFT), ACTION .LE. NOT POSSIBLE
            DIFF3 =  POSIT - ITEPOS(I2)
            IF (DIFF3 .GE. 0) GOTO 11 ! POSIT .GE.
              GOTO 100
C           CONTINUE ! POSIT .GE.
11          CONTINUE
            IF (DIFF3 .NE. 0) GOTO 12 ! POSIT =
              ITEMEX = I2
              GOTO 101
12          CONTINUE ! POSIT =
            ! ELSE POSIT > : TRY NEXT ELEMENT
13        CONTINUE ! ACTION =
          ! ELSE ACTION > : NOT POSSIBLE
9       CONTINUE ! SYMBOL =
8       CONTINUE
        ! ELSE SYMBOL > : TRY NEXT ELEMENT
        IF (ITESYM(I2) .EQ. SYMA) GOTO 14
          ITEMA = I2
          SYMA = ITESYM(ITEMA)!
14      CONTINUE
        I1 = I2
        I2 = ITE(I1)!
      GOTO 5
6     CONTINUE ! ALL ITEMS
      CALL ASSERT(22,STATE,POSIT) ! NO PLACE FOUND WHERE,INSERT
C
100   CONTINUE !      INSERT:
      CALL ITEALL (SYMBOL,POSIT,SHIFT,0,  I1,I2)
      IF (SYMBOL .LE. 1) GOTO 15
        CALL SEPUSH(STAMAR,STATE,STASUT,STASUB)
      GOTO 16
15    CONTINUE
        CALL SEPUSH(STAMAR,STATE,LAGETT,LAGETB)
16    CONTINUE ! SYMBOL .GT. 1
C
101   CONTINUE !      DONE:
      CALL ITEMA9 (STATE,GOT)
      RETURN! ITEINS
      END
&END
&(ITEMA1  )
      SUBROUTINE ITEMA1 (STATE,  I1,GOT)
C     READ AND LOCK AN ITEM-SET
C     GF 20.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (SLOS)
      INTEGER DIR(&DIRH)
      EQUIVALENCE (SLOT(1,1),DIR(1))
      %INCLUDE (DIRS)
      %INCLUDE (SPAS)
      %INCLUDE (STAS)
      INTEGER PARASK
      INTEGER I1,I2,I
     = ,GOT     ! = 1 (0) IF THE STATE WAS (NOT) REALLY READ
     = ,LNG     ! 'DIR' HAS 'LNG' SIGNIFICANT ELEMENTS
     = ,STATE   ! ACCESS TO THIS ITEM-SET
C
      IF(STAITE(STATE) .GT. 0) GOTO 71
C       < 0 : FETCH THE STATE
        GOT = 1
        IF (STAITE(STATE) .GE. - ITEHIB) GOTO 73
C         = - ITEHIB - 1 : WAS PAGED
          IF (SPATES .LT. 0) GOTO 51
          CALL SPASEA (STATE)
          IF (STAITE(STATE) .GT. 0) GOTO 74
51        CONTINUE
          FDIR = STATE
          CALL DIRREA (DIR,DIRHIB)
          LNG = DIR(1)
          I2 = ITEHIB
          IF (ITEPAG .GT. 1)
     =      CALL ASSERT (151,STATE,LNG)
          I = 4
80        IF(I .GT. LNG) GOTO 81
            IF (FITE .LT. ITEHIB-1) GOTO 82
              IF (SPATES .LT. 0) GOTO 52
              CALL SPAFRE
              IF (I2 .NE. ITEHIB) ITE(I2) = FITE ! 'SPAFRE' BROKE CHAIN
              IF (FITE .LT. ITEHIB) GOTO 82
52            CONTINUE
              CALL ASSERT (150,STATE,FITE)
            GOTO 81
82          CONTINUE
            I2 = FITE
            FITE = ITE(FITE)
            ITESYM(I2) = DIR(I-2)
            ITEPOS(I2) = DIR(I-1)
            ITESUC(I2) = DIR(I  )
            IF (I .EQ. 4) STAITE(STATE) = I2
            I = I + 3
          GOTO 80
81        CONTINUE
          IF (I .EQ. 4) GOTO 79
C           STATE WAS NOT EMPTY
            ITE(I2) = ITEHIB
          GOTO 78
79        CONTINUE
C           STATE WAS EMPTY
            STAITE(STATE) = ITEHIB
78        CONTINUE
        GOTO 74
73      CONTINUE
          IF (ITEPAG .LT. 0)
     =      CALL ASSERT (161,STATE,0)
          STAITE(STATE) = - STAITE(STATE)
74      CONTINUE
      GOTO 72
71    CONTINUE
C       > 0 : STATE WAS ALREADY FETCHED
        GOT = 0
72    CONTINUE
C
      I1 = STAITE(STATE)
      RETURN
      END
&END
&(ITEMA2  )
      SUBROUTINE ITEMA2 (STATE,  I1,I2,GOT)
C     READ FOR UPDATE AND LOCK AN ITEM-SET
C     GF 20.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (STAS)
      %INCLUDE (PRIS)
      INTEGER PARASK
      INTEGER I1,I2
     = ,GOT     ! = 1 (0) IF THE STATE WAS (NOT) REALLY READ
     = ,STATE   ! ACCESS TO THIS ITEM-SET
C
      IF (ITEPAG .GT. 1 .OR. ITEPAG .LT. 0)
     =  CALL ASSERT (152,STATE,STAITE(STATE))
      CALL ITEMA1 (STATE,  ITE(1),GOT)
      I1 = 1
      I2 = ITE(1)
      RETURN
      END
&END
&(ITEMA8  )
      SUBROUTINE ITEMA8 (STATE,GOT)
C     UNLOCK AN ITEM-SET
C     GF 20.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (SLOS)
      INTEGER DIR(&DIRH)
      EQUIVALENCE (SLOT(1,1),DIR(1))
      %INCLUDE (DIRS)
      %INCLUDE (SPAS)
      %INCLUDE (STAS)
      INTEGER PARASK
      INTEGER I1,I2,WAS149
     = ,GOT     ! = 1 (0) IF THE STATE WAS (NOT) REALLY READ
     = ,LNG     ! 'LNG' ELEMENTS OF 'DIR' ARE FILLED
     = ,STATE   ! ACCESS TO THIS ITEM-SET
C
      WAS149 = 0
      IF (GOT .EQ. 0) GOTO 72
C       UNLOCK THE STATE
        IF (ITEPAG .LE. 0) GOTO 73
          LNG = 4
          I2 = STAITE(STATE)
81        IF(I2 .EQ. ITEHIB) GOTO 82
            IF (LNG .LE. DIRHIB) GOTO 83
              IF (WAS149 .NE. 0) GOTO 84
              CALL ASSERT (149,I2,STATE)
              WAS149 = 1
83          CONTINUE
            DIR(LNG-2) = ITESYM(I2)
            DIR(LNG-1) = ITEPOS(I2)
            DIR(LNG  ) = ITESUC(I2)
            LNG = LNG + 3
84          CONTINUE
            I1 = I2
            I2 = ITE(I2)
            IF (SPATES .GE. 0) GOTO 51
            ITE(I1) = FITE
            FITE = I1
51          CONTINUE
          GOTO 81
82        CONTINUE
          DIR(1) = LNG - 3
          IF (ITEPAG .GT. 1)
     =      CALL ASSERT (158,STATE,DIR(1))
          IF (SPATES .LT. 0) GOTO 52
          CALL SPAALL (STATE,STAITE(STATE),I1)
52        CONTINUE
          STAITE(STATE) = - ITEHIB - 1
        GOTO 74
73      CONTINUE
          IF (ITEPAG .LT. 0)
     =      CALL ASSERT (168,STATE,0)
          STAITE(STATE) = - ABS(STAITE(STATE))
74      CONTINUE
72    CONTINUE
      RETURN
      END
&END
&(ITEMA9  )
      SUBROUTINE ITEMA9 (STATE,GOT)
C     WRITE AND UNLOCK AN ITEM-SET
C     GF 20.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (SLOS)
      INTEGER DIR(&DIRH)
      EQUIVALENCE (SLOT(1,1),DIR(1))
      %INCLUDE (DIRS)
      %INCLUDE (STAS)
      INTEGER PARASK
      INTEGER I1,I2
     = ,GOT     ! = 1 (0) IF THE STATE WAS (NOT) REALLY READ
     = ,STATE   ! ACCESS TO THIS ITEM-SET
C
      IF (STATE .NE. 0) GOTO 1
        WRITE (UPRI,2) -999
2       FORMAT (1X,I1)
        RETURN
1     CONTINUE
      STAITE(STATE) = ITE(1) ! ANCHOR MAY BE CHANGED
      IF (GOT .EQ. 0) RETURN
      CALL ITEMA8 (STATE,GOT)
      IF (ITEPAG .GT. 1 .OR. ITEPAG .LT. 0)
     =  CALL ASSERT (159,STATE,STAITE(STATE))
      IF (ITEPAG .LE. 0) GOTO 85
        FDIR = STATE
        CALL DIRWRI (DIR,DIRHIB)
85    CONTINUE
      RETURN
      END
&END
&(ITES    )
C-------GF 28.08.80------------------------------ I T E S
      INTEGER FITE,ITEHIB,ACCEPT,REDUCE,SHIFT,ERROR
      INTEGER ITE(&ITEH),ITESYM(&ITEH),ITEPOS(&ITEH)
      INTEGER ITEACT,ITESUC(&ITEH)
      INTEGER ITEPAG
      COMMON /ITES/
     =  FITE
     = ,ITEHIB
     = ,ACCEPT      ! PARSER ACTION, OCCURS ONLY ONCE IN STATE 3
     = ,REDUCE      !      <= 'SHIFT'
     = ,SHIFT      !      >= 'REDUCE'
     = ,ERROR      ! GENERATED BY 'DELTA'
     = ,ITE      ! -> NEXT ITEM IN A STATE
     = ,ITESYM      ! THE MARKED SYMBOL
     = ,ITEPOS      ! THE MARKER IS BEFORE THIS MEMBER
     = ,ITESUC  ! SHIFT: SUCCESSOR, REDUCE: PRODUCTION
     = ,ITEPAG  ! = 1 (0): DO (NOT) PAGE 'ITES'
&END
&(LACOPY  )
      SUBROUTINE LACOPY (STATEB, STATEZ, PRODZ)
C     ALL SYMBOLS (THE TERMINALS) OF 'STATEB' ARE USED AS LOOK-AHEAD
C       SYMBOLS FOR PRODUCTION 'PRODZ' IN 'STATEZ'
C     CALLED AS 'APPLY' FROM 'LAGET' AND 'LAPUT'
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (PROS)
      %INCLUDE (SETS)
      %INCLUDE (STAS)
      %INCLUDE (SYMS)
      INTEGER PARASK
      INTEGER I
     = ,B2       ! AN ITEM OF 'STATEB' = FROM THE SOURCE
     = ,DIFF1    !,COMPARE THE SYMBOLS
     = ,DIFF2    !,COMPARE THE ACTIONS
     = ,DIFF3    !,COMPARE THE POSITS
     = ,GOTZ
     = ,GOTB    ! RESULT OF 'ITEMA2'
     = ,I1       ! -> ONE ELEMENT BEFORE THE ELEMENT INSPECTED
     = ,I2       ! THE CURRENT ITEM INSPECTED
     = ,ITEM     ! -> THE ITEM FINALLY INSERTED
     = ,POSIT ! INSERT AN ITEM WITH THE MARKER BEFORE THIS POSITION
     = ,PRODZ    ! GET THE LOOK-AHEAD SYMBOLS FOR THIS PRODUCTION
     = ,STATEB   ! TAKE SYMBOLS FROM THIS STATE
     = ,STATEZ   ! INSERT REDUCTIONS IN THIS STATE
     = ,SYMBOL   ! A LOOK-AHEAD SYMBOL OF 'STATEB'
C
      CALL ITEMA2 (STATEZ,  I1,I2,GOTZ)
      POSIT = PROMON(PRODZ) + PROLNG(PRODZ) ! ON THE DUMMY SYMBOL
      SYMBOL = 1
      CALL ITEMA1 (STATEB,  B2,GOTB)
1     IF(ITESYM(B2) .NE. SYMBOL) GOTO 2 ! SKIP OVER DUMMY SYMBOLS
        B2 = ITE(B2)
      GOTO 1
2     CONTINUE ! SKIP DUMMY
3     IF(B2 .GE. ITEHIB) GOTO 4 ! ALL IN SOURCE
      SYMBOL = ITESYM(B2)
5     IF(I1 .GE. ITEHIB) GOTO 6
        DIFF1 = SYMBOL - ITESYM(I2)
        IF (DIFF1 .GE. 0) GOTO 7 ! SYMBOL .GE.
          CALL SEPUSH(STAMAR,STATEZ,LAPUTT,LAPUTB)
          GOTO 100
C       CONTINUE ! SYMBOL .GE.
7       CONTINUE
        IF (DIFF1 .NE. 0) GOTO 9 ! SYMBOL =
          DIFF2 = REDUCE - ITEACT(I2)
          ! 'DIFF2 .GE. 0' NOT POSSIBLE
          IF (DIFF2 .NE. 0) GOTO 10 ! ANOTHER REDUCTION THERE
            DIFF3 =  POSIT - ITEPOS(I2)
            IF (DIFF3 .GE. 0) GOTO 11 ! POSIT .GE.
              GOTO 100
C           CONTINUE ! POSIT .GE.
11          CONTINUE
            IF (DIFF3 .NE. 0) GOTO 12 ! POSIT =
              GOTO 101
12          CONTINUE ! POSIT =
            ! ELSE POSIT > : TRY NEXT ELEMENT
10        CONTINUE ! ACTION =
          ! ELSE ACTION > : NOT POSSIBLE
9       CONTINUE ! SYMBOL =
        ! ELSE SYMBOL > : TRY NEXT ELEMENT
        I1 = I2
        I2 = ITE(I1)!
      GOTO 5
6     CONTINUE ! ALL ITEMS IN TARGET
C
100   CONTINUE !      INSERT:
      IF (PARASK('TERMLA',1,6,0) .NE. 0 .AND.
     =    SYMPRO(SYMBOL) .NE. PROHIB)
     =GOTO 13
        IF (ITESYM(I1) .EQ. SYMBOL .OR. ITESYM(I2) .EQ. SYMBOL)
     =    CALL SEPUSH(STAMAR,STATEZ,SPLITT,SPLITB)
        CALL ITEALL (SYMBOL,POSIT,REDUCE,PRODZ,  I1,I2)
13    CONTINUE ! TERMLA
C
101   CONTINUE !      DONE:
      B2 = ITE(B2) ! SKIP ALL FOLLOWING ITEMS WITH 'SYMBOL'
16    IF(ITESYM(B2) .NE. SYMBOL) GOTO 17
        B2 = ITE(B2)
17    CONTINUE ! SKIP FOLLOWING
      GOTO 3
4     CONTINUE ! ALL IN SOURCE
      CALL ITEMA8 (STATEB,GOTB)
      CALL ITEMA9 (STATEZ,GOTZ)
      RETURN! LACOPY
      END
&END
&(LADEL   )
      SUBROUTINE LADEL(STATEB,STATEZ,PRODZ)
C     DELETE LOOK-AHEAD SYMBOLS OF 'PRODZ' IN 'STATEZ' AND PROPAGATE
C       THIS DELETION
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (PROS)
      %INCLUDE (SETS)
      %INCLUDE (STAS)
      INTEGER I
     = ,GOT     ! RESULT OF 'ITEMA1/2', =1 IF STATE WAS READ
     = ,I1       ! -> ITEM BEFORE ITEM 'I2'
     = ,I2       ! -> CURRENT ITEM
     = ,ITEMEX   ! FOR CALL OF 'ITEINS'
     = ,LESS     ! = 1 IF ('STATEZ' LOOSES SOME SYMBOLS
     = ,PRODZ    ! DELETE FROM THIS REDUCTION
     = ,POSIT ! BEHIND 'PRODZ'
     = ,STATEB   ! NOT USED
     = ,STATEZ   ! DELETE FROM THIS STATE
     = ,SYMEX    ! FOR CALL OF 'ITEINS'
C
      LESS = 0
      POSIT = PROMON(PRODZ) + PROLNG(PRODZ) ! BEHIND THE PRODUCTION
      CALL ITEMA2 (STATEZ,  I1,I2,GOT)
1     IF(I2 .GE. ITEHIB) GOTO 2
        IF (ITEPOS(I2) .NE. POSIT) GOTO 3
          LESS = I2
          CALL ITEFRE (  I1,I2)
3       CONTINUE ! DELETE-ITEM FOUND
        I1 = I2
        I2 = ITE(I1)!
      GOTO 1
2     CONTINUE ! ALL ITEMS
      CALL ITEMA9 (STATEZ,GOT)
      IF (LESS .LE. 0) GOTO 4
        CALL SEPUSH(STAMAR,STATEZ,LAGART,LAGARB)
4     CONTINUE ! 'STATEZ' LOST SOME LOOK-AHEAD SYMBOLS
      CALL ITEINS(STATEZ,POSIT,SYMEX,ITEMEX)
      RETURN! LADEL
      END
&END
&(LAGAR   )
      SUBROUTINE LAGAR
C     GARBAGE COLLECTION FOR LOOK-AHEAD SYMBOLS
C
      %INCLUDE (PARS)
      %INCLUDE (SETS)
      %INCLUDE (STAS)
      INTEGER I
     = ,ELEM     ! -> A STATE IN THE 'LAGAR'-SET
     = ,STATEB   ! CURRENT STATE OF THE 'LAGAR'-SET
      EXTERNAL LADEL
C
      ELEM = LAGARH
1     IF(ELEM .EQ. LAGART) GOTO 2
        STATEB = SETELE(ELEM)
        CALL RECEIV(STATEB,LADEL)
        ELEM = SET(ELEM)
      GOTO 1
2     CONTINUE ! ALL IN SET
      CALL SETFRE(STAMAR,LAGARH,LAGART,LAGARB)
      RETURN! LAGAR
      END
&END
&(LAGET   )
      SUBROUTINE LAGET
C     GET LOOK-AHEAD SYMBOLS FOR ALL PRODUCTIONS OF ALL STATES IN QUEU
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (MEMSETS)
      %INCLUDE (STAS)
      INTEGER I
     = ,ENBLOC   ! = 0 (1) FOR A INCREMENTAL (EN-BLOC) CONSTRUCTION
     = ,GOT     ! RESULT OF 'ITEMA1/2', =1 IF STATE WAS READ
     = ,I1       ! -> ITEM BEFORE ITEM 'I2'
     = ,I2       ! CURRENT ITEM IN 'STATEZ'
     = ,STATEZ   ! A STATE FROM THE QUEUE
      INTEGER PARASK
      EXTERNAL LACOPY
C
      ENBLOC = PARASK ('ENBLOC',1,6,0)
1     IF(LAGETH .EQ. LAGETT) GOTO 2 ! FOR ALL ELEMENTS OF THE QUEUE
        CALL SETPOP(STAMAR,STATEZ,LAGETH,LAGETB)
        CALL ITEMA2 (STATEZ,  I1,I2,GOT)
3       IF(ITESYM(I2) .NE. 1) GOTO 4 ! ALL REDUCTIONS TO BE PROCESSED
          IF (ENBLOC .NE. 1)
     =      CALL EMITT(STATEZ,MEMNUC(ITEPOS(I2)),LACOPY)
          CALL ITEFRE (  I1,I2) ! DELETE THE DUMMY SYMBOL
          I1 = I2
          I2 = ITE(I1)!
        GOTO 3
4       CONTINUE ! ALL DUMMY SYMBOLS
C
        CALL ITEMA9 (STATEZ,GOT)
      GOTO 1
2     CONTINUE ! ALL IN QUEUE
      RETURN! LAGET
      END
&END
&(LAPUT   )
      SUBROUTINE LAPUT
C     PROPAGATE THE SYMBOLS OF ALL STATES IN THE QUEUE
C
      %INCLUDE (PARS)
      %INCLUDE (SETS)
      %INCLUDE (STAS)
      INTEGER I
     = ,STATEB   ! A STATE OF THE QUEUE
      EXTERNAL LACOPY
C
      I = FSTA - 1
      DO 7 STATEB=2,I
        CALL SEPUSH (STAMAR,STATEB,LAPUTT,LAPUTB)
7     CONTINUE
5     IF(LAPUTH .EQ. LAPUTT) GOTO 6
        CALL SETPOP(STAMAR,STATEB,LAPUTH,LAPUTB)
        CALL RECEIV(STATEB,LACOPY)
      GOTO 5
6     CONTINUE ! ALL IN QUEUE
      RETURN! LAPUT
      END
&END
&(LIFRE   )
      SUBROUTINE LIFRE(A,FA,AHEAD,ATAIL)
C     PREFIX THE FREE LIST WITH A LIST
C
      INTEGER I
     = ,A(1)     ! THE ARRAY FOR THE POINTERS OF THE LIST
     = ,AHEAD    ! -> FIRST ELEMENT
     = ,AHIB     ! HBOUND(A,1)
     = ,ATAIL    ! -> LAST ELEMENT
     = ,FA       ! -> THE 1ST FREE ELEMENT
     = ,I1       ! -> THE ELEMENT BEFORE 'I2'
     = ,I2       ! -> CURRENT ELEMENT
C
      IF (AHEAD .EQ. ATAIL) GOTO 3
        A(1) = AHEAD
        I1 = 1
        I2 = A(I1)
11      IF(I2 .EQ. ATAIL) GOTO 2
            I1 = I2
            I2 = A(I1)
        GOTO 11
2       CONTINUE ! ALL ELEMENTS
        ! NOW PREFIX THE FREE LIST WITH 'A(AHEAD : I1)'
        A(I1) = FA
        FA = AHEAD
        AHEAD = ATAIL
3     CONTINUE ! AHEAD .EQ. ATAIL
      RETURN ! LIFRE
      END
&END
&(LILINK  )
      SUBROUTINE LILINK(AHIB,A,FA)
C     SET HIGH-BOUND, FREE-POINTER AND LINK ALL ELEMENTS
C
      INTEGER I
     = ,A(1)     ! THE ARRAY FOR THE POINTERS OF THE LIST
     = ,AHEAD    ! -> FIRST ELEMENT
     = ,AHIB     ! HBOUND(A,1)
     = ,ATAIL    ! -> LAST ELEMENT
     = ,FA       ! -> THE 1ST FREE ELEMENT
      A(AHIB) = AHIB
      FA = 2
      A(1) = 0
      DO 1 I = FA,AHIB
        A(I) = I + 1
1     CONTINUE
      A(AHIB) = AHIB
      RETURN ! LILINK
      END
&END
&(LINETE  )
      PROGRAM LINETE
C     TEST 'LINEXT'
C
      %INCLUDE (PARS)
      INTEGER I
C
      CALL LINIT
      WRITE(UPRI,2) ULIN
2     FORMAT(' ULIN=',I5)
      DO 1 I = 1,15
        CALL LINEXT
1     CONTINUE
      STOP
      END
&END
&(LINEXT  )
      SUBROUTINE LINEXT
C     GET NEXT LINE FROM SOURCE-PROGRAM
C
      %INCLUDE (PARS)
      %INCLUDE (LINS)
      %INCLUDE (PROS)
      INTEGER ZZCR
      INTEGER I
     = ,MARRD2  ! RIGHT MARGIN IN WORDS
     = ,BL6(3)  ! 6 BLANKS
      DATA BL6 /2H  ,2H  ,2H  /
C
10    CONTINUE ! LIREAD:
      READ (ULIN,1,END=2) LINE
1     FORMAT(&LINH A2)
C     DETERMINE THE LAST WORD NOT CONTAINING BLANKS
      MARRD2 = &LINH + 1
4     CONTINUE
        MARRD2 = MARRD2 - 1
      IF(LINE(MARRD2) .EQ. BL6(1)) GOTO 4
      IF(MARRD2 .LE. 0) MARRD2 = 1
      LIMARR = MARRD2*2
      LINENO = LINENO + 1
      WRITE(UPRI,3) LINENO,FPRO,(LINE(I),I=1,MARRD2)
3     FORMAT(1X,2I5,2X,&LINH A2)
      FLIN = LIMARL
      GOTO (101,102,103), LILANG
C--------------------------------------------------------
102   CONTINUE ! FORTRAN
C
      IF (ZZCR(LINE,1,1,'C',1,1) .EQ. 0 .OR.
     =    ZZCR(LINE,1,1,'*',1,1) .EQ. 0
     =) GOTO 10 ! LIREAD
      IF (ZZCR(LINE,6,6,'0',1,1) .EQ. 0)
     =  CALL ZZCC (BL6,1,1,LINE,6,6)
      IF (ZZCR(LINE,6,6,BL6,1,1) .NE. 0) GOTO 1021
C       NEW STATEMENT BEGINS
        LINOCO = 0
        FLIN = LIMARR + 2 ! BEHIND 'LIEOLC'
        CALL ZZIC (LIEOFC,LINE,FLIN)
      GOTO 1022
1021  CONTINUE
C       CONTINUATION LINE
        IF (ZZCR(LINE,1,5,BL6,1,5) .EQ. 0) GOTO 1023
          CALL ASSERT (145,0,0)
C           COLUMNS 1-5 OF CONTINUATION LINE NOT ALL BLANKS
1023    CONTINUE
        LINOCO = LINOCO + 1
        IF (LINOCO .LE. 19) GOTO 1024
          CALL ASSERT (146,19,0)
C           MORE THAN @ CONTINUATION LINES
1024    CONTINUE
        FLIN = 7
1022  CONTINUE
      GOTO 99
C-------------------------------------------------------
101   CONTINUE ! PL/1-LIKE
103   CONTINUE ! COBOL
C
      FLIN = LIMARL
      GOTO 99
C-------------------------------------------------------
99    CONTINUE
      CALL ZZIC (LIEOLC,LINE,LIMARR + 1) ! SET STOPPING CHAR.
      RETURN
C
C     PROCESS END OF FILE
2     CONTINUE
      FLIN = 1
      CALL ZZIC (LIEOFC,LINE,FLIN)
      LINENO = LINENO + 1
      RETURN ! AFTER EOF
      END
&END
&(LINIT   )
      SUBROUTINE LINIT
C     INITIALIZE READING OF SOURCE-TEXT
C
      %INCLUDE (PARS)
      %INCLUDE (LINS)
      INTEGER I
C
      LIMARL =  1
      LIMARR = (&LINH - 1) * 2
      LIEOFC = 127
      CALL ZZCI ('!',1,LIEOLC)
      CALL ZZIC (LIEOFC,LINE,1)
      CALL CODASS (LINE,1,1,I) ! THROW 'I'
      CALL ZZIC (LIEOLC,LINE,1)
      CALL CODASS (LINE,1,1,I)
      LINENO = 0 ! 1ST NOT YET READ IN
      LILANG = 1 ! PL/1
      CALL LINEXT
      RETURN
      END
&END
&(LINS    )
C-------GF 01.08.80------------------------------- L I N S
      INTEGER FLIN,LINENO,LINE(&LINH)
      INTEGER LIMARL,LIMARR,LIEOFC,LIEOLC
      INTEGER LINOCO,LILANG
      COMMON /LINS/
     =  FLIN    ! 1ST COLUMN NOT YET PROCESSED BY 'SCAN'
     = ,LINENO  ! SEQUENTIAL NUMBER OF THE LINE
     = ,LINE    ! BUFFER FOR THE LINE + 1 STOP-CHARACTER
     = ,LIMARL  ! LEFT MARGIN OF SOURCE-LINE
     = ,LIMARR  ! RIGTH ...
     = ,LIEOFC  ! A CHARACTER WHICH INDICATES THE END OF FILE
     = ,LIEOLC  ! ... END OF LINE
     = ,LINOCO  ! NUMBER OF CONTINUATION LINES
     = ,LILANG  ! = 1,2,3: LANGUAGE IS PL/1, FORTRAN, COBOL
C     LIEOFC .AND. (FLIN=1 => EOFILE, FLIN=LINHIB => EOSTMT)
&END
&(LITRAC  )
      SUBROUTINE LITRAC(A,AHEAD,ATAIL,APPLY,NEGATE)
C     DO SOMETHING WITH ALL ELEMENTS OF A LIST  AND MARK THEM EVENTUAL
C
      INTEGER J
     = ,A(1)     ! THE ARRAY FOR THE POINTERS OF THE LIST
     = ,AHEAD    ! -> FIRST ELEMENT
     = ,AHIB     ! HBOUND(A,1)
     = ,ATAIL    ! -> LAST ELEMENT
     = ,FA       ! -> THE 1ST FREE ELEMENT
     = ,ELEM     ! ->,CURRENT ELEMENT
     = ,NEGATE   ! = -1 : MARK THE ELEMENTS, = +1 : DO NOT MARK
     = ,REF      ! = 'A(ELEM)'
      EXTERNAL APPLY
C
      ELEM = AHEAD
      I = 128
12    IF(ELEM .EQ. ATAIL) GOTO 4
        I = I - 1
        IF (I .GT. 0) GOTO 6
          CALL ASSERT(33,AHEAD,ATAIL)
          GOTO 5
6       CONTINUE ! LOOP-CHECK
        CALL APPLY(ELEM)
        REF = A(ELEM)
        IF (REF .GE. 0) GOTO 7 ! ALREADY MARKED - MUST BE A WRONG LIST
          CALL ASSERT(25,ELEM,ATAIL)
          GOTO 5
7       CONTINUE ! WRONG LIST
        A(ELEM) = REF * NEGATE ! * (+/- 1)
        ELEM = REF
      GOTO 12
4     CONTINUE ! ALL ELEMENTS
      A(ATAIL) = A(ATAIL) * NEGATE
5     CONTINUE
      RETURN ! LITRAC
      END
&END
&(LRDUMP  )
      SUBROUTINE LRDUMP
C     PRINT THE PARSING TABLE READABLY
C     GF 11.07.80 INCLUDES FIRST
C     GF 12.07.80 : PRINT 'BUCS' AND 'CODS'
C
      %INCLUDE(PARS)
      %INCLUDE (BUCS)
      %INCLUDE (CODS)
      %INCLUDE(STAS)
      %INCLUDE (SYMS)
      INTEGER PARASK
      INTEGER I,J
     = ,MSTA     ! NUMBER OF THE LAST STATE,BE DUMPED
C
      CALL SETSIN
      MSTA = FNUM - 1
      IF (MSTA .LT. STAHIB) MSTA = STAHIB - 1
      ! MSTA = MIN(FNUM-1,STAHIB-1)
      DO 1 I = PARASK('OUTSTA',1,6,0),MSTA
        CALL OUTSTA(I)
1     CONTINUE ! ALL STATES
6     CONTINUE
      CALL OUTSYM(0)
      IF (PARASK('BUCS',1,4,0) .EQ. 0) GOTO 2
        DO 3 I=1,BUCHIB
          CALL ZZWI (I,3)
          CALL ZZWC ('. BUC: ',1,7,0)
          CALL OUTBUC(BUCKET(I))
          CALL ZZWS (0)
3       CONTINUE
        CALL OUTBUC (SPEH)
        CALL ZZWS (0)
2     CONTINUE
      IF (PARASK('CODS',1,4,0) .EQ. 0) GOTO 4
        WRITE(UPRI,5) (CODTAB(I),I-1,I=33,CODHIB)
5         FORMAT(8(4X,I2,A2))
4     CONTINUE
      RETURN! LRDUMP
      END
&END
&(LRINIT  )
      SUBROUTINE LRINIT
C     INITIALIZE PARSER-GENERATOR
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (PRES)
      %INCLUDE (PROS)
      %INCLUDE (STAS)
      %INCLUDE (SYMS)
      INTEGER I
     = ,GOT   ! = 1 (0) IF THE STATE WAS (NOT) READ IN
     = ,I1,I2 ! RESULT OF 'ITEMA2'
     = ,MON1     ! MEMBER NUMBER ONE OF THE HYPER-RULE
     = ,PROD     ! PRODUCTION RETURNED BY 'PROCHA'
     = ,STATE3   ! DELTA(2,HYPER-AXIOM) = (->,3)
C
      CALL LILINK(ITEHIB,ITE   ,FITE)
      CALL LILINK(PREHIB,PRE   ,FPRE)
      CALL LILINK(PROHIB,PRO   ,FPRO)
      CALL LILINK(STAHIB,STAPRE,FSTA)
      FNUM = FSTA ! INCREMENTED IN 'STAALL'
      DO 2 I = 1,SYMHIB
        SYMPRO(I) = PROHIB
        SYMRST(I) = STAHIB
        SYMMAR(I) = 0
2     CONTINUE ! INITIALIZE 'SYM'
      STARST(STAHIB) = STAHIB
C
      PRESTA(PREHIB) = STAHIB ! FOR 'PREINS'
C
      RETURN ! LRINIT
C--------------------------------------------------------
      ENTRY LRAXIO
C     INITIALIZE THE PARSER WITH THE RULE FOR THE HYPER-AXIOM
C
      MEM(FMEM - 1) = EOP ! A DUMMY SYMBOL BEFORE THE 1ST PRODUCTION
      MON1 = FMEM
      MEM(FMEM) = EOFILE
      CALL STAALL(STATE2,MEM(FMEM))
      FMEM = FMEM + 1
      AXIOM = FSYM
      MEM(FMEM) = AXIOM
      CALL STAALL(STATE3,MEM(FMEM))
      FMEM = FMEM + 1
      MEM(FMEM) = EOFILE
      FMEM = FMEM + 1
C     PROD1 = (HYPER_AXIOM = EOFILE AXIOM EOFILE)
C
      I= 1
      CALL PROCHA (1 ! ADDSUB = ADD
     = ,I            ! HYPER-AXIOM
     = ,MON1
     = ,3            ! LNG
     = ,PROD)
      CALL PREINS(STATE2,STATE3)
      CALL ITEMA2 (STATE2,  I1,I2,GOT)
      CALL ITEALL (AXIOM,MON1+1,SHIFT,STATE3,  I1,I2)
      CALL ITEMA9 (STATE2,1) ! 'GOT' BY 'STAALL'
C
      CALL ITEMA2 (STATE3,  I1,I2,GOT)
      CALL ITEALL (EOFILE,MON1+2,ACCEPT,1,     I1,I2)
      CALL ITEMA9 (STATE3,1) ! 'GOT' BY 'STAALL'
C     TABLE0 = (1 EOFILE ?? 2 AXIOM -> 3 EOFILE =.)
C
      RETURN ! LRAXIO
      END
&END
&(LROPEN  )
      SUBROUTINE LROPEN
C     OPEN THE PARSING TABLE
C     GF 24.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (PRES)
      %INCLUDE (PROS)
      %INCLUDE (MEMSETS)
      %INCLUDE (STAS)
      %INCLUDE (SYMS)
      INTEGER I
     = ,GOT   ! = 1 (0) IF THE STATE WAS (NOT) READ IN
     = ,HYPER   ! THE HYPER_AXIOM (VIRTUAL SYMBOL)
     = ,I1,I2 ! RESULT OF 'ITEMA2'
     = ,LEFT    ! A NONTERMINAL SYMBOL
     = ,MON1     ! MEMBER NUMBER ONE OF THE HYPER-RULE
     = ,PROD     ! PRODUCTION RETURNED BY 'PROCHA'
     = ,STATE3   ! DELTA(2,HYPER-AXIOM) = (->,3)
C
      CALL DIRECT (2) ! WRITE 'SYMLNK,-POS,SEMS,STRS'
C
      CALL LILINK(ITEHIB,ITE   ,FITE)
C
      CALL LILINK(STAHIB,STAPRE,FSTA)
      STARST(STAHIB) = STAHIB
      FNUM = FSTA ! INCREMENTED IN 'STAALL'
      DO 1 I = FSTA,STAHIB
        STAITE(I) = 0
1     CONTINUE
C
      DO 2 I = 1,SYMHIB
        SYMRST(I) = STAHIB
        SYMMAR(I) = 0
2     CONTINUE ! INITIALIZE 'SYM'
C
      CALL LILINK(PREHIB,PRE   ,FPRE)
      PRESTA(PREHIB) = STAHIB ! FOR 'PREINS'
C
C
      MON1 = FMEM
      MEM(FMEM) = EOFILE
      CALL STAALL(STATE2,MEM(FMEM))
      FMEM = FMEM + 1
      MEM(FMEM) = AXIOM
      CALL STAALL(STATE3,MEM(FMEM))
      FMEM = FMEM + 1
      MEM(FMEM) = EOFILE
      FMEM = FMEM + 1
      MEM(FMEM) = EOP
      FMEM = FMEM + 1
C
C     PROD1 = (HYPER_AXIOM = EOFILE AXIOM EOFILE)
      PROD = FPRO
      FPRO = FPRO + 1
      PROMON(PROD) = MON1
      HYPER = 1 ! VIRTUAL SYMBOL
      PROLEF(PROD) = HYPER
      PRO(PROD) = PROHIB
C
      CALL SETINI
C
      CALL PREINS(STATE2,STATE3)
      CALL ITEMA2 (STATE2,  I1,I2,GOT)
      CALL ITEALL (AXIOM,MON1+1,SHIFT,STATE3,  I1,I2)
      CALL ITEMA9 (STATE2,1) ! 'GOT' BY 'STAALL'
C
      CALL ITEMA2 (STATE3,  I1,I2,GOT)
      CALL ITEALL (EOFILE,MON1+2,ACCEPT,1,     I1,I2)
      CALL ITEMA9 (STATE3,1) ! 'GOT' BY 'STAALL'
C     TABLE0 = (1 EOFILE ?? 2 AXIOM -> 3 EOFILE =.)
C
      CALL SEPUSH (STAMAR,STATE2,STASUT,STASUB)
      CALL SEPUSH (STAMAR,STATE3,LAPUTT,LAPUTB)
C
      CALL SEPUSH (SYMMAR,HYPER,SYMINT,SYMINB) ! FOR 'PUTCON'
      I = FSYM - 1
      DO 3 LEFT = AXIOM,I
        IF (SYMPRO(LEFT) .EQ. PROHIB) GOTO 4
C         THIS IS A NONTERMINAL
          CALL SEPUSH (SYMMAR,LEFT,SYMINT,SYMINB)
4       CONTINUE
3     CONTINUE
      RETURN
C----------------------------------------------------------------
      ENTRY LRCLOS
C     CLOSE THE PARSING TABLE
C     GF 24.08.80
C
      RETURN
      END
&END
&(MEMS    )
C-------GF 28.08.80-------------------------------- M E M S
      INTEGER FMEM,MEMHIB
      INTEGER EOP
      INTEGER MEM(&MEMH),MEMNUC(&MEMH)
      COMMON /MEMS/
     =  FMEM      ! 1ST FREE MEMBER
     = ,MEMHIB
     = ,EOP      ! SYMBOL AT THE END OF A PRODUCTION
     = ,MEM      ! SYMBOL-NUMBER, =1: END OF PRODUCTION
      COMMON /MEMSET/
     =  MEMNUC      ! ANCHOR FOR 'NUC'-LISTS
&END
&(MEMSETS )
C-------GF 28.08.80------------------------ M E M S E T S
      INTEGER FSET,SETHIB
      INTEGER SET   (&SETH),SETELE(&SETH)
     = ,EMITSH,EMITST,EMITSB   ! STA: FOR EMITT, SOURCE
     = ,EMITTH,EMITTT,EMITTB   ! STA: FOR EMITT, TARGET
     = ,LAGARH,LAGART,LAGARB   ! STA: FOR LAGAR
     = ,LAGETH,LAGETT,LAGETB   ! STA: FOR LAGET
     = ,LAPUTH,LAPUTT,LAPUTB   ! STA: FOR LAPUT
     = ,SPLITH,SPLITT,SPLITB   ! STA: FOR SPLIT
     = ,STACLH,STACLT,STACLB   ! SYM: FOR STACLO
     = ,STAGAH,STAGAT,STAGAB   ! STA: FOR STAGAR, ILL STATES
     = ,STAGBH,STAGBT,STAGBB   ! STA: FOR STAGAR, SURVIVING STATES
     = ,STASUH,STASUT,STASUB   ! STA: FOR STASUC
     = ,SYMINH,SYMINT,SYMINB   ! SYM: FOR SYMINS
      COMMON /SETS/
     =  FSET
     = ,SETHIB
     = ,EMITSH,EMITST,EMITSB   ! STA: FOR EMITT, SOURCE
     = ,EMITTH,EMITTT,EMITTB   ! STA: FOR EMITT, TARGET
     = ,LAGARH,LAGART,LAGARB   ! STA: FOR LAGAR
     = ,LAGETH,LAGETT,LAGETB   ! STA: FOR LAGET
     = ,LAPUTH,LAPUTT,LAPUTB   ! STA: FOR LAPUT
     = ,SPLITH,SPLITT,SPLITB   ! STA: FOR SPLIT
     = ,STACLH,STACLT,STACLB   ! SYM: FOR STACLO
     = ,STAGAH,STAGAT,STAGAB   ! STA: FOR STAGAR, ILL STATES
     = ,STAGBH,STAGBT,STAGBB   ! STA: FOR STAGAR, SURVIVING STATES
     = ,STASUH,STASUT,STASUB   ! STA: FOR STASUC
     = ,SYMINH,SYMINT,SYMINB   ! SYM: FOR SYMINS
      COMMON /SETTRA/ SETELE
      EQUIVALENCE (SET(1),MEMNUC(1))
&END
&(NUMSYM  )
      SUBROUTINE NUMSYM (INT2,  IBUF,LNG)
C     CONVERT A NUMBER TO A CHARACTER-STRING
C     GF 23.08.80
C
      INTEGER INT2  ! THE NUMBER TO BE CONVERTED (-32768...32767)
     = ,DIGIT       ! CURRENT DIGIT EXTRACTED
     = ,DIV         ! A POWER OF 10
     = ,IBUF(4)     ! STORE THE STRING HERE
     = ,LNG         ! RESULTING LENGTH OF THE STRING
     = ,NUM         ! A COPY OF 'INT2'
     = ,ZERO        ! ASCII-CODE OF '0'
C
      NUM = INT2
      CALL ZZCI ('0',1,ZERO)
      LNG = 1
C
      IF (NUM .GE. 0) GOTO 10
        NUM = - NUM
        CALL ZZCC ('-',1,1,  IBUF,LNG,LNG)
        LNG = LNG + 1
10    CONTINUE
      DIV = 10000
11    IF (DIV .LE. NUM) GOTO 12
        DIV = DIV / 10
        GOTO 11
12    CONTINUE
C
13    CONTINUE
        DIGIT = NUM / DIV
        CALL ZZIC (DIGIT+ZERO,  IBUF,LNG)
        LNG = LNG + 1
      IF (DIV .EQ. 1) GOTO 14
        NUM = NUM - DIGIT * DIV
        DIV = DIV / 10
        GOTO 13
14    CONTINUE
      LNG = LNG - 1
      RETURN
      END
&END
&(OUTMAP  )
      SUBROUTINE OUTMAP (PROD,POS)
C     PRINT A MARKED PRODUCTION
C     GF 11.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (MEMS)
      %INCLUDE (PRES)
      %INCLUDE (PROS)
      %INCLUDE (SYMS)
      INTEGER I,J
     = ,LOOPCH      ! TO CHECK AGAINST INFINITE LOOPS
     = ,POS      ! THE MARKER IS BEFORE IS POSITION
     =            ! OR NOT PRESENT IF 'POS = 0'
     = ,PROD      ! PRINT THIS PRODUCTION
     = ,SYMBOL
C
      CALL PUTSYM(PROLEF(PROD))
      CALL ZZWC (' = ',1,3,0)
      J = PROMON(PROD)
20      IF(J .GT. PROMON(PROD) + PROLNG(PROD) - 1) GOTO 21
        IF (J .NE. POS) GOTO 22
          CALL ZZWC (' @ ',1,3,0)
22        CONTINUE
        CALL PUTSYM (MEM(J))
        J = J + 1
      GOTO 20
21      CONTINUE
      RETURN ! OUTMAP
C---------------------------------------------------------------
      ENTRY OUTBUC (I)
C     PRINT A BUCKET OF THE HASH-TABLE OR THE LIST OF SPECIALS
C     GF 11.07.80
C
      SYMBOL = I
11      IF(SYMBOL .GE. SYMHIB - 1) GOTO 10
        CALL PUTSYM (SYMBOL)
        CALL ZZWX (2)
        SYMBOL = SYMLNK(SYMBOL)
      GOTO 11
10      CONTINUE
      RETURN ! OUTBUC
C----------------------------------------------------------------
      ENTRY OUTMEM (I)
C     PRINT A MEMBER OF A PRODUCTION
C     GF 11.07.80
C
      LOOPCH = 20
      CALL ZZWC ('                    MEMB: ',1,26,0)
      CALL ZZWI (I,4)
      CALL PUTSYM (MEM(I))
100      CONTINUE
      CALL ZZWS (0)
      RETURN ! OUTMEM
C---------------------------------------------------------
      ENTRY OUTNUM (I)
C     PRINT THE PARAMETER
C     GF 11.07.80
C
      CALL ZZWI(I,0)
      CALL ZZWX(1)
      RETURN ! OUTNUM
C----------------------------------------------------------
      ENTRY OUTPRE (I)
C     PRINT AN ELEMENT OF A LIST OF PREDECESSORS
C     GF 11.07.80
C
      CALL ZZWI (PRESTA(I),0)
      CALL ZZWX(1)
      RETURN ! OUTPRE
      END
&END
&(OUTPRO  )
      SUBROUTINE OUTPRO (PROD)
C     PRINT A PRODUCTION OF THE GRAMMAR
C     GF 11.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (PROS)
      INTEGER PARASK
      INTEGER I
     = ,PROD      ! THE PRODUCTION TO BE PRINTED
     = ,ITEM      ! THE ITEM TO BE PRINTED
C
C     HEADER
      CALL ZZWC ('      PROD ',1,11,0)
      CALL ZZWI (PROD,4)
      CALL ZZWC (', SEM: ',1,7,0)
      CALL ZZWI (PROSEM(PROD),5)
      CALL OUTMAP (PROD,0) ! PRINT THE MARKED PRODUCTION
      CALL ZZWS (0)
      CALL ZZWC (' => ',1,4,0)
C
C     SEMANTIC ACTIONS
      I = PROSEM(PROD)
40    CONTINUE
        CALL OUTSEM(I)
      IF (I .NE. 0) GOTO 40
      CALL ZZWS (0)
C
C     MEMBERS AND 'MEMNUC'-LISTS
      IF (PARASK ('OUTMEM',1,6,0) .EQ. 0) RETURN
      I = PROMON(PROD)
44    IF(I .GT. PROMON(PROD) + PROLNG(PROD) - 1) GOTO 45
        CALL OUTMEM(I)
        I = I + 1
      GOTO 44
45    CONTINUE
      RETURN ! OUTPRO
C------------------------------------------------------------------
      ENTRY OUTITE (ITEM)
C     PRINT AN ITEM OF THE PARSING TABLE
C     GF 11.07.80
C
      CALL ZZWI (ITEM,5)
      CALL ZZWC (': ',1,2,0)
      CALL PUTSYM (ITESYM(ITEM))
      CALL ZZWT (30)
      CALL ZZWC ('.',1,1,0)
      CALL ZZWI (ITEPOS(ITEM),5)
      CALL PUTACT (ITEM)
      CALL ZZWS (0)
      RETURN ! OUTITE
      END
&END
&(OUTSEM  )
      SUBROUTINE OUTSEM (I)
C     PRINT A SINGLE SEMANTIC ACTION FOR A PRODUCTION
C     GF 11.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (SEMS)
      INTEGER I
     = ,CODE
     = ,SEMNO(40) ! MNEMONICS FOR THE SEMANTIC ACTIONS
      DATA SEMNO
     = /'AC','CO',  'AC','IN',  'AC','MA',  'AC','TA'
     = ,'AT','CO',  'AT','IN',  'AT','MA',  'SY','AT'
     = ,'SO','CO',  'RE','IN',  'UN','CH',  'SO','TA'
     = ,'SY','CO',  'SY','IN',  'SY','MA',  'SE','PR'
     = ,'AC','CU',  'AT','TR',  'EO','SY',  'EO','S '
     = /
      CODE = SEM(I)
      CALL ZZWC (SEMNO,CODE*4-3,CODE*4,0)
      CALL ZZWC('(',1,1,0)
      CALL PUTSYM (SEMSYM(I))
      CALL ZZWC (')',1,1,3)
      IF (CODE .EQ. EOS) I = - 1 ! RETURN 'I=0'
      I = I + 1
      RETURN ! OUTSEM
      END
&END
&(OUTSET  )
      SUBROUTINE OUTSET(ELEM)
C     OUTPUT A SINGLE ELEMENT OF A SET (PARAMETER TO 'LITRAC')
C
      %INCLUDE (PARS)
      %INCLUDE (SETS)
      INTEGER ELEM
C
      CALL ZZWI(SETELE(ELEM),6)
      RETURN
      END
&END
&(OUTSTA  )
        SUBROUTINE OUTSTA (STATE)
C       PRINT A STATE OF THE PARSING TABLE
C       GF 11.10.80
C
        %INCLUDE (PARS)
        %INCLUDE (ITES)
        %INCLUDE (PRES)
        %INCLUDE (PROS)
        %INCLUDE (STAS)
        %INCLUDE (SYMS)
        INTEGER PARASK
        INTEGER I
     = ,GOT     ! RESULT OF 'ITEMA1/2', =1 IF STATE WAS READ
     = ,STATE   ! THE STATE TO BE PRINTED
     = ,SYM     ! 'STATE' IS REACHED BY 'SYM'
     = ,SYMB    ! FOR 'OUTSYM', SYMBOL TO BE PRINTED
     = ,SYMH    ! HIGH BOUND FOR LOOP ON SYMBOLS
     = ,SYML    ! LOW  BOUND ...
        EXTERNAL OUTITE,OUTPRE
        EXTERNAL OUTPRO,OUTNUM
C
        IF (STAITE(STATE) .EQ. 0) GOTO 1 ! 'STATE' IS NOT IN FREE LIST
          SYM = STASYM(STATE)
          WRITE(UPRI,2) STATE,STAMAR(STATE),STARST(STATE)
2           FORMAT(' **** STATE ',I4,', MAR: ',I5
     =        ,', RST: ',I4)
          CALL ZZWC ('                    SYM : ',1,25,0)
          CALL PUTSYM (SYM)
          IF (PARASK('PACKED',1,6,1) .NE. 0) GOTO 3
          CALL ZZWC (', PRE: ',1,7,0)
          CALL LITRAC (PRE,STAPRE(STATE),PREHIB,OUTPRE,1)
3         CONTINUE
          CALL ZZWS (0)
          CALL ITEMA1 (STATE,  I,GOT)
          CALL LITRAC (ITE,I,ITEHIB,OUTITE,1)
          CALL ITEMA8 (STATE,GOT)
1       CONTINUE
        RETURN ! OUTSTA
      END
&END
&(OUTSYM  )
      SUBROUTINE OUTSYM (SYMB)
C       PRINT A SYMBOL OF THE GRAMMAR OR OF 'SOURCE_TEXT'
C       GF 11.07.80
C
        %INCLUDE (PARS)
        %INCLUDE (PROS)
        %INCLUDE (STAS)
        %INCLUDE (SYMS)
        INTEGER PARASK
        INTEGER I
     = ,GOT     ! RESULT OF 'ITEMA1/2', =1 IF STATE WAS READ
     = ,STATE   ! THE STATE TO BE PRINTED
     = ,SYM     ! 'STATE' IS REACHED BY 'SYM'
     = ,SYMB    ! FOR 'OUTSYM', SYMBOL TO BE PRINTED
     = ,SYMH    ! HIGH BOUND FOR LOOP ON SYMBOLS
     = ,SYML    ! LOW  BOUND ...
        EXTERNAL OUTPRO,OUTNUM
        IF (SYMB .NE. 0) GOTO 30
          SYML = PARASK('OUTSYM',1,6,2)
          SYMH = FSYM -1
        GOTO 31
30      CONTINUE
          SYML = SYMB
          SYMH = SYMB
31      CONTINUE
C
        DO 32 I = SYML,SYMH
          CALL ZZWC(' ---- SYMBOL ',1,13,0)
          CALL PUTSYM (I)
          IF (PARASK('PACKED',1,6,1,) .NE. 0) GOTO 35
          CALL ZZWC (', MAR: ',1,7,0)
          CALL ZZWI (SYMMAR(I),5)
          CALL ZZWC (', RST: ',1,7,0)
          CALL LITRAC (STARST,SYMRST(I),STAHIB,OUTNUM,1)
35        CONTINUE
          CALL ZZWS (0)
          CALL LITRAC (PRO   ,SYMPRO(I),PROHIB,OUTPRO,1)
32      CONTINUE
        RETURN ! OUTSYM
        END
&END
&(PARADD  )
      SUBROUTINE PARADD
C     READ THE SYSTEM-PARAMETERES FROM A FILE
C     SEE ALSO: 'PAROLD'
C     GF 12.07.80
C     GF 14.03.81: NEW VERSION FOR '0 0' (EOD) IN THE 1ST LINE
C
      %INCLUDE (PARS)
      INTEGER PARASK
      INTEGER I,J
      INTEGER P7
      INTEGER FILNAM(16)
      DATA P7 /1/
      DATA FILNAM/'SY',': ','PA','RM','S.','DA','T '
     = ,0,0,0, 0,0,0,0,0,0 / ! 8-16 = ,0
C
      IF (PARASK('PARADD',1,6,0) .EQ. 0) GOTO 15
10    CONTINUE
      WRITE (UPRI,11)
11    FORMAT('$Parameters from (<file-spec> | <RETURN>): ')
      FILNAM(16) = FILNAM(P7)
      READ (UPRI,12) J,(FILNAM(I),I=P7,P7+J/2)
12    FORMAT(Q,16A2)
      IF (FILNAM(P7) .NE. '  ') GOTO 13
        FILNAM(P7) = FILNAM(16)
      GOTO 14
13    CONTINUE
        CALL ZZIC(0,FILNAM,J+1+P7+P7)
14    CONTINUE
15    CONTINUE
      I = 1 ! ASSUME 'PARLAS=0'
      OPEN (UNIT=UPAR,NAME=FILNAM,TYPE='OLD'
     = ,ERR=2)
1     CONTINUE
      IF (I .LE. PARHIB) GOTO 4
        CALL ASSERT (9,PARHIB,0)
C         MORE THAN @ PARAMETERS
        GOTO 2
4     CONTINUE
        READ(UPAR,3,ERR=2,END=2)
     =    PARVAL(I),PARME(I),(PARM(J,I),J=1,3)
3         FORMAT(I5,I2,1X,10A2)
      IF (PARME(I) .EQ. 0) GOTO 2
        I = I + 1
        GOTO 1
2     CONTINUE
      PARLAS = I - 1
      CLOSE (UNIT=UPAR)
      RETURN
      END
&END
&(PARASK  )
      INTEGER FUNCTION PARASK (CHARN,CHARS,CHARE,DEFLT)
C     RETURN THE VALUE OF A SYSTEM-PARAMETER
C
      %INCLUDE (PARS)
      INTEGER ZZCR
      INTEGER I
     = ,CHARS,CHARE,CHARN(1) ! THE NAME OF THE PARAMETER
     = ,DEFLT ! THE DEFAULT-VALUE IF THE PARAMETER IS NOT WRITTEN
C
      IF (PARLAS .EQ. 0) GOTO 6
      DO 4 I = 1,PARLAS
        IF (ZZCR(CHARN,CHARS,CHARE
     =          ,PARM(1,I),1,PARME(I)) .NE.0)
     =  GOTO 4
C         PARAMETER WAS WRITTEN
          PARASK = PARVAL(I)
          GOTO 5
4     CONTINUE
C     PARAMETER WAS NOT WRITTEN:
6     CONTINUE
      PARASK = DEFLT
5     RETURN
      END
&END
&(PARATE  )
      PROGRAM PARATE
      CALL PARADD
10    CONTINUE
      CALL PARADD
      GOTO 10
      END
&END
&(PAROLD  )
      SUBROUTINE PARADD(ADDN,ADDS,ADDE)
        ! BUILD A FORTRAN-NAMELIST

      DCL ADDSTR CHAR(*) VARYING

      COMMON / PARM(30) STATIC
     = ,2 STRING CHAR(16) VARYING ! HOLDS THE NAMES
     = ,2 VALUE BIN FIXED
      INTEGER PARHIB
       = ,LAST  ! LAST ENTRY IN 'PARM'
           STATIC INIT(0)

      !-----------------------------------------------------------------
      ! BODY OF 'PARADD'
      INTEGER START,LEN,I,NEXT,POSCOM,POSEQU

      WRITE(6, )('OPTIONS SPECIFIED: ',ADDSTR)
        (SKIP,A,A)SKIP(2)
      PARHIB = 30
      LAST = 0
      START = 1 LEN = LENGTH(ADDSTR)!
      IF(START .GT. LEN)
        NEXT = LAST + 1
        IF (NEXT .GT. PARHIB) GOTO
          POSCOM = INDEX(SUBSTR(ADDSTR,START),',')
          IF (POSCOM = 0)! NO COMMA AFTER LAST NAME
            POSCOM = LEN - START + 2 ! 1 AFTER END OF 'ADDSTR'
          POSEQU = INDEX(SUBSTR(ADDSTR,START,POSCOM - 1),'=')
          IF (POSEQU = 0) GOTO
            IF (POSCOM .LE. 3) GOTO
              IF (SUBSTR(ADDSTR,START,2) = 'NO') GOTO
                VALUE(NEXT) = 0
                STRING(NEXT) = SUBSTR(ADDSTR,START+2,POSCOM - 3)
                GOTO DONE
              CONTINUE ! NOXXX
            CONTINUE ! POSCOM .LE. 3
                VALUE(NEXT) = 1
                STRING(NEXT) = SUBSTR(ADDSTR,START  ,POSCOM - 1)
            DONE:
          CONTINUE ! WITHOUT '='
          CONTINUE
            GET STRING(SUBSTR(ADDSTR,START+POSEQU)) LIST(VALUE(NEXT))
            STRING(NEXT) = SUBSTR(ADDSTR,START,POSEQU - 1)
          CONTINUE ! WITH '='

          DO I = 1,LAST
            IF (STRING(I) = STRING(NEXT)) GOTO
              VALUE(I) = VALUE(NEXT)
              NEXT = LAST
              GOTO FOUND
            CONTINUE
          CONTINUE ! DO I

          FOUND:
          LAST = NEXT
          START = START + POSCOM
        CONTINUE ! IF (NO OVERFLOW OF 'PARM'
        CONTINUE
          WRITE(6, )('??? PARADD: INCREASE ''PARHIB'''
       = ,PARHIB,STRING(LAST)SKIP,A,F(6),X(3),A)
          GOTO ADDEND
        CONTINUE ! OVERFLOW
      CONTINUE ! WHILE IN 'ADDSTR'

      ADDEND:
      RETURN ! PARADD

        PUT EDIT('|',STRING(I),'|',VALUE(I)SKIP,A,A,A,X(3),F(6))
      !-----------------------------------------------------------------
      PARASK: ENTRY(ASKSTR,ASKDEF) RETURNS(BIN FIXED)
        ! GET THE VALUE FOR A NAME

      DCL ASKSTR CHAR(*)  ! THE NAME,BE ASKED FOR
      DCL ASKDEF BIN FIXED ! VALUE IF (THE NAME IS UNKNOWN

      DO I = 1,LAST
        IF (STRING(I) = ASKSTR)RETURN(VALUE(I))
      RETURN!  ! DO I

      RETURN(ASKDEF)
      !-----------------------------------------------------------------
      PARLAS: ENTRY(ORD,STRORD)
      ! GET KEYWORD NUMBER 'ORD' AND RETURN IT IN 'STRORD'
      ! RETURN IN 'ORD' THE NUMBER OF THE LAST KEYWORD

      DCL ORD BIN FIXED
     = ,STRORD CHAR(16) VARYING

      IF (ORD .GE. LAST THEN
        STRORD = STRING(ORD)
      CONTINUE
        STRORD = ''
      ORD = LAST
      RETURN ! PARLAS
      !-----------------------------------------------------------------
      RETURN! PARADD
      END
&END
&(PARS    )
C-------GF 08.11.80------------------------------ P A R S
      %PARAMETER BUCH=127
      %PARAMETER CODH=128
      %PARAMETER ITEH=600
      %PARAMETER LINH=41
      %PARAMETER MEMH=1200
      %PARAMETER PARH=20
      %PARAMETER PREH=1400
      %PARAMETER PRIH=61
      %PARAMETER PROH=350
      %PARAMETER SEMH=PREH
      %PARAMETER SETH=MEMH
      %PARAMETER SLOH=6
      %PARAMETER SPAH=40
      %PARAMETER STAH=500
      %PARAMETER STKH=80
      %PARAMETER STRH=4*STAH
      %PARAMETER SYMH=500
      %PARAMETER TARH=35
      %PARAMETER TRAH=SETH/3
      %PARAMETER TREH=40
      %PARAMETER DIRH=(TREH+1)*(SLOH+1)
      %PARAMETER UDIR=7
      %PARAMETER UTRE=6
      %PARAMETER UPRI=5
      %PARAMETER ULIN=4
      %PARAMETER UTAR=3
      %PARAMETER UPAR=2
      %PARAMETER UASS=1
      IMPLICIT COMPLEX (A-Z)
      INTEGER UPRI,ULIN,UTAR
      INTEGER UPAR,UASS,UTRE
      INTEGER UDIR
      INTEGER PARVAL(&PARH),PARME(&PARH)
      INTEGER PARM(3,&PARH)
      INTEGER PARLAS,PARHIB
      COMMON /AAAAAA/
     =  UPRI      ! &UPRI: TEST-PRINTOUT TO THIS UNIT
     = ,ULIN      ! &ULIN: SOURCE-PROGRAM FROM HERE
     = ,UTAR      ! &UTAR: TARGET-PROGRAM GOES HERE
     = ,UPAR      ! &UPAR: READ PARAMETERS FROM THIS FILE
     = ,UASS      ! &UASS: WRITE ASSERT-TEXTS TO THIS DIRECT-FILE
     = ,UTRE    ! &UTRE: EXTERNAL TREE ON THIS UNIT
     = ,UDIR    ! &UDIR: DIRECT-FILE FOR PARSING TABLE
     = ,PARLAS  ! ACTUAL NUMBER OF PARAMETERS
     = ,PARHIB  ! MAXIMAL ...
     = ,PARVAL  ! VALUES OF THE PARAMETERS
     = ,PARME   ! ENDING POSITION OF THE TEXTS
     = ,PARM      ! NAMES OF THE PARAMETERS
&END
&(PARSER  )
      SUBROUTINE PARSER (SCANS)
C     LR(1) SYNTAX-ANALYZER FOR 'GRAMMAR'  A N D  'SOURCE_TEXT'
C     GF 16.07.80
C     GF 08.11.80: BREAK FOR PANIC-MODE AND 'SECOND'-LOGIC
C     GF 28.12.80: 'REAL REAL'-PROBLEM, POSSIBLE SYMBOLS
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (PROS)
      %INCLUDE (STAS)
      %INCLUDE (STKS)
      %INCLUDE (SYMS)
      %INCLUDE (TRAS)
      INTEGER PARASK
      INTEGER I
     = ,ACT     ! -> 'TRA'-ELEMENT WITH THE NEXT (TERMINAL) SYMBOL
     = ,ACTION  ! RESULT OF 'DELTA': SHIFT/REDUCE/ACCEPT/ERROR
     = ,CLASS   ! FROM 'TRASYM', WHICH CLASS OF SYMBOL
     = ,ERRNO   ! NUMBER OF SYNTACTICAL ERRORS DIAGNOSED
     = ,LEFT    ! RESULTING LEFT SIDE AFTER THE REDUCTION
     = ,PROD    ! = 'SUCPRO' FOR A REDUCTION
     = ,REIPOS  ! >0 (=0) IF RE-INPUT WAS (NOT) SPECIFIED IN 'PROD'
     = ,SECOND  ! = 0 (1) IF '2004' IS REACHED FOR THE 1ST (2ND) TIME
     = ,STATE   ! THE CURRENT STATE OF THE DPDA
     = ,SUCPRO  ! RESULT OF 'DELTA': SUCCESSOR OR PRODUCTION
     = ,SYMBOL  ! THE NEXT TERMINAL TO BE SHIFTED OR LOOKED AT
     = ,TRAIN   ! -> RING WHICH CONTAINS THE REMAINING INPUT STRING
     = ,TRALEF  ! RESULT OF 'TRAFOR', -> RING FOR THE SONS OF 'LEFT'
      %INCLUDE (ENDS)
C
C     INITIALIZATION
C
        ERRNO = 0
        FSTK = 2  ! 1 IS RESERVED
      STKSYM(FSTK - 1) = EOSTMT ! FORCE BREAK IN PANIC-MODE
        I = FSYM - 1
        DO 15 SYMBOL = 2,I
          SYMMAR(SYMBOL) = 0 ! NO ACCU OR ATTRIBUTE
15      CONTINUE
        CALL LILINK (TRAHIB,TRA   ,  FTRA)
        DO 16 I = 1,TRAHIB
          TRASYM(I) = 0
          TRAENT(I) = 0
16      CONTINUE
        TRA(TRAHIB-1) = FTRA  ! FREE   R I N G
        TRAIN = TRAHIB
        CALL TRAPIM (TRAIN,TKEYW,EOFILE)
        STATE = STATE2 ! START-STATE FOR THE DPDA
C
C       GET NEXT SYMBOL FROM THE INPUT-STRING
C
1990  CONTINUE ! NEXTER:
        IF (TRA(TRAIN) .NE. TRAIN) GOTO 1 ! INPUT IS EMPTY
          CALL SCANS (TRAIN) ! READ A STATEMENT, CARE FOR KEYWORDS
1       CONTINUE
        ACT = TRA(TRAIN) ! -> 1ST SYMBOL IN INPUT
        CLASS = TRASYM(ACT)
        IF (CLASS .GE. TCOMT) GOTO 2
          IF (CLASS .EQ. TCALL) GOTO 13
            SYMBOL = TRAENT(ACT) ! FOR 'CLASS=TKEYW,TCALL...'
          GOTO 14
13        CONTINUE
            SUCPRO = STATE
            GOTO 2001 ! SHIFT 'TCALL'
14        CONTINUE
        GOTO 3
2       CONTINUE ! CLASS = TCOMT,TGOTO,TIDEN,TNUMB,TSTRI
          SYMBOL = CLASS
3       CONTINUE
C
C
C       DETERMINE NEXT PARSER ACTION DEPENDING ON 'STATE' AND 'SYMBOL'
C
        SECOND = 0 ! ERROR IS ACCESSED FOR THE FIRST TIME
1991  CONTINUE ! GETMAT:
        IF (PARASK('PARSER',1,6,0) .EQ. 0) GOTO 11
          CALL ZZWC('GETMAT: ',1,8,0)
          CALL PUTSYM (SYMBOL)
          CALL PUTSYM (TRAENT(ACT))
          CALL ZZWS (0)
11      CONTINUE
        STKSTA(FSTK) = STATE ! USEFUL FOR SHIFT AND REDUCE, LNG 0
        STKSYM(FSTK) = SYMBOL
        IF (FSTK .GE. STKHIB) GOTO 4
          FSTK = FSTK + 1
        GOTO 5
4       CONTINUE
          CALL ASSERT (38,STKHIB,0)
5       CONTINUE
        CALL DELTA (STATE,SYMBOL,  ACTION,SUCPRO)
C
C       SWITCH DEPENDING ON THE ACTION
C
1992  CONTINUE ! SWITCH
        GOTO (2001,2002,2003,2004), ACTION
C
C       SHIFT THE SYMBOL
C
2001  CONTINUE ! SHIFT
        STATE = SUCPRO
        STKTRA(FSTK - 1) = ACT ! 'FSTK' IS ALREADY INCREMENTED
        TRA(TRAIN) = TRA(ACT) ! READ 'ACT' OFF
        TRA(ACT) = ACT ! MAKE A RING
        GOTO 1990 ! NEXTER
C
C     REDUCE ACCORDING TO A PRODUCTION, DO THE TRANSFORMATION
C
2002  CONTINUE
        PROD = SUCPRO
        FSTK = FSTK - 1 - PROLNG(PROD) ! FOR '-1' SEE 'GETMAT'
        REIPOS = 0 ! ASSUME "NO RE-INPUT"
        LEFT = PROLEF(PROD) ! CARE FOR 'EOS' WITHOUT 'UNCH'
        TRALEF = TRAHIB
        CALL TRAFOR (PROD,TRAIN,  REIPOS,LEFT,TRALEF) ! TRANSFORM
        IF (REIPOS .EQ. 0) GOTO 7 ! RE-INPUT WAS SPECIFIED
          FSTK = FSTK + REIPOS - 1 ! SURELY 'FSTK < STKHIB'
          STATE = STKSTA(FSTK)
          GOTO 1990 ! NEXTER
7       CONTINUE
        STATE = STKSTA(FSTK)
        STKSYM(FSTK) = LEFT
        IF (FSTK .GE. STKHIB) GOTO 9
          FSTK = FSTK + 1
        GOTO 10
9       CONTINUE
          CALL ASSERT (38,STKHIB,0)
10      CONTINUE
C       NOW SHIFT THE LEFT SIDE
        CALL DELTA (STATE,LEFT,  ACTION,SUCPRO)
        IF (ACTION .EQ. SHIFT) GOTO 8
          CALL ASSERT (39,STATE,-LEFT)
C           IN STATE @ LEFT SIDE @ NOT SHIFTED
8       CONTINUE
        STKTRA(FSTK-1) = TRALEF
        STATE = SUCPRO
        SECOND = 0
        GOTO 1991 ! GETMAT:
C
C       PROCESS A SYNTACTICAL ERROR
C
2004  CONTINUE
        IF (SECOND .EQ. 1 .OR. TRASYM(ACT) .NE. TKEYW) GOTO 12
C         TRY IDENTIFIER INSTEAD OF KEYWORD
          SECOND = 1
          SYMBOL = TIDEN
          TRASYM(ACT) = TIDEN ! REPLACE KEYWORD BY IDENTIFIER
          FSTK = FSTK - 1 ! 'GETMAT' INCREMENTED ALREADY
          GOTO 1991 ! SWITCH
12      CONTINUE
        ERRNO = ERRNO + 1
        I = SYMBOL
        IF (I .EQ. TIDEN) I = TRAENT(ACT)
        CALL ASSERT (148, - STKSYM(FSTK-2), - I)
        IF (SYMBOL .EQ. EOFILE .OR. ERRNO .GT. 64) GOTO 2003 ! ACCEPT
C
C         ERROR-RECOVERY WITH PANIC-MODE
C
C         1. THROW ALL IN INPUT UP TO AND INCLUDING 'EOSTMT'
17        CONTINUE
            TRA(TRAIN) = TRA(ACT)
            TRA(ACT) = ACT
            CALL TRAPEN (FTRA,ACT)
            IF (TRA(TRAIN) .NE. TRAIN) GOTO 18
              CALL SCANS (TRAIN)
18          CONTINUE
          IF (TRAENT(ACT) .EQ. EOSTMT
     =      .OR. TRAENT(ACT) .EQ. EOFILE
     =    ) GOTO 19
            ACT = TRA(TRAIN)
            GOTO 17
19        CONTINUE
C
C         2. THROW ALL IN STACK UNTIL A STATE WHICH
C            IS REACHED BY 'EOSTMT'
          FSTK = FSTK - 1 ! SEE GETMAT
20        CONTINUE
            FSTK = FSTK - 1 ! THROW THE ERROR-STATE
          IF (STKSYM(FSTK) .EQ. EOSTMT) GOTO 21
            CALL TRAPEN (FTRA,STKTRA(FSTK))
            GOTO 20
21        CONTINUE
          FSTK = FSTK + 1
          STATE = STKSTA(FSTK)
        IF (PARASK('PARSER',1,6,0) .EQ. 0) GOTO 22
          CALL ASSERT (154,FSTK,STATE)
22      CONTINUE
          GOTO 1990 ! NEXTER
C
C       THE PARSE IS COMPLETE, ACCEPT THE SENTENCE
C
2003  CONTINUE ! ACCEPT:
        TRA(TRAIN) = TRA(ACT) ! READ 'EOFILE' OFF
        TRA(ACT) = ACT
        CALL TRAPEN (FTRA,ACT)
        CALL ASSERT (42,ERRNO,0)
C         PARSE IS COMPLETE, @ ERRORS
C
      RETURN
      END
&END
&(PREDEL  )
      SUBROUTINE PREDEL(STATEA,STATEB)
C     DELETE 'STATEA' FROM THE SET OF PREDECESSORS OF 'STATEB'
C     GF 09.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (PRES)
      %INCLUDE (SETS)
      %INCLUDE (STAS)
      INTEGER I
     = ,P1       ! -> ELEMENT BEFORE 'P2'
     = ,P2       ! -> CURRENT PREDECESSOR OF 'STATEB'
     = ,STATEA   ! DELETE THIS STATE
     = ,STATEB   ! DELETE FROM THE PREDECESSORS OF THIS STATE
C
      PRE(1) = STAPRE(STATEB)
      P1 = 1
      P2 = PRE(P1)!
6     IF(P2 .GE. PREHIB) GOTO 7
        IF (PRESTA(P2) .NE. STATEA) GOTO 8 ! RIGHT ELEMENT FOUND
          PRE(P1) = PRE(P2)
          PRE(P2) = FPRE!
          FPRE = P2
          GOTO 103
8       CONTINUE ! FOUND
        ! ELSE TRY NEXT ELEMENT
        P1 = P2
        P2 = PRE(P1)!
      GOTO 6
7     CONTINUE ! ALL PREDECESSORS
      ! 'STATEA' WAS NOT FOUND:
      CALL ASSERT(6,STATEA,STATEB)
103   CONTINUE
      STAPRE(STATEB) = PRE(1)
      CALL SEPUSH(STAMAR,STATEB,STAGAT,STAGAB)
      RETURN! PREDEL
      END
&END
&(PREINS  )
      SUBROUTINE PREINS(STATEA,STATEB)
C     INSERT 'STATE' IN THE SET OF PREDECESSORS OF 'STATEB'
C     GF 09.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (PRES)
      %INCLUDE (STAS)
      INTEGER I
     = ,DIFF     !,COMPARE THE PREDECESSOR-STATES
     = ,P1       ! -> ELEMENT BEFORE 'P2'
     = ,P2       ! -> CURRENT PREDECESSOR OF 'STATEB'
     = ,PRED     ! -> NEW PREDECESSOR INSERTED
     = ,STATEA   ! INSERT THIS STATE
     = ,STATEB   ! INSERT IN THE SET OF PREDECESSORS OF THIS STATE
C
      PRE(1) = STAPRE(STATEB)
      P1 = 1
      P2 = PRE(P1)!
1     IF(P1 .GE. PREHIB) GOTO 2
        DIFF = STATEA - PRESTA(P2)
        IF (DIFF .GE. 0) GOTO 3 ! INSERT BETWEEN 'P1' AND 'P2'
          IF (FPRE .GE. PREHIB) GOTO 6
            PRED = FPRE
            FPRE = PRE(FPRE)!
            PRESTA(PRED) = STATEA
            PRE(PRED) = P2
            PRE(P1) = PRED
          GOTO 7 ! NO 'PRE'-OVERFLOW
6         CONTINUE
            CALL ASSERT(11,STATEA,STATEB)
7         CONTINUE
          GOTO 100
C       GOTO 4 ! STATEA .GE.
3       CONTINUE
        IF (DIFF .NE. 0) GOTO 5 ! 'STATEA' ALREADY IN 'PRE'
          CALL ASSERT(23,STATEA,STATEB)
          GOTO 100
5       CONTINUE ! STATEA =
4       CONTINUE  ! TRY NEXT ELEMENT
        P1 = P2
        P2 = PRE(P1)!
      GOTO 1
2     CONTINUE ! ALL PREDECESSORS
      CALL ASSERT(43,STATEB,STATEA)
C
100   CONTINUE ! DONE
      STAPRE(STATEB) = PRE(1)
      RETURN! PREINS
      END
&END
&(PREPAR  )
      SUBROUTINE PREPAR (WHAT)
C     PREPARE FILES AND DATA STRUCTURES FOR PROCESSING MODULES
C     GF 23.08.80
C     GF 08.11.80: CARRAIGECONTROL='NONE' FOR 'TARGET.DAT'
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (LINS)
      %INCLUDE (MEMS)
      %INCLUDE (PROS)
      %INCLUDE (SPAS)
      %INCLUDE (STAS)
      %INCLUDE (STAT1)
      %INCLUDE (SYMS)
      %INCLUDE (TRES)
      INTEGER PARASK
      INTEGER I
     = ,WHAT    ! CODE FOR THE LOCATION IN PROGRAM 'EXTRA' (1...7)
C
      GOTO (101,102,103,104,105,106,107,108,109),WHAT
C------------------------------------------------------------
C     1 -                       BEFORE META:GRAMMAR
C
101   CONTINUE
      OPEN (UNIT=ULIN,NAME='SY:META.DAT',TYPE='OLD'
     = ,READONLY
     = )
      CALL HEADER ('SY:META.DAT',11,1)
      MEM(1) = EOP
      ITEPAG = 0
      NEWNUM = PARASK('NEWNUM',1,6,7952)
      IF (SPATES .LT. 0) GOTO 51
      CALL SPAINI
51    CONTINUE
      CALL LILINK (PROHIB,PRO   ,FPRO)
      GOTO 99
C------------------------------------------------------------
C     2 - AFTER META:GRAMMAR,   BEFORE META:REORG
C
102   CONTINUE
      GOTO 99
C------------------------------------------------------------
C     3 - AFTER META:REORG,     BEFORE GRAM:LRAXIO
C
103   CONTINUE
      IF (PARASK('PARADD',1,6,0) .NE. 0) CALL PARADD
      GOTO 99
C------------------------------------------------------------
C     4 - AFTER GRAM:LRAXIO,    BEFORE GRAM:PARSER
C
104   CONTINUE
      AXIOM = FSYM
      GRAMAX = 0 ! SEE 'SCANS': NEVER A KEYWORD
      GOTO 99
C------------------------------------------------------------
C     5 - AFTER GRAM:PARSER,    BEFORE GRAM:REORG
C
105   CONTINUE
      ITEPAG = PARASK ('ITEPAG',1,6,360)
      IF (ITEPAG .LE. 2) GOTO 1061
      IF (FMEM .GE. ITEPAG) GOTO 1062
        ITEPAG = 0
        GOTO 1061
1062  CONTINUE
        ITEPAG = 1
1061  CONTINUE
      GOTO 99
C------------------------------------------------------------
C     6 - AFTER GRAM:REORG,     BEFORE PROG:PARSER
C
106   CONTINUE
      CLOSE (UNIT=ULIN)
      GOTO 99
C-----------------------------------------------------------
C     7 - WHEN TRANSLATION ONLY, BEFORE PROG:PARSER
C
107   CONTINUE
      CALL HEADER ('SY:SOURCE.DAT',13,1)
      IF (SPATES .LT. 0) GOTO 52
      CALL SPAINI
52    CONTINUE
      OPEN  (UNIT=ULIN,NAME='SY:SOURCE.DAT',TYPE='OLD'
     = ,READONLY
     = )
      LILANG = PARASK ('LANG',1,4,2) ! FORTRAN
      LINENO = 0
      CALL LINEXT
      CALL CODGET ! LOOK-AHEAD OF THE SCANNER
      IF (PARASK('PARADD',1,6,0) .NE. 0) CALL PARADD
      NEWNUM = PARASK('NEWNUM',1,6,7952)
      OPEN (UNIT=UTRE,TYPE='SCRATCH',ACCESS='DIRECT'
     = ,RECORDSIZE=&TREH/2,ASSOCIATE VARIABLE=TRECNO,MAXREC=256
     = ,NAME='SY:TRE.DAT'
     = )
      GRAMAX = FSYM - 1 ! SEE 'SCANS'
      GOTO 99
C-----------------------------------------------------------
C     8 - AFTER PROG:PARSER,    BEFORE PROG:TARGET
C
108   CONTINUE
      CLOSE (UNIT=ULIN)
      IF (PARASK('PARADD',1,6,0) .NE. 0) CALL PARADD
      OPEN (UNIT=UTAR,TYPE='NEW'
     = ,NAME='SY:TARGET.DAT'
     = ,CARRIAGECONTROL='LIST'
     = )
      GOTO 99
C-----------------------------------------------------------
C     9 - AFTER PROG:TARGET
C
109   CONTINUE
      CLOSE (UNIT=UTAR)
      CLOSE (UNIT=UTRE)
      GOTO 99
C-----------------------------------------------------------
99    CONTINUE
      RETURN
      END
&END
&(PRES    )
C-------GF 28.08.80--------------------------------- P R E S
      INTEGER FPRE,PREHIB
      INTEGER PRE   (&PREH),PRESTA(&PREH)
      COMMON /PRES/
     =  FPRE     ! 1ST FREE PREDECESSOR
     = ,PREHIB   ! HIGH BOUND OF 'PRES'
      COMMON /PRESEM/
     =  PRE     ! -> NEXT PREDECESSOR
     = ,PRESTA  ! NUMBER OF THE PREDECESSOR-STATE
&END
&(PRESEMS )
C-------GF 28.08.80------------------------- P R E S E M S
      INTEGER FSEM,SEMHIB,PNOSEM
     = ,ACCO,ACIN,ACMA,ACTA  ! ACCUMULATOR
     = ,ATCO,ATIN,ATMA,SYAT  ! ATTRIBUTE
     = ,SOCO,REIN,UNCH,SOTA  ! SON, MEMBER
     = ,SYCO,SYIN,SYMA,SEPR  ! NEW SYMBOL
     = ,ACCU,ATTR,EOSY,EOS   ! MISCELLANEOUS
        INTEGER SEMSYM(&SEMH)
      INTEGER SEM   (&SEMH)
      COMMON /SEMS/
     =  FSEM      ! 1ST FREE 'SEM'-ENTRY
     = ,SEMHIB  ! HIGH BOUND OF 'SEM'
     = ,PNOSEM  ! -> DUMMY ACTION: UNCH, EOS
     = ,ACCO,ACIN,ACMA,ACTA  ! ACCUMULATOR
     = ,ATCO,ATIN,ATMA,SYAT  ! ATTRIBUTE
     = ,SOCO,REIN,UNCH,SOTA  ! SON, MEMBER
     = ,SYCO,SYIN,SYMA,SEPR  ! NEW SYMBOL
     = ,ACCU,ATTR,EOSY,EOS   ! MISCELLANEOUS
      EQUIVALENCE (PRE(1),SEM(1)),(PRESTA(1),SEMSYM(1))
&END
&(PRIS    )
C------------------------------------------------------- P R I S
      INTEGER FPRI,PRIHIB,PRIBUF(&PRIH)
      COMMON /PRIS/
     =  FPRI   ! 1ST FREE PRINT POSITION
     =, PRIHIB ! LAST AVAILABLE PRINT POSITION
     =, PRIBUF ! BUFFER WHICH COLLECTS STREAM PRINT-OUT
&END
&(PRIXRE  )
      SUBROUTINE PRIXRE
      !*****************************************************************
      !  P R I X R E   PRINT CROSS-REFERENCE TABLE
      !*****************************************************************
      INTEGER I
     = ,XREF     ! = 1(0) IF (CROSS-REFERENCE (NOT) DESIRED
        INIT(0)
       STATIC
     = ,PARASK ENTRY(CHAR(*),BIN FIXED) RETURNS(BIN FIXED)
     = ,IHESRTA  ENTRY(CHAR(*),CHAR(*),BIN FIXED(31),BIN FIXED(31))
     = ,(SORTIN,SORTOUT) FILE RECORD
     = ,ALIGN1 BIN FIXED(31)
     = ,1 LINE
     = ,2 ROW    CHAR(34)
     = ,2 COLM   CHAR( 6)
     = ,RATTR CHAR(4) DEFINED ROW POS(1)
     = ,RID   CHAR(30)DEFINED ROW POS(5)
     = ,CLIN  CHAR(5) DEFINED COLM POS(1)
     = ,CUSE  CHAR(1) DEFINED COLM POS(6)
     = ,ALIGN2 BIN FIXED(31)
     = ,1 OLD_LINE
     = ,2 OLD_ROW CHAR(34)
     = ,2 OLD_COLM CHAR(6)
     = ,COLNO BIN FIXED
     = ,RETURN_CODE BIN FIXED(31) INIT(0)

      %INCLUDE(LINS
      %INCLUDE(STRS
      %INCLUDE(SYMS
      !------------------------------------------------
      CLOXRE: ENTRY
      CLOSE FILE(SORTIN)
      RETURN ! CLOXRE
      CALL IHESRTA('  SORT FIELDS=(5,30,A,CH,1,4,A,CH,35,6,A,CH) '! PL1-
            = ,'  RECORD TYPE=F,LENGTH=(40) '
            = ,100000
            = ,RETURN_CODE
                  )
      !------------------------------------------------
      PUTXRE: ENTRY
      OLD_ROW = ' '
      OPEN FILE(SORTOUT)
      ON ENDFILE(SORTOUT) GOTO FIN
      LOOP:
      READ FILE(SORTOUT) INTO (LINE)
      IF (ROW .EQ. OLD_ROW) GOTO ! NEW ROW
        COLNO = 0
        WRITE(6, )(RATTR,RIDSKIP,A,X(2),A)
        OLD_ROW = ROW
        OLD_COLM = ' '
      CONTINUE ! NEW ROW
      COLNO = MOD(COLNO+1,12)
      IF (COLNO = 0 THEN
        WRITE(6, )('    'SKIP,X(LENGTH(RID)),X(2),A)
      IF (COLM .EQ. OLD_COLM) GOTO
        OLD_COLM = COLM
        WRITE(6, )(COLMX(2),A)
      CONTINUE ! NEW COLM
      GOTO LOOP
      FIN:
      CLOSE FILE(SORTOUT)
      RETURN ! PRIXRE

      !-----------------------------------------------------------------
      ! I N I X R E    INITIALIZE CROSS-REFERENCE FILE
      !-----------------------------------------------------------------
      INIXRE: ENTRY
      XREF = PARASK('XREF',0)
      IF (XREF = 0)RETURN
      OPEN FILE(SORTIN) OUTPUT
      RETURN ! INIXRE

      !-----------------------------------------------------------------
      !  O U T X R E   MAKE AN ENTRY FOR CROSS-REFERENCE LISTING
      !-----------------------------------------------------------------
      OUTXRE: ENTRY(     ATTR,IDEN,LIN,USE)
      DCL SYMB BIN FIXED
     = ,(ATTR
     = ,IDEN
     = ,LIN
     = ,USE
      ) CHAR(*)

      IF (XREF = 0)RETURN
      RATTR = ATTR
      RID = IDEN
      IF (LIN = ' ' THEN
        PUT STRING(CLIN) EDIT(LINENOF(5))
      CONTINUE
        CLIN = LIN
      OUT:
      CUSE = USE
      WRITE FILE(SORTIN) FROM (LINE)
      RETURN ! OUTXRE
      !--------------------------------------------------------
      !  W R I X R E    WRITE A SYMBOL,THE XREF-FILE
      !--------------------------------------------------------
      WRIXRE: ENTRY(SYMB,USE)
      IF (XREF = 0)RETURN
      RATTR = ' '
      RID = SUBSTR(STRNG,SYMPOS(SYMB),SYMLNG(SYMB))
      PUT STRING(CLIN) EDIT(LINENOF(5))
      GOTO OUT
      RETURN! PRIXRE
      END
&END
&(PROCHA  )
      SUBROUTINE PROCHA (ADDSUB,LEFT,MON,LNG,PROD)
      ! PROCESS THE NEXT PRODUCTION DELIVERED,THE USER
      %INCLUDE (PARS)
      %INCLUDE (MEMS)
      %INCLUDE (PROS)
      %INCLUDE (SYMS)
      INTEGER I
     = ,ADDSUB   ! = 1(0) : ADD (SUBTRACT) THE PRODUCTION
     = ,LEFT     ! SYMBOL ON THE LEFT SIDE
     = ,LMEM     ! -> LAST MEMBER OF THE NEW PRODUCTION
     = ,LNG      ! THE LENGTH OF THE NEW PRODUCTION
     = ,M        ! = 1 ... FMEM-1
     = ,MEMB
     = ,MON      ! MEMBER NUMBER ONE
     = ,P1       ! -> PRODUCTION BEFORE THE ONE FOUND,'PROSAM'
     = ,P2       ! -> PRODUCTION FOUND,'PROSAM'
     = ,PROD     ! THE NEW PRODUCTION BUILT,'PROADD'
C
      ! SEE WHETHER A NEW PRODUCTION IS ALREADY IN THE GRAMMAR
      LMEM = MON + LNG - 1 ! THE LAST MEMBER OF THE NEW PRODUCTION
      P1 = 1
      PRO(1) = SYMPRO(LEFT)
      P2 = PRO(P1)
1     IF(P2 .GE. PROHIB) GOTO 2
        IF (LNG .NE. PROLNG(P2)) GOTO 3
        MEMB = PROMON(P2)
        M = MON
18      IF(M .GT. LMEM) GOTO 4
          IF (MEM(M) .NE. MEM(MEMB))
     =      GOTO 101 ! REALLY NEW PRODUCTION
          MEMB = MEMB + 1
          M = M + 1
        GOTO 18
4       CONTINUE ! DO M
        ! HERE ALL MEMBERS WERE EQUAL
        GOTO 100
3       CONTINUE ! SAME LENGTHS
101     CONTINUE
        P1 = P2
        P2 = PRO(P1)! ! TAKE NEXT PRODUCTION
        GOTO 1
2     CONTINUE ! ALL PRODUCTIONS OF 'LEFT'
100   CONTINUE
      ! 'P2 = PROHIB' : REALLY NEW PRODUCTION
      ! 'P2 .GE. PROHIB' : PRODUCTION 'P2' IS EQUAL,THE NEW ONE
      ! 'P1' IS NEEDED IF (PRODUCTION 'P2' SHOULD BE DELETED
      IF (P2 .NE. PROHIB) GOTO 5 ! REALLY NEW PRODUCTION
        IF (ADDSUB .NE. 1) GOTO 7 ! ADD THE PRODUCTION
          IF (FPRO .GE. PROHIB) GOTO 9 ! 'PRO'-ALLOCATE POSSIBLE
            PROD = FPRO
            FPRO = PRO(FPRO)!
            PROLEF(PROD) = LEFT
            PROMON(PROD) = MON
C           PROLNG(PROD) = FMEM - MON
C           PROMAR(PROD) = 0
            PRO   (PROD) = SYMPRO(LEFT)
            SYMPRO(LEFT) = PROD
            MEM   (FMEM) = 1 ! DUMMY SYMBOL BEHIND THE ENTIRE PRODUCTION
            MEMNUC(FMEM) = PROD
            IF (FMEM .GE. MEMHIB) GOTO 11
              FMEM = FMEM + 1
              GOTO 12
11          CONTINUE
              CALL ASSERT(19,-LEFT,FMEM)
12          CONTINUE
C$ENB$      CALL SEPUSH(SYMMAR,LEFT,SYMINT,SYMINB) ! SYMINS
          GOTO 10 ! ALLOCATE POSSIBLE
9         CONTINUE ! 'PRO'-OVERFLOW
            CALL ASSERT(16,-LEFT,FMEM)
            FMEM = MON ! DELETE THE PRODUCTION
10        CONTINUE ! OVERFLOW
        GOTO 8 ! ADD
7       CONTINUE ! SUBTRACT A PRODUCTION THAT IS UNKNOWN
          CALL ASSERT(54,MON,LEFT)
          FMEM = MON
8       CONTINUE ! SUBTRACT
      GOTO 6 ! NO SAME ONE FOUND
5     CONTINUE ! SAME PRODUCTION FOUND
        PROD = P2
        IF (ADDSUB .NE. 1) GOTO 13 ! ADD
          CALL ASSERT(17,PROD,-LEFT)
          FMEM = MON
        GOTO 14 ! ADD
13      CONTINUE ! SUBTRACT
          PRO(1) = SYMPRO(LEFT)
          P1 = 1
          P2 = PRO(P1)!
15        IF(P2 .GE. PROHIB) GOTO 16
            IF (P2 .NE. PROD) GOTO 17
              PRO(P1) = PRO(P2)
              PRO(P2) = FPRO
              FPRO = P2!
C             CALL SEPUSH(PROMAR,PROD,PRODET,PRODEB)
              GOTO 102
17          CONTINUE ! FOUND
            ! CONTINUETRY NEXT ELEMENT
            P1 = P2
            P2 = PRO(P1)!
            GOTO 15
16        CONTINUE ! ALL PRODUCTIONS OF 'LEFT'
          ! 'PROD' WAS NOT FOUND HERE
          CALL ASSERT(49,PROD,LEFT)
102       CONTINUE
         FMEM = MON
         SYMPRO(LEFT) = PRO(1)
14     CONTINUE ! SUBTRACT
6     CONTINUE ! SAME PRODUCTION
      RETURN! PROCHA
      END
&END
&(PROLNG  )
      INTEGER FUNCTION PROLNG(PROD)
C     LENGTH OF THE RIGHT SIDE
C     (REPLACES AN ARRAY SET IN 'PROCHA')
C     GF 21.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (MEMS)
      INTEGER FPRO,PROHIB
      INTEGER PRO   (&PROH),PROLEF(&PROH)
      INTEGER PROMON(&PROH),PROSEM(&PROH)
      COMMON /PROS/
     =  FPRO     ! 1ST FREE PRODUCTION
     = ,PROHIB   ! HIGH BOUND OF 'PROS'
     = ,PRO     ! -> NEXT PRODUCTION OF THE LEFT SIDE
     = ,PROLEF  ! SYMBOL ON THE LEFT SIDE
     = ,PROMON  ! -> FIRST MEMBER
     = ,PROSEM  ! -> SEMANTICS FOR THE PRODUCTION
      INTEGER I
     = ,PROD
C
      I = PROMON(PROD)
1     IF(MEM(I) .EQ. EOP) GOTO 2
        I = I + 1
      GOTO 1
2     CONTINUE
      PROLNG = I - PROMON(PROD)
      RETURN
      END
&END
&(PROS    )
C-------GF 28.08.80------------------------------------- P R O S
      INTEGER FPRO,PROHIB
      INTEGER PRO   (&PROH),PROLNG,PROLEF(&PROH)
      INTEGER PROMON(&PROH),PROSEM(&PROH)
      COMMON /PROS/
     =  FPRO     ! 1ST FREE PRODUCTION
     = ,PROHIB   ! HIGH BOUND OF 'PROS'
     = ,PRO     ! -> NEXT PRODUCTION OF THE LEFT SIDE
     = ,PROLEF  ! SYMBOL ON THE LEFT SIDE
     = ,PROMON  ! -> FIRST MEMBER
     = ,PROSEM  ! -> SEMANTICS FOR THE PRODUCTION
&END
&(PUTACT  )
        SUBROUTINE PUTACT (ITEM)
C       PRINT THE ACTION OF AN ITEM
C       GF 11.07.80
C
        %INCLUDE (PARS)
        %INCLUDE (ITES)
        %INCLUDE (PROS)
        INTEGER
     =  ACT     ! THE ACTION OF THE PARSER
     = ,ITEM    ! THE ITEM THE ACTION OF WHICH IS TO BE PRINTED
     = ,PROD    ! THE PRODUCTION FOR 'ACT = REDUCE'
     = ,MNEMO(4) ! THE MNEMONICS FOR THE ACTIONS
        DATA MNEMO/'->', '=:', '=.', '??'/
C
        ACT = ITEACT(ITEM)
        CALL ZZWC (MNEMO(ACT),1,2,3)
        PROD = ITESUC (ITEM)
        CALL ZZWI (PROD,0)
        IF (ACT .NE. REDUCE) GOTO 2
          CALL ZZWC (': ',1,2,0)
          CALL OUTMAP (PROD,0)
2       CONTINUE
        RETURN ! PUTACT
        END
&END
&(PUTCON  )
      SUBROUTINE PUTCON
C     PRINT ALL DIFFERENT CONFLICTS
C     GF 20.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (PROS)
      %INCLUDE (MEMSETS)
      %INCLUDE (STAS)
      %INCLUDE (STASTRS)
      %INCLUDE (SYMS)
      INTEGER FPRE,PREHIB,PRE(100),PRESTA(100)
      EQUIVALENCE (FPRE,FITE),(PREHIB,ITEHIB)
      EQUIVALENCE (PRE(1),ITE(1)),(PRESTA(1),ITESUC(1))
      INTEGER PARASK, INDEX
      INTEGER I,J
     = ,CONH     ! HEAD OF CONFLICT-LIST IN 'PRE'
     = ,CONFL    ! =1 IF (A CONFLICT WAS FOUND
     = ,ELEM     ! ->  ELEMENT IN SPLIT-QUEUE
     = ,GOT     ! RESULT OF 'ITEMA1/2', =1 IF STATE WAS READ
     = ,I1       ! -> FIRST ITEM FOR COMPARISION
     = ,I2       ! -> 2ND   ITEM FOR COMPARISION
     = ,ITEM     ! -> CURRENT ITEM
     = ,ITEMA    ! FIRST ITEM WITH SYMBOL 'SYMA'
     = ,POS      !,FIND THE END OF THE PRODUCTION
     = ,PRED     ! -> PRE
     = ,PROD     ! A MARKED PRODUCTION INVOLVED IN THE CONFLICT
     = ,SAME     ! =1 IF (SAME CONFLICT ALREADY STORED
     = ,STATE    ! THE STATE WHICH CONTAINS THE CONFLICT
     = ,SYMA     ! = ITESYM(ITEMA)
C
      IF (PARASK('SINGLE',1,6,0) .EQ. 0) GOTO 1
        ELEM = SET(SYMINH)
        I = 0 ! COUNT UNREACHABLES
        IF (SYMINH .EQ. SYMINT) GOTO 3
2       IF(ELEM .EQ. SYMINT) GOTO 3
          I = I + 1
          ELEM = SET(ELEM)
        GOTO 2
3       CONTINUE
        CALL ZZWI (I,4)
      GOTO 34
1     CONTINUE ! IF (SINGLE
C     DO ! ONLY SPECIFIC INFORMATION ON INACCESIBLES AND CONFLICTS
        ! MARK TERMINALS IN CROSS-REFERENCE-TABLE
        CALL ASSERT (196,0,0)
        J = FSYM - 1
        DO 4 I = 2,J
          IF (SYMPRO(I) .LT. PROHIB) GOTO 5 ! TERMINALS
C           CALL OUTXRE(' ',SUBSTR(STRNG,SYMPOS(I),SYMEND(I)),'TERM',' '
            IF (INDEX(STRNG,SYMPOS(I),SYMEND(I),'_') .LE. 0) GOTO 38
              CALL PUTSYM (I)
              CALL ZZWS (0)
38          CONTINUE
5         CONTINUE ! IF TERMINAL
4       CONTINUE ! 2 ... FSYM -1
C
        IF (SYMINH .EQ. SYMINT) GOTO 6 !   IF HYPER_AXIOM IS ALREADY OFF
        ELEM = SET(SYMINH)
        IF (ELEM .EQ. SYMINT) GOTO 6 ! UNREACHABLE SYMBOLS DO EXIST
          CALL ASSERT(198,0,0)
7         IF (ELEM .EQ. SYMINT) GOTO 8
            CALL PUTSYM(SETELE(ELEM))
          CALL ZZWS (0)
            ELEM = SET(ELEM)
          GOTO 7
8         CONTINUE
6       CONTINUE ! UNREACHABLE SYMBOLS
C
        CONH = PREHIB ! THE LIST IS EMPTY INITIALLY
        ELEM = SPLITH
12      IF(ELEM .EQ. SPLITT) GOTO 13
          STATE = SETELE(ELEM)
          CALL ITEMA1 (STATE,  ITEMA,GOT)
          SYMA = ITESYM(ITEMA)!
14        IF(ITEMA .GE. ITEHIB) GOTO 15
            CONFL = 0
            ITEM = ITE(ITEMA)
16          IF(ITESYM(ITEM) .NE. SYMA) GOTO 17
              IF (ITEACT(ITEM) .NE. REDUCE) GOTO 18
                CONFL = 1
18            CONTINUE
              ITEM = ITE(ITEM)
            GOTO 16
17          CONTINUE ! = SYMA
            IF (CONFL .NE. 1) GOTO 19 ! CONFLICT FOR 'SYMA' FOUND
            WRITE (UPRI,36)
36          FORMAT(1X,8(10H----------))
            CALL ASSERT (197,-SYMA,0)
C             CONFLICT FOR SYMBOL @:
31          IF(ITESYM(ITEMA) .NE. SYMA) GOTO 32
              POS = ITEPOS(ITEMA)
29            IF(MEM(POS) .EQ. EOP) GOTO 30
                POS = POS + 1
              GOTO 29
30            CONTINUE ! .EQ. 1
              PROD = MEMNUC(POS)
              CALL OUTMAP(PROD,ITEPOS(ITEMA))
              CALL ZZWS(0)
              ITEMA = ITE(ITEMA)
            GOTO 31
32          CONTINUE ! = SYMA
19          CONTINUE ! CONFL = 1
            ITEMA = ITEM
            SYMA = ITESYM(ITEMA)!
          GOTO 14
15        CONTINUE ! .GE. ITEHIB
          CALL ITEMA8 (STATE,GOT)
          ELEM = SET(ELEM)
        GOTO 12
13      CONTINUE ! .EQ. SPLITT
34    CONTINUE ! SPECIFIC
      RETURN! PUTCON
      END
&END
&(PUTCOQ  )
      SUBROUTINE PUTCON
C     PRINT ALL DIFFERENT CONFLICTS
C     GF 20.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (PROS)
      %INCLUDE (MEMSETS)
      %INCLUDE (STAS)
      %INCLUDE (STASTRS)
      %INCLUDE (SYMS)
      INTEGER FPRE,PREHIB,PRE(100),PRESTA(100)
      EQUIVALENCE (FPRE,FITE),(PREHIB,ITEHIB)
      EQUIVALENCE (PRE(1),ITE(1)),(PRESTA(1),ITESUC(1))
      INTEGER PARASK, INDEX
      INTEGER I,J
     = ,CONH     ! HEAD OF CONFLICT-LIST IN 'PRE'
     = ,CONFL    ! =1 IF (A CONFLICT WAS FOUND
     = ,ELEM     ! ->  ELEMENT IN SPLIT-QUEUE
     = ,GOT     ! RESULT OF 'ITEMA1/2', =1 IF STATE WAS READ
     = ,I1       ! -> FIRST ITEM FOR COMPARISION
     = ,I2       ! -> 2ND   ITEM FOR COMPARISION
     = ,ITEM     ! -> CURRENT ITEM
     = ,ITEMA    ! FIRST ITEM WITH SYMBOL 'SYMA'
     = ,POS      !,FIND THE END OF THE PRODUCTION
     = ,PRED     ! -> PRE
     = ,PROD     ! A MARKED PRODUCTION INVOLVED IN THE CONFLICT
     = ,SAME     ! =1 IF (SAME CONFLICT ALREADY STORED
     = ,STATE    ! THE STATE WHICH CONTAINS THE CONFLICT
     = ,SYMA     ! = ITESYM(ITEMA)
C
      IF (PARASK('SINGLE',1,6,0) .EQ. 0) GOTO 1
        ELEM = SET(SYMINH)
        I = 0 ! COUNT UNREACHABLES
        IF (SYMINH .EQ. SYMINT) GOTO 3
2       IF(ELEM .EQ. SYMINT) GOTO 3
          I = I + 1
          ELEM = SET(ELEM)
        GOTO 2
3       CONTINUE
        CALL ZZWI (I,4)
      GOTO 34
1     CONTINUE ! IF (SINGLE
C     DO ! ONLY SPECIFIC INFORMATION ON INACCESIBLES AND CONFLICTS
        ! MARK TERMINALS IN CROSS-REFERENCE-TABLE
        CALL ASSERT (196,0,0)
        J = FSYM - 1
        DO 4 I = 2,J
          IF (SYMPRO(I) .LT. PROHIB) GOTO 5 ! TERMINALS
C           CALL OUTXRE(' ',SUBSTR(STRNG,SYMPOS(I),SYMEND(I)),'TERM',' '
            IF (INDEX(STRNG,SYMPOS(I),SYMEND(I),'_') .LE. 0) GOTO 38
              CALL PUTSYM (I)
              CALL ZZWS (0)
38          CONTINUE
5         CONTINUE ! IF TERMINAL
4       CONTINUE ! 2 ... FSYM -1
C
        IF (SYMINH .EQ. SYMINT) GOTO 6 !   IF HYPER_AXIOM IS ALREADY OFF
        ELEM = SET(SYMINH)
        IF (ELEM .EQ. SYMINT) GOTO 6 ! UNREACHABLE SYMBOLS DO EXIST
          CALL ASSERT(198,0,0)
7         IF (ELEM .EQ. SYMINT) GOTO 8
            CALL PUTSYM(SETELE(ELEM))
          CALL ZZWS (0)
            ELEM = SET(ELEM)
          GOTO 7
8         CONTINUE
6       CONTINUE ! UNREACHABLE SYMBOLS
C
        CONH = PREHIB ! THE LIST IS EMPTY INITIALLY
        ELEM = SPLITH
12      IF(ELEM .EQ. SPLITT) GOTO 13
          STATE = SETELE(ELEM)
          CALL ITEMA1 (STATE,  ITEMA,GOT)
          SYMA = ITESYM(ITEMA)!
14        IF(ITEMA .GE. ITEHIB) GOTO 15
            CONFL = 0
            ITEM = ITE(ITEMA)
16          IF(ITESYM(ITEM) .NE. SYMA) GOTO 17
              IF (ITEACT(ITEM) .NE. REDUCE) GOTO 18
                CONFL = 1
18            CONTINUE
              ITEM = ITE(ITEM)
            GOTO 16
17          CONTINUE ! = SYMA
            IF (CONFL .NE. 1) GOTO 19 ! CONFLICT FOR 'SYMA' FOUND
              CALL ASSERT (136,-SYMA,STATE)
              PRED = CONH
20            IF(PRED .GE. PREHIB) GOTO 21
                I1 = PRESTA(PRED)
                I2 = ITEMA!
22              IF(ITESYM(I1) .NE. SYMA .AND. ITESYM(I2) .NE. SYMA)
     =          GOTO 23
                  IF (ITEPOS(I1) .EQ. ITEPOS(I2))
     =              GOTO 99
                  I1 = ITE(I1)
                  I2  = ITE(I2)!
                GOTO 22
23              CONTINUE ! 1 = SYMA .AND. 2 = SYMA
                GOTO 100
99            CONTINUE !      DIFFER:
                PRED = PRE(PRED)
              GOTO 20
21            CONTINUE ! COMPARE WITH ALL PREVIOUS CONFLICTS
              IF (FPRE .GE. PREHIB) GOTO 24
                PRED = FPRE
                FPRE = PRE(FPRE)!
                PRE(PRED) = CONH
                CONH = PRED!
                PRESTA(CONH) = ITEMA
              GOTO 25 ! NO 'PRE'-OVERFLOW
24            CONTINUE
                CALL ASSERT(195,PRED,PREHIB)
25            CONTINUE
C
100         CONTINUE !        DONE:
19          CONTINUE ! CONFL = 1
            ITEMA = ITEM
            SYMA = ITESYM(ITEMA)!
          GOTO 14
15        CONTINUE ! .GE. ITEHIB
          CALL ITEMA8 (STATE,GOT)
          ELEM = SET(ELEM)
        GOTO 12
13      CONTINUE ! .EQ. SPLITT
C
        ! NOW PRINT THE COLLECTED CONFLICTS
        IF (CONH .GE. PREHIB) GOTO 33
          CALL ASSERT (185,0,0)
27        IF (CONH .GE. PREHIB) GOTO 28
            ITEMA = PRESTA(CONH)
            SYMA = ITESYM(ITEMA)!
31          IF(ITESYM(ITEMA) .NE. SYMA) GOTO 32
              POS = ITEPOS(ITEMA)
29            IF(MEM(POS) .EQ. EOP) GOTO 30
                POS = POS + 1
              GOTO 29
30            CONTINUE ! .EQ. 1
              PROD = MEMNUC(POS)
              CALL OUTMAP(PROD,ITEPOS(ITEMA))
              CALL ZZWS(0)
              ITEMA = ITE(ITEMA)
            GOTO 31
32          CONTINUE ! = SYMA
            WRITE (UPRI,36)
36          FORMAT(1X,8(10H----------))
            PRED = CONH
            CONH = PRE(CONH)!
            PRE(PRED) = FPRE
            FPRE = PRED!
          GOTO 27
28        CONTINUE ! WHILE .GE. PREHIB
33      CONTINUE ! IF (.GE. PREHIB
34    CONTINUE ! SPECIFIC
      RETURN! PUTCON
      END
&END
&(PUTSYM  )
      SUBROUTINE PUTSYM (SYM)
C     PRINT THE EXTERNAL REPRESENTATION OF A SYMBOL
C     GF 11.07.80
C     GF 27.12.80: WITHOUT SYMBOL-NO.
C
      %INCLUDE (PARS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      INTEGER PARASK
      INTEGER SYM
C
      IF (PARASK('PUTSYN',1,6,0) .NE. 0)
     =  CALL ZZWI (SYM,0)
      CALL ZZWC('''',1,1,0)
      IF (SYM .LT. 2 .OR. SYM .GE. FSYM
     =    .OR. SYMLNK(1) .EQ. 0
     =  ) GOTO 1
        CALL ZZWC (STRNG,SYMPOS(SYM),SYMEND(SYM),0)
1     CONTINUE
      CALL ZZWC ('''',1,1,0)
      RETURN
      END
&END
&(RECEIV  )
      SUBROUTINE RECEIV (STATEB,APPLY)
C     CALLS 'APPLY(STATEB,STATEZ,PRODZ)' FOR ALL REDUCTIONS 'PRODZ' IN
C       'STATEZ' THAT RECEIVE THEIR LOOK-AHEAD SYMBOLS FROM 'STATEB'
C     GF 09.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (PRES)
      %INCLUDE (PROS)
      %INCLUDE (STAS)
      %INCLUDE (SYMS)
      EXTERNAL APPLY
      INTEGER I
     = ,PRED     ! -> A PREDECESSOR OF 'STATEA'
     = ,PROD     ! A PRODUCTION OF THE REACHING SYMBOL OF 'STATEB'
     = ,PRODZ    ! MUST BE = 'PROD'
     = ,STATEA   ! A PREDECESSOR OF 'STATEB'
     = ,STATEB   ! THE STATE THAT EMITTS THE LOOK-AHEAD SYMBOLS
     = ,STATEZ   ! THE STATE THAT HAS THE REDUCTION TO THE REACHING SYMB
C
      PROD = SYMPRO(STASYM(STATEB))
1     IF(PROD .GE. PROHIB) GOTO 2
        ! FOR ALL PRODUCTIONS OF THE REACHING SYMBOL OF 'STATEBH
        PRED = STAPRE(STATEB)
3       IF(PRED .GE. PREHIB) GOTO 4
          STATEA = PRESTA(PRED)
          CALL ALONG(STATEA,PROMON(PROD),STATEZ,PRODZ)
          IF (PRODZ .NE. PROD)
     =      CALL ASSERT(24,PROD,PRODZ)
          IF (STATEZ .GT. 0)
     =      CALL APPLY(STATEB,STATEZ,PRODZ)
          ! ELSE
            ! 'LAGET' IS ISSUED WHEN REDUCTION IS INSERTED,'ITEINS'
          PRED = PRE(PRED)
        GOTO 3
4       CONTINUE ! ALL PREDECESSORS
        PROD = PRO(PROD)
      GOTO 1
2     CONTINUE ! ALL PRODUCTIONS
      RETURN! RECEIV
      END
&END
&(REORG   )
      SUBROUTINE REORG
C     REORGANIZE ALL TABLES OF THE PARSER TO REFLECT THE CHANGED GRAMMAR
C     GF 19.07.80 'LREORG' INCORPORATED
C
      %INCLUDE (PARS)
      %INCLUDE (INFS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (PRES)
      %INCLUDE (PROS)
      %INCLUDE (PRESEMS)
      %INCLUDE (SPAS)
      %INCLUDE (STAS)
      %INCLUDE (STASTRS)
      %INCLUDE (SYMS)
      INTEGER PARASK
      INTEGER ORD       ! FOR CALLS OF 'INSTAR', 'INSTOP'
     = ,CHANGE  ! = 1(0) WHILE SOMETHING CHANGED DURING 'SYMINS'
C
      CALL INSTAR('REORG',6)
      ORD = 1
      CALL INFSTO(1,FSYM-1,SYMHIB)
      CALL INFSTO(2,FPRO-1,PROHIB)
      CALL INFSTO(3,FMEM-1,MEMHIB)
      CALL INFSTO(4,FSTR-1,STRHIB)
      CALL INFSTO (9,FSEM-1,SEMHIB)
      IF (PARASK('INFOUT',1,6,0) .NE. 0)
     =  CALL INFOUT
      CALL INSTAR('STASUC',ORD)
      CALL LROPEN
      CHANGE = 1
1     IF(CHANGE .NE. 1) GOTO 2
        CHANGE = 0
        CALL SYMINS(CHANGE)
        CALL STASUC
        GOTO 1
2     CONTINUE ! WHILE CHANGE = 1
      CALL INSTOP(ORD)
      IF (PARASK('SETSIN',1,6,0) .NE. 0)
     =  CALL SETSIN
      IF (PARASK('IMDUMP',1,6,0) .NE. 0)
     =  CALL LRDUMP
      IF (PARASK('ENBLOC',1,6,0) .NE. 0) GOTO 3
      ORD = ORD + 1
      CALL INSTAR('LAGAR' ,ORD)
      CALL LAGAR
      CALL INSTOP(ORD)
      ORD = ORD + 1
      CALL INSTAR('STAGAR',ORD)
      CALL STAGAR
      CALL INSTOP(ORD)
      ORD = ORD + 1
      CALL INSTAR('LAGET' ,ORD)
      CALL LAGET
      CALL INSTOP(ORD)
3     CONTINUE
      ORD = ORD + 1
      CALL INSTAR('LAPUT' ,ORD)
      CALL LAPUT
      CALL INSTOP(ORD)
      ORD = ORD + 1
      CALL INFLIS(5,STAPRE,FSTA,STAHIB)
      CALL INFSTO(6,SPAHIB,ITEHIB)
      CALL INFLIS(7,PRE   ,FPRE,PREHIB)
C     NOW READ 'SYMPOS,SYMLNK,SEM,SEMSYM,STRNG' WHICH OVERLAY
C              'SYMRST, ---  ,PRE,PRESTA,(STAPRE,-RST,-SYM,-MAR)'
      CALL DIRECT (1) ! READ OVL
      IF (PARASK('CLEARE',1,6,0) .NE. 0)
     =  CALL CLEARE
      IF (PARASK('PUTCON',1,6,1) .NE. 0)
     =  CALL PUTCON
      IF (PARASK('DUMP',1,4,0) .NE. 0)
     =  CALL LRDUMP
      CALL INSTOP(6)
      CALL INFOUT
      RETURN ! REORG
      END
&END
&(SCAINI  )
      SUBROUTINE SCAINI
C     INITIALIZE THE SCANNER
C
      %INCLUDE (PARS)
      %INCLUDE (CODS)
      %INCLUDE (SYMS)
      INTEGER I
C
      CALL CODINI(I) ! 110
      CALL LINIT ! 120,130
      CALL CODASS(' ',1,1,I) ! 140
      CALL CODASS('0123456789',1,10,I) ! 150
      CALL CODASS('ABCDEFGHIJKLMNOPQRSTUVWXYZ_',1,27,I) !160
      CALL CODASS('''',1,1,I) ! 170
C
      CALL HAINIT
      CALL SPEINI
      CALL SPEINS('??',1,2,ERRSYM)
      ! THIS SYMBOL IS RETURNED FOR ILLEGAL COMBINATIONS OF 110IALS
      CALL SPEINS('/*',1,2,SCOBEG)
      CALL SPEINS('*/',1,2,SCOEND)
C
      CALL CODGET ! (SC)
      RETURN ! SCAINI
      END
&END
&(SCAN    )
      SUBROUTINE SCAN (SYMBOL,ENTITY)
C     THE SCANNER BUILDS SYMBOLS FROM CHARACTERS
C     GF 12.07.80 : WITH PARASK('SCAN')
C
      %INCLUDE (PARS)
      %INCLUDE (CODS)
      %INCLUDE (LINS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      INTEGER PARASK
      INTEGER I
     = ,ENTITY        ! -> SYM -> STR
     = ,SCOLS        ! NUMBER OF COLUMS IN THE FA-TABLE
     = ,START   ! -> 1ST CHARACTER OF THE SYMBOL IN 'LINE'
     = ,STATE        ! CURRENT STATE OF THE FINITE AUTOMATON
     = ,SYMBOL  ! THE SYMBOL-CLASS, IDENT, NUMBER ...
      INTEGER SINIT,SA1QU,SNUMB,SIDEN,SA2QU,SCOMT
      DATA    SINIT,SA1QU,SNUMB,SIDEN,SA2QU,SCOMT
     =       /  0  ,  8  ,  16 ,  24 ,  32 ,  40 / ! STATE * 8, EOST->8
        STATE = SINIT
        GOTO 1901
1800  CONTINUE
1801  CONTINUE
1802  CONTINUE
1803  CONTINUE
1804  CONTINUE
1805  CONTINUE
1400  CONTINUE
1401  CONTINUE
1405  CONTINUE
1501  CONTINUE
1502  CONTINUE
1503  CONTINUE
1505  CONTINUE
1601  CONTINUE
1603  CONTINUE
1605  CONTINUE
1705  CONTINUE
1101  CONTINUE
1902  CONTINUE
        CALL ZZCI (LINE,FLIN,SC)
        FLIN = FLIN + 1
        SC = CODTAB(SC+1)
1901  CONTINUE
        I = STATE + SC
C       SPEC EOFL EOLN BLAN DIGT LETR QUOT EOST
        GOTO
     = (1100,1200,1300,1400,1500,1600,1700,1800 ! WHEN CALLED
     = ,1101,1201,1301,1401,1501,1601,1701,1801 ! AFTER 1ST QUOTE
     = ,1102,1202,1302,1402,1502,1602,1702,1802 ! IN NUMBER
     = ,1103,1203,1303,1403,1503,1603,1703,1803 ! IN IDENTIFIER
     = ,1104,1204,1304,1404,1504,1604,1704,1804 ! AFTER 2ND QUOTE
     = ,1105,1205,1305,1405,1505,1605,1705,1805 ! IN COMMENT
     = ),I
1200  CONTINUE
        ! EOF
                IF (FLIN .GT. LIMARR) GOTO 12001
                  SYMBOL = EOFILE
                  ENTITY = SYMBOL
                GOTO 12002
12001           CONTINUE
                  FLIN = LIMARL
                  CALL CODGET ! (SC)
                  SYMBOL = EOSTMT
                  ENTITY = EOSTMT
12002           CONTINUE
                GOTO 1903
1201  CONTINUE
        ! ERS
                  CALL ASSERT(30,LINENO,FLIN)
                  SYMBOL = STRIN
                  GOTO 1904
1402  CONTINUE
1202  CONTINUE
1602  CONTINUE
1702  CONTINUE
1102  CONTINUE
        ! NUM
                  SYMBOL = NUMBER
                  GOTO 1904
1403  CONTINUE
1203  CONTINUE
1703  CONTINUE
1103  CONTINUE
        ! IDE
                  SYMBOL = IDENT
                  GOTO 1904
1404  CONTINUE
1504  CONTINUE
1204  CONTINUE
1604  CONTINUE
1104  CONTINUE
        ! STR
                  SYMBOL = STRIN
                  GOTO 1904
1205  CONTINUE
        ! ERC
                  CALL ASSERT(29,LINENO,FLIN)
                IF (FLIN .GT. LIMARR) GOTO 12051
                  SYMBOL = EOFILE
                  ENTITY = SYMBOL
                GOTO 12052
12051           CONTINUE
                  FLIN = LIMARL
                  CALL CODGET ! (SC)
                  SYMBOL = EOSTMT
                  ENTITY = EOSTMT
12052           CONTINUE
                  GOTO 1903
1300  CONTINUE
1304  CONTINUE
1305  CONTINUE
        ! LIN
                  CALL LINEXT
                  GOTO 1902
1301  CONTINUE
1302  CONTINUE
1303  CONTINUE
        ! SWA
                  CALL HAPSE(LINE,START,FLIN - 2)
                  CALL LINEXT
                  START = FLIN
                  GOTO 1902
1500  CONTINUE
        ! FM1
                  START = FLIN - 1
                  STATE = SNUMB
                  GOTO 1902!
1600  CONTINUE
        ! FM1
                  START = FLIN - 1
                  STATE = SIDEN
                  GOTO 1902!
1700  CONTINUE
        ! F0
                  START = FLIN
                  STATE = SA1QU
                  GOTO 1902!
1701  CONTINUE
        ! APS
                  CALL HAPSE(LINE,START,FLIN - 2)
                  START = FLIN ! IGNORE 2ND QUOTE
                  STATE = SA2QU
                  GOTO 1902!
1704  CONTINUE
                  STATE = SA1QU
                  GOTO 1902!
1100  CONTINUE
        ! SPE
                  CALL SPEMAP(ENTITY)
                  CALL CODGET ! (SC)
                  IF (ENTITY .NE. SCOBEG) GOTO 1
                    STATE = SCOMT
                    GOTO 1901!
1                 CONTINUE
                  SYMBOL = ENTITY
                  GOTO 1903
1105  CONTINUE
        ! SPE
                  CALL SPEMAP(ENTITY)
                  CALL CODGET ! (SC)
                  IF (ENTITY .NE. SCOEND) GOTO 2
                    STATE = SINIT
2                 CONTINUE
                  GOTO 1901
C
1904  CONTINUE
        CALL HAPSE(LINE,START,FLIN - 2)
        CALL HAMAP(ENTITY)
1903  CONTINUE
        IF(PARASK('SCAN',1,4,0) .EQ. 0) GOTO 2000
          CALL ZZWC('SCAN:',1,5,0)
          CALL ZZWI(SYMBOL,5)
          CALL PUTSYM(ENTITY)
2000    CONTINUE
        RETURN ! SCAN
      END
&END
&(SCANS   )
      SUBROUTINE SCANS (ANCH)
C     SCAN A SEQUENCE
C     GF 16.07.80
C     GF 20.07.80: 'PROHIB' -> 'TRAHIB' FOR NEW ENTITIES
C
C     DUMMY VERSION FOR THE READING OF GRAMMARS
C     CALLS 'SCAN' ONLY ONCE PER CALL
C
      %INCLUDE (PARS)
      %INCLUDE (PROS)
      %INCLUDE (STAS)
      %INCLUDE (STAT1)
      %INCLUDE (SYMS)
      %INCLUDE (TRAS)
      INTEGER I
     = ,ACT     ! -> A NEW 'TRA'-ELEMENT
     = ,ANCH    ! ANCHOR FOR THE INPUT-STRING (RING)
     = ,ENTITY  ! RESULT OF 'SCAN'
     = ,SYMBOL  ! RESULT OF 'SCAN'
     = ,TEMP    ! FOR EXCHANGING IN *TRAPEN
      %INCLUDE (ENDS)
C
      CALL SCAN (  SYMBOL,ENTITY)
      IF (SYMBOL .GT. TSTRI) GOTO 1
C       HERE IT IS AN IDENTIFIER, NUMBER, STRING OR 'EOF'
        IF (SYMBOL .NE. TIDEN .OR. ENTITY .GT. GRAMAX
     =  ) GOTO 3
C         GRAMMAR-KEYWORD
          SYMBOL = TKEYW
3       CONTINUE
      GOTO 2
1     CONTINUE
        ENTITY = SYMBOL
        SYMBOL = TKEYW
2     CONTINUE
      CALL TRAPIM (ANCH,SYMBOL,ENTITY)
      ANCH = TRA(ANCH) ! -> 'TGOTO' AGAIN
      RETURN ! SCANS
      END
&END
&(SEMANT  )
      SUBROUTINE SEMANT (SEMNUM,ROOT,ANCH,TRAIN)
C     PERFORM A SPECIAL SEMANTIC ACTION
C     GF 14.07.80
C     GF 20.07.80: WITH #7, WITHOUT NEGATE IN #12
C     GF 07.08.80: USER'S ACTIONS NOW BY 'SEPANT'
C     GF 09.11.80: WITH #34
C
C-----------------------------------------------------------------
C     THIS VERSION OF 'SEMANT' HANDLES ACTIONS #1 - #33
C     I.E. THE ACTIONS FOR THE META-GRAMMAR
C
C     THE POSSIBLE SEQUENCES OF ACTIONS FOR A PRODUCTION
C     ARE DESCRIBED BY THE FOLLOWING REGULAR EXPRESSIONS:
C
C     .SEMCLO = ( UNCH
C               | ( ELEM* SYIN SYMB
C                 | ELEM* ATIN SON   ATTR SYMB
C                 | ELEM* REIN POS
C                 )
C               )
C               ( ELEM* ( ACMA SYMB ACCU INC
C                       | ATMA SON  ATTR SYMB )
C               )*
C               ELEM* EOS
C     .ELEM   = ( SOCO | SOTA ) SON
C             | ( ACCO | ACTA ) SYMB ACCU INC
C             |   ATCO          SON  ATTR SYMB
C             |   SYCO          SYMB
C             |   SEPR          NUM
C             | ( SYMA | SYAT SON ATTR SYMB ) ELEM*  EOSY
C
C$  /*------------------------------------------------------*/
C$  /* META-GRAMMAR FOR PARSING OF TRANSFORMATION GRAMMARS  */
C$  /* GEORG FISCHER JULY 20, 1980                          */
C$  /*------------------------------------------------------*/
C$ EOF IDENTIFIER NUMBER STRING
C$ [AXIOM = EXTRA_INPUT
C$ .EXTRA_INPUT    = '[' GRAMMAR ']' SOURCE_TEXT   => #1
C$                 | EXTRA_INPUT
C$                   '[' GRAMMAR ']' SOURCE_TEXT   => #1
C$ .GRAMMAR        = RULES                         => #2
C$ .RULES          = RULE
C$                 | RULES '..' RULE
C$ .RULE           = LEFT_SIDE '=' RIGHT_SIDES
C$ .LEFT_SIDE      = IDENTIFIER                    => #3
C$ .RIGHT_SIDES    = RIGHT_SIDE
C$                 | RIGHT_SIDES '|' RIGHT_SIDE
C$ .RIGHT_SIDE     = SYNTAX_PART SEMANTIC_PART
C$ .SYNTAX_PART    = MEMBERETIES                   => #6
C$ .SOURCE_TEXT    =
C$ .MEMBERETIES    =                               => #7
C$                 | MEMBERETIES MEMBER
C$ .MEMBER         = PRIMARY
C$ .PRIMARY        = IDENTIFIER                    => #8
C$                 | STRING                        => #9
C$                 | NUMBER                        => #8
C$ .SEMANTIC_PART  = TRANSFORMATIONS               => #11
C$ .TRANSFORMATIONS=                               => #12
C$                 | '=>' TRANSFORMATION           => #13
C$                 | TRANSFORMATIONS '->' TRANSFORMATION
C$                                                 => #14
C$ .TRANSFORMATION = DESTINATION
C$                 | TRANSFORMATION ELEMENT        => #16
C$ .DESTINATION    = '='                           => #17
C$                 | ELEMENT                       => #18
C$                 | SYMBOL '='                    => #19
C$ .ELEMENT        = SYMBOL                        => #20
C$                 | '#' NUMBER                    => #21
C$                 | NUMBER                        => #22
C$                 | STRING                        => #23
C$                 | '@'                           => #24
C$                 | SYMBOL '(' COMBINED_LIST ')'  => #25
C$ .SYMBOL         = INCARNATION
C$                 | INCARNATION '$' IDENTIFIER    => #27
C$ .INCARNATION    = IDENTIFIER                    => #28
C$                 | IDENTIFIER ':' NUMBER         => #29
C$ .COMBINED_LIST  =                               => #30
C$                 | COMBINED_LIST SYMBOL
C$                 | COMBINED_LIST NUMBER          => #32
C$                 | COMBINED_LIST STRING          => #33
C$                 | COMBINED_LIST '#' NUMBER      => #34
C$ .
C$ ]
C-----------------------------------------------------------
      %INCLUDE (PARS)
      %INCLUDE (MEMS)
      %INCLUDE (PROS)
      %INCLUDE (SEMS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      %INCLUDE (STAT1)
      %INCLUDE (TRAS)
      INTEGER PARASK
      INTEGER I
     = ,ANCH    ! -> 'TRA'-RING COLLECTED SO FAR
     = ,INC     ! INCARNATION OF A SON OR ACCU
     = ,FIRST   ! FOR MOVING DOWNWARDS IN #19
     = ,ROOT    ! -> 1ST MEMBER OF THE META-PRODUCTION IN 'TRA'
     = ,SEMNUM  ! NUMBER OF THE SPECIAL SEMANTIC ACTION TO BE PERFORMED
     = ,SON     ! RESULT OF 'SEMLUP' IN #29
     = ,SYMB    ! A TEMPORARY SYMBOL
     = ,TRAIN   ! -> RING FOR THE INPUT NOT YET CONSUMED
      %INCLUDE (ENDS)
C
      GOTO  (1001,1002,1003,1004,1005,1006,1007,1008,1009
     = ,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019
     = ,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029
     = ,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039
     = ), SEMNUM
      GOTO 99 !--------------------------------------------------
1001  CONTINUE!  .EXTRA_INPUT = '[' GRAMMAR ']' SOURCE_TEXT
C                | EXTRA_INPUT  '[' GRAMMAR ']' SOURCE_TEXT
C
                 INGRAM = 1
      GOTO 99 !--------------------------------------------------
1002  CONTINUE!  .GRAMMAR = RULES
C
                 IF (PARASK('SEPAR',1,5,1) .EQ. 0) GOTO 10021
C                  GENERATE TWO TABLES, FORCE 'EOF'
                   I = TRAIN
                   CALL TRAPIM (TRAIN,EOFILE,0)
                   TRAIN = I ! PREFIX INPUT WITH 'EOFILE'
                 GOTO 10022
10021            CONTINUE
C                  CALL REORG
10022            CONTINUE
C                IF (PARASK('PARADD',1,6,1) .NE. 0) CALL PARADD
                 INGRAM = 0
      GOTO 99 !--------------------------------------------------
1003  CONTINUE!  .LEFT_SIDE = IDENTIFIER
C
                 BUPROD = 0 ! FOR TRACE AFTER '99'
                 CALL SEMGET (ROOT,1,BULEFT)
      GOTO 99 !--------------------------------------------------
1006  CONTINUE!  SYNTAX_PART = MEMBERETIES
C
                 CALL PROCHA (1,BULEFT,BUMON,FMEM-BUMON,  BUPROD)
C                        ADDSUB,        ,LNG     ,  =:
                 PROSEM(BUPROD) = FSEM
                 IF (PARASK('SINGLE',1,6,0) .EQ. 0) GOTO 51
                   CALL REORG
51               CONTINUE
                 REIPOS = 0
                 MEMPOS = 0
      GOTO 99 !--------------------------------------------------
1007  CONTINUE!  .MEMBERETIES =
C
                 BUMON = FMEM
      GOTO 99 !--------------------------------------------------
1008  CONTINUE!  .PRIMARY = IDENTIFIER
              !           | NUMBER
C
                 CALL SEMGET (ROOT,1,SYMB)
110   CONTINUE!MEMSTO:
                 IF (FMEM .GE. MEMHIB) GOTO 52
                   MEM(FMEM) = SYMB
                   FMEM = FMEM + 1
                 GOTO 53
52               CONTINUE
                   CALL ASSERT (175,FMEM,-SYMB) ! INCREASE MEMHIB (=@)
53               CONTINUE
      GOTO 99 !--------------------------------------------------
1009  CONTINUE!  .PRIMARY = STRING
C
                 CALL SEMGET (ROOT,1,I)
                 CALL SPEINS(STRNG,SYMPOS(I),SYMEND(I),  SYMB)
                 GOTO 110 ! MEMSTO
C     GOTO 99 !--------------------------------------------------
1011  CONTINUE!  .SEMANTIC_PART = TRANSFORMATIONS
C
                 CALL SEMCLO(BUPROD)
      GOTO 99 !--------------------------------------------------
1012  CONTINUE!  .TRANSFORMATIONS =
C
                 CALL SEMWRI (0,UNCH,0)
      GOTO 99 !---------------------------------------------------
1013  CONTINUE!  | '=>' TRANSFORMATION
C
                 SEM(DESL) = SEM(DESL) + SYIN - SYCO
                 IF (SEM(DESL) .NE. SYIN .OR. SEMSYM(DESL)
     =             .NE. PROLEF(BUPROD) .OR. REIPOS .LE. 0)
     =           GOTO 3
                   CALL SEMWRI (0,REIN,REIPOS)
                   GOTO 4
3                CONTINUE
                   IF (REIPOS .LE. 0) GOTO 5
                     CALL ASSERT(95,REIPOS,0)
C                      RE-INPUT NOT ALLOWED HERE, POSITION @
5                  CONTINUE
                   DO 6 I = DESL,DESU
                     CALL SEMWRI (0,SEM(I),SEMSYM(I))
6                  CONTINUE
4                CONTINUE
      GOTO 99 !----------------------------------------------------
1014  CONTINUE!  | TRANSFORMATIONS '->' TRANSFORMATION
C
                 SEM(DESL) = SEM(DESL) + SYMA - SYCO
                   IF (REIPOS .LE. 0) GOTO 7
                     CALL ASSERT(96,REIPOS,0)
C                      RE-INPUT NOT ALLOWED HERE, POSITION @
7                  CONTINUE
                   DO 8 I = DESL,DESU
                     CALL SEMWRI (0,SEM(I),SEMSYM(I))
8                  CONTINUE
      GOTO 99 !----------------------------------------------------
1015  CONTINUE!  .TRANSFORMATION = DESTINATION
C
      GOTO 99 !---------------------------------------------------
1016  CONTINUE!  | TRANSFORMATION ELEMENT
C
                 MEMPOS = MEMPOS + 1
      GOTO 99 !---------------------------------------------------
1017  CONTINUE!  .DESTINATION = '='
C
                 DESU = DESL + 1
                 CALL SEMWRI (DESL,ACCO,0) ! DELETE-ANCHOR
                 CALL SEMWRI (DESU,ACCU,0)
                 REIPOS = -1 ! DISALLOW '@'
                 MEMPOS = 0
      GOTO 99 !---------------------------------------------------
1018  CONTINUE!  | ELEMENT
C
                 DESU = DESL
                 CALL SEMWRI (DESL,SYCO,PROLEF(BUPROD))
                 MEMPOS = 1 ! 1ST MEMBER IS ALREADY PROCESSED
      GOTO 99 !-----------------------------------------------------
1019  CONTINUE!  | SYMBOL '='
C
                 DESU = DESL - 1
                 FIRST = FSEM - 1
                 IF (SEM(FIRST) .NE. ACCU .AND.
     =             SEM(FIRST) .NE. ATTR)
     =           GOTO 9
                   FIRST = FIRST - 1
9                CONTINUE
                 I = FIRST
10               IF (I .GT. FSEM - 1) GOTO 11 ! MOVE TO SEMS(DESL:DESU)
                   DESU = DESU + 1
                   CALL SEMWRI (DESU,SEM(I),SEMSYM(I))
                   I = I + 1
                 GOTO 10
11               CONTINUE
                 FSEM = FIRST
                 REIPOS = -1 ! DISALLOW '@'
                 MEMPOS = 0
      GOTO 99 !--------------------------------------------------
1020  CONTINUE!  .ELEMENT = SYMBOL
      GOTO 99 !--------------------------------------------------
1021  CONTINUE!  | '#' NUMBER
C
                 CALL SEMGET (ROOT,-2,SYMB)
                 CALL SEMWRI (0,SEPR,SYMB)
      GOTO 99 !---------------------------------------------------
1022  CONTINUE!  | NUMBER
C
                 INC = - 1
                 CALL SEMGET (ROOT,1,SYMB)
                 GOTO 100 ! LOOKUP
C     GOTO 99 !---------------------------------------------------
1023  CONTINUE!  | STRING
C
                 INC = - 1
                 CALL SEMGET (ROOT,1,SYMB)
101   CONTINUE!STRISE:
                 FSYM = SYMHIB + FSYM ! DISABLE INSERTION IN 'SPEINS'
                 CALL SPEINS (STRNG,SYMPOS(SYMB),SYMEND(SYMB),I)
                 IF (I .EQ. 0) GOTO 12 ! ALREADY IN THE GRAMMAR
                   SYMB = I
12               CONTINUE
                 GOTO 100
C     GOTO 99 !-------------------------------------------------
1024  CONTINUE!  | '@'
C
                 IF (REIPOS .EQ. 0) GOTO 13
                   CALL ASSERT (93,MEMPOS,0)
C                    BACKSPACING NOT ALLOWED HERE, POSITION @
                 GOTO 14
13               CONTINUE
                   REIPOS = MEMPOS + 1
                   FSEM = PROSEM(BUPROD) ! ALL BEFORE '@' REMAIN UNCHANG
14               CONTINUE
      GOTO 99 !-------------------------------------------------
1025  CONTINUE!  | SYMBOL '(' COMBINED_LIST ')'
C
                 CALL SEMWRI (0,EOSY,0)
      GOTO 99 !-------------------------------------------------
1026  CONTINUE!  .SYMBOL = INCARNATION
      GOTO 99 !-------------------------------------------------
1027  CONTINUE!  | INCARNATION '$' IDENTIFIER
C
                 CALL SEMGET (ROOT,3,SYMB)
                 IF (SEM(FSEM-1) .NE. ACCU) GOTO 15
                   CALL ASSERT (94, - SYMB,0)
C                    ATTRIBUTE @ NOT ALLOWED HERE
                 GOTO 16
15               CONTINUE
                   SEM(FSEM-1) = ATCO
                   CALL SEMWRI (0,ATTR,SYMB)
16               CONTINUE
      GOTO 99 !--------------------------------------------------
1028  CONTINUE!  .INCARNATION = IDENTIFIER
C
                 INC = 0
                 CALL SEMGET (ROOT,1,SYMB)
                 GOTO 100 ! LOOKUP
C     GOTO 99 !-------------------------------------------------
1029  CONTINUE!  | IDENTIFIER ':' NUMBER
C
                 CALL SEMGET (ROOT,1,SYMB)
                 CALL SEMGET (ROOT,-3,INC)
C
100   CONTINUE ! LOOKUP:
                 CALL SEMLUP (BUPROD,SYMB,INC,  SON)
      GOTO 99 !--------------------------------------------------
1030  CONTINUE!  .COMBINED_LIST =
C
C                THE LAST ACTION WAS FOR (THE COMBINDE) 'SYMBOL'
                 IF (SEM(FSEM-1) .NE. SOCO) GOTO 17
C                  REVERT THE EFFECT OF 'SEMLUP', STORE
C                  THE SYMBOL INSTEAD OF THE SON-NUMBER
                   I = PROMON(BUPROD) + SEMSYM(FSEM-1) - 1
                   CALL SEMWRI(FSEM-1,SYMA,MEM(I))
                 GOTO 18
17               CONTINUE
                 IF (SEM(FSEM-1) .NE. ATTR) GOTO 19
                   SEM(FSEM-2) = SYAT
                 GOTO 18
19               IF (SEM(FSEM-1) .NE. SYCO) GOTO 20
                   SEM(FSEM-1) = SYMA
                 GOTO 18
20               CONTINUE ! ELSE = ACCU
                   FSEM = FSEM - 1
                   IF (SEMSYM(FSEM) .EQ. 0) GOTO 21 ! INC > 0
                     CALL ASSERT (92, - SEMSYM(FSEM-1),SEMSYM(FSEM))
C                      COMBINED SYMBOL @ MUST NOT BE AN ACCU WITH INCARN
21                 CONTINUE
                   SEM(FSEM-1) = SYMA
18               CONTINUE
      GOTO 99 !-------------------------------------------------
1031  CONTINUE!  | COMBINED_LIST SYMBOL
C
      GOTO 99 !-------------------------------------------------
1032  CONTINUE!  ! COMBINED_LIST NUMBER
C
                 INC = -1
                 CALL SEMGET (ROOT,2,SYMB)
                 GOTO 100 ! LOOKUP
C     GOTO 99 !-------------------------------------------------
1033  CONTINUE!  | STRING
C
                 INC = -1
                 CALL SEMGET (ROOT,2,SYMB)
                 GOTO 101 ! STRISE
C     GOTO 99 !-------------------------------------------------
1004  CONTINUE!
1005  CONTINUE!
1010  CONTINUE!
C
      GOTO 99 !------------------------------------------------------
1034  CONTINUE!  | COMBINED_LIST '#' NUMBER   (CF. #21)
C
                 CALL SEMGET (ROOT,-3,SYMB)
                 CALL SEMWRI (0,SEPR,SYMB)
      GOTO 99 !------------------------------------------------------
1035  CONTINUE!
1036  CONTINUE!
1037  CONTINUE!
1038  CONTINUE!
1039  CONTINUE!
      GOTO 99
C     ABOVE ACTIONS ARE ALL UNDEFINED SO FAR
C
99    CONTINUE ! ESAC
      IF(PARASK('SEMANT',1,6,0) .EQ. 0 .OR. BUPROD .EQ. 0) GOTO 22
        CALL OUTPRO(BUPROD)
22    CONTINUE
      RETURN
      END
&END
&(SEMARI  )
      SUBROUTINE SEMARI (A2,OP)
C     PERFORM AN ARITHMETIC OPERATION ON 2 'TRA'-ELEMENTS
C     GF 21.07.80
C     GF 08.11.80: WITH #47 - FORCE A VALUE
C     GF 28.12.80: THE OPERANDS MAY BE NON-NUMERIC
C
C     'SEMARI' DOES 'OP' AS POSTFIX-OPERATOR ON THE ELEMENT
C     'A1' BEFORE 'A2' AND 'A2', THE RESULT IS STORED IN 'A1',
C     AND 'A2' IS DELETED.
C
C     THE OPERANDS SHOULD BE NUMBER ENTITIES, OR 'TRAENT' MAY
C     CONTAIN THE VALUE DIRECTLY (IF 'TRAENT < 0'). THE
C     RESULT IS ALWAYS STORED IN THE LATTER WAY.
C
C     SINCE "NEGATIVE" MEANS "IMMEDIATE", ONLY NATURAL NUMBERS
C     MAY BE HANDLED, AND FOR 'OP = 2' THE RESULT IS ALSO ASSUMED
C     TO BE NONNEGATIVE !!
C
C     IF THE OPERANDS ARE NON-NUMERICAL, THE OPERATION-SYMBOL ('+','-',
C     '*' OR '/') IS INSERTED BETWEEN THE TWO OPERANDS, AND 'A2' IS
C     LEFT UNCHANGED.
C
      %INCLUDE (PARS)
      %INCLUDE (SYMS)
      %INCLUDE (TRAS)
      INTEGER I
     = ,A1      ! -> 1ST OPERAND (= RESULT)
     = ,A2      ! -> 2ND OPERAND (IS FREED)
     = ,ACT     ! -> ELEMENT TO BE DELETED
     = ,N1      ! NUMERICAL VALUE OF 'A1'
     = ,N2      ! ... OF 'A2'
     = ,OP      ! = 1: ADD, 2: SUB, 3: MUL, 4: DIV
     = ,OPSYM   ! OPERATION-SYMBOL
     = ,POSSIB  ! = 1 (0) IF NUMERICAL EVALUATION (NOT) POSSIBLE
     = ,TEMP    ! A TEMPORARY FOR EXCHANGING
C
      POSSIB = 1 ! ASSUME: POSSIBLE
      A1 = TRA(A2)
1     IF (TRA(A1) .EQ. A2) GOTO 2
        A1 = TRA(A1)
      GOTO 1
2     CONTINUE
      IF (A1 .NE. A2) GOTO 3
        CALL ASSERT (135,OP,0)
C         ONLY ONE OPERAND FOR OPERATION @
        N1 = 0
        GOTO 100 ! SECOND
3     CONTINUE
      IF (TRASYM(A1) .NE. -TNUMB) GOTO 61
        POSSIB = 0
C       CALL ASSERT(136,-TRAENT(A1),0)
C         ARITHMETIC ON @ NOT POSSIBLE
      GOTO 62
61    CONTINUE
        N1 = TRAENT(A1)
        IF (N1 .GT. 0) GOTO 63
          N1 = - N1
        GOTO 64
63      CONTINUE
          CALL SYMNUM(N1,N1)
64      CONTINUE
62    CONTINUE
C
100   CONTINUE ! SECOND:
      IF (TRASYM(A2) .NE. -TNUMB) GOTO 71
        POSSIBLE = 0
C       CALL ASSERT(137,-TRAENT(A2),TRASYM(A2))
C         ARITHMETIC ON @ NOT POSSIBLE
      GOTO 72
71    CONTINUE
        N2 = TRAENT(A2)
        IF (N2 .GT. 0) GOTO 73
          N2 = - N2
        GOTO 74
73      CONTINUE
          CALL SYMNUM(N2,N2)
74      CONTINUE
72    CONTINUE
C
      IF (POSSIB .EQ. 1) GOTO 79
        GOTO (91,92,93,94,90,90,90),OP
79    CONTINUE
      GOTO (81,82,83,84,80,80,87),OP
C            +  -  *  /        =
80    CONTINUE
        CALL ASSERT (63,OP,0)
C         INVALID OPERATION @
          RETURN
81    CONTINUE
        N1 = N1 + N2
          GOTO 89
82    CONTINUE
        N1 = N1 - N2
          GOTO 89
83    CONTINUE
        N1 = N1 * N2
          GOTO 89
84    CONTINUE
        N1 = N1 / N2
          GOTO 89
87    CONTINUE
        IF (N1 .EQ. N2) GOTO 89
          CALL ASSERT (64,N1,N2)
C           '*@' NOT ALLOWED HERE, REPLACED BY '*@'
          N1 = N2
          GOTO 89
89    CONTINUE
C
      TRA(A1) = TRA(A2) ! -> 1ST
      TRASYM(A1) = TNUMB
      TRAENT(A1) = - N1
      TRA(A2) = A2
      CALL TRAPEN (FTRA,A2)
      A2 = A1
      RETURN
C
90    CONTINUE
        CALL ASSERT (63,OP,0)
C         INVALID OPERATION @
          RETURN
91    CONTINUE
        OPSYM = PLUS
          GOTO 99
92    CONTINUE
        OPSYM = MINUS
          GOTO 99
93    CONTINUE
        OPSYM = TIMES
          GOTO 99
94    CONTINUE
        OPSYM = DIVIDE
          GOTO 99
99    CONTINUE
      TRA(A1) = TRA(A2) ! LET 'A1' -> A RING
      CALL TRAPIM (A1,TKEYW,OPSYM)
      TRA(A1) = A2
      RETURN
      END
&END
&(SEMCLO  )
      SUBROUTINE SEMCLO (PROD)
C     CLOSE THE SEMANTIC ACTIONS FOR A PRODUCTION
C     GF 14.07.80
C     GF 08.08.80: ACCU-LOGIC WITH INCREMENT/DECREMENT
C
C     'SEMCLO' DOES THE FOLLOWING MAIN STEPS:
C
C     -- DELETE UNUSED MEMBERS (SONS) OF THE RIGHT SIDE
C          (A SON WAS USED IFF 'MEMNUC < 0')
C     -- CHANGE THE LAST 'SOCO' TO 'SOTA', AND SET ALL BUT
C          THE LAST NEGATIVE
C     -- INCREMENT ALL INCARNATIONS OF AN ACCU AFTER
C          AN 'ACMA' WITH 'INC = 0'
C     -- CHANGE THE LAST 'ACCO' TO 'ACTA', AND SET ALL BUT
C          THE LAST NEGATIVE (FOR A SPECIFIC ACCU)
C     -- MAKE ALL CODES POSITVE AGAIN
C
      %INCLUDE (PARS)
      %INCLUDE (MEMS)
      %INCLUDE (PROS)
      %INCLUDE (SEMS)
      INTEGER PARASK
      INTEGER I,J
     = ,INC    ! AN INCARNATION OF AN ACCU
     = ,PROD   ! CLOSE ACTIONS FOR THIS PRODUCTION
     = ,SYMB   ! A TEMPORARY SYMBOL
C-----------------------------------------------------------
C     -- CHANGE THE LAST 'SOCO' TO 'SOTA', AND SET ALL BUT
C          THE LAST NEGATIVE
C
      I = PROSEM(PROD)
      IF (SEM(I) .NE. UNCH) GOTO 26
C       IS 'UNCH'
        J = I + 1
        FSEM = FSEM - 1
        DO 28 I = J,FSEM
          SEM(I - 1) = SEM(I) ! MOVE 1 DOWNWARDS
          SEMSYM(I-1) = SEMSYM(I)
28      CONTINUE
        CALL SEMWRI (0,EOS,1) ! EOS,1 = UNCH
      GOTO 27
26    CONTINUE
        CALL SEMWRI (0,EOS,0) ! EOS,0 = DELETE REST OF THE TREE
      IF (PARASK('SEMCLO',1,6,1) .NE. 0) GOTO 27
      I = FSEM - 1
5     IF(I .LT. PROSEM(PROD)) GOTO 6
        IF (SEM(I) .NE. SOCO) GOTO 7
          SEM(I) = SOTA
          SYMB = SEMSYM(I)
          J = I - 1
8         IF(J .LT. PROSEM(PROD)) GOTO 9
            IF (SEM(J) .NE. SOCO .OR. SEMSYM(J) .NE. SYMB) GOTO 19
              SEM(J) = - SOCO
19          CONTINUE
            J = J - 1
          GOTO 8
9         CONTINUE ! DO J
7       CONTINUE ! = SOCO
        I = I - 1
      GOTO 5
6     CONTINUE ! DO I
27    CONTINUE
C-----------------------------------------------------------
C     -- CHANGE THE LAST 'ACCO' TO 'ACTA', AND SET ALL BUT
C          THE LAST NEGATIVE (FOR A SPECIFIC ACCU)
C
      I = FSEM - 1
20    IF(I .LT. PROSEM(PROD)) GOTO 21
        IF (SEM(I) .NE. ACCO) GOTO 22
          SEM(I) = ACTA
          SYMB = SEMSYM(I)
          INC =  SEMSYM(I+1)
          J = I - 1
23        IF(J .LT. PROSEM(PROD)) GOTO 24
            IF (SEM(J) .NE. ACCO .OR. SEMSYM(J) .NE. SYMB
     =        .OR. SEMSYM(J+1) .NE. INC)
     =      GOTO 25
              SEM(J) = - ACCO
25          CONTINUE
            J = J - 1
          GOTO 23
24        CONTINUE ! DO J
22      CONTINUE ! = ACCO
        I = I - 1
      GOTO 20
21    CONTINUE ! DO I
C-----------------------------------------------------------
C     -- INCREMENT ALL INCARNATIONS OF AN ACCU AFTER
C          AN 'ACMA' WITH 'INC = 0'
C
      I = PROSEM(PROD)
10    IF(I .GT. FSEM - 1) GOTO 11
        IF (SEM(I) .NE. ACMA) GOTO 12
          SYMB = SEMSYM(I)
          IF (SEMSYM(I+1) .NE. 0) GOTO 13
C           TO BE PUSHED
            J = I + 2
14          IF(J .GT. FSEM - 1) GOTO 15
              IF (SEM(J) .NE. ACCU .OR. SEMSYM(J-1) .NE. SYMB) GOTO 16
                IF (SEMSYM(J) .EQ. 0) SEMSYM(J) = 1
                SEMSYM(J) = SEMSYM(J) + 1 ! INCREMENT 'INC'
16            CONTINUE
              J = J + 1
            GOTO 14
15          CONTINUE ! DO J
13        CONTINUE ! INC = 0
12      CONTINUE ! = ACMA
        I = I + 1
      GOTO 10
11    CONTINUE ! DO I
C-----------------------------------------------------------
C     -- DECREMENT ALL INCARNATIONS OF AN ACCU AFTER
C          AN 'ACTA' WITH 'INC' >=
C
      I = PROSEM(PROD)
40    IF(I .GT. FSEM - 1) GOTO 41
        IF (SEM(I) .NE. ACTA) GOTO 42
          SYMB = SEMSYM(I)
          INC = SEMSYM(I+1)
          IF (INC .EQ. 0) INC = 1
          J = I + 2
44        IF(J .GT. FSEM - 1) GOTO 45
              IF (SEM(J) .NE. ACCU .OR. SEMSYM(J-1) .NE. SYMB) GOTO 46
                IF (SEMSYM(J) .GE. INC)
     =            SEMSYM(J) = SEMSYM(J) - 1 ! DECREMENT 'INC'
46            CONTINUE
              J = J + 1
          GOTO 44
45        CONTINUE ! DO J
42      CONTINUE ! = ACMA
        I = I + 1
      GOTO 40
41    CONTINUE ! DO I
C-----------------------------------------------------------
C     -- MAKE ALL CODES POSITVE AGAIN
C
      I = PROSEM(PROD)
30    IF(I .GT. FSEM - 1) GOTO 31
        IF (SEM(I) .LT. 0) SEM(I) = - SEM(I)
        I = I + 1
      GOTO 30
31    CONTINUE
C
      IF (PARASK('SEMCLO',1,6,0) .EQ. 0) GOTO 32
        CALL OUTPRO (PROD)
32    CONTINUE
      RETURN ! SEMCLO
      END
&END
&(SEMGET  )
      SUBROUTINE SEMGET (ROOT,POS,  SYMB)
C     GET A MEMBER OF THE PARSED PRODUCTION
C     GF 16.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (STKS)
      %INCLUDE (SYMS)
      %INCLUDE (TRAS)
      INTEGER I
     = ,ROOT    ! -> 1ST MEMBER OF THE PARSED PRODUCTION
     = ,POS     ! NUMBER OF THE DESIRED MEMBER, 1,2,...
     = ,SYMB    ! RESULTING ENTITY
C
C     POS = +-1, +-2, ...
C     IF 'POS < 0', THE MEMBER IS ALREADY CONVERTED TO AN INTEGER
C
      I = ROOT + ABS(POS) - 1
      I = STKTRA(I)
      IF (TRASYM(I) .LT. TIDEN .OR. TRASYM(I) .GT. TSTRI) GOTO 1
C       HERE IT IS AN ENTITY (IDENTIFIER, NUMBER OR STRING)
        SYMB = TRAENT(I)
      GOTO 2
1     CONTINUE
        CALL ASSERT (97,POS,0)
        SYMB = ERRSYM
2     CONTINUE
      IF (ABS(POS) .EQ. POS) GOTO 3
        CALL SYMNUM (SYMB,SYMB) ! CONVERT DIGIT-SEQUENCE TO INTEGER
3     CONTINUE
      RETURN ! SEMGET
      END
&END
&(SEMLUP  )
        SUBROUTINE SEMLUP (PROD,SYMB,INC,  SON)
C       LOOK-UP A MEMBER IN THE RIGTH SIDE OF 'PROD'
C
        %INCLUDE (PARS)
        %INCLUDE (MEMS)
        %INCLUDE (PROS)
        %INCLUDE (SEMS)
        INTEGER I
     = ,INC     ! DESIRED OCCURRENCE OF 'SYMB'
     = ,OCCUR   ! CURRENT ...
     = ,PROD    ! LOOK IN THIS PRODUCTION
     = ,SON     ! = 1...PROLNG IF FOUND, 0 OTHERWISE
     = ,SYMB    ! LOOK FOR THIS SYMBOL
C
      SON = 0
      OCCUR = 0
      I = PROMON(PROD)
1     IF(I .GT. PROMON(PROD) + PROLNG(PROD) - 1) GOTO 2
        IF (MEM(I) .NE. SYMB) GOTO 3
          OCCUR = OCCUR + 1
          IF (OCCUR .LT. INC) GOTO 4 ! WORKS ALSO FOR 'INC <= 0'
            SON = I - PROMON(PROD) + 1
C           MEMNUC(I) = - ABS(MEMNUC(I)) ! WAS USED
            CALL SEMWRI(0,SOCO,SON)
            RETURN
4         CONTINUE
3       CONTINUE
        I = I + 1
      GOTO 1
2     CONTINUE
C     NOT FOUND, MUST BE ACCU ('INC=0') OR NEW TERMINAL ('INC<0')
      IF (INC .LT. 0) GOTO 5
        CALL SEMWRI(0,ACCO,SYMB)
        CALL SEMWRI(0,ACCU,INC)
      GOTO 6
5     CONTINUE
        CALL SEMWRI(0,SYCO,SYMB)
6     CONTINUE
      RETURN ! SEMLUP
      END
&END
&(SEMS    )
C-------GF 28.08.80--------------------------------- S E M S
      INTEGER FSEM,SEMHIB,PNOSEM
     = ,ACCO,ACIN,ACMA,ACTA  ! ACCUMULATOR
     = ,ATCO,ATIN,ATMA,SYAT  ! ATTRIBUTE
     = ,SOCO,REIN,UNCH,SOTA  ! SON, MEMBER
     = ,SYCO,SYIN,SYMA,SEPR  ! NEW SYMBOL
     = ,ACCU,ATTR,EOSY,EOS   ! MISCELLANEOUS
        INTEGER SEMSYM(&SEMH)
      INTEGER SEM   (&SEMH)
      COMMON /SEMS/
     =  FSEM      ! 1ST FREE 'SEM'-ENTRY
     = ,SEMHIB  ! HIGH BOUND OF 'SEM'
     = ,PNOSEM  ! -> DUMMY ACTION: UNCH, EOS
     = ,ACCO,ACIN,ACMA,ACTA  ! ACCUMULATOR
     = ,ATCO,ATIN,ATMA,SYAT  ! ATTRIBUTE
     = ,SOCO,REIN,UNCH,SOTA  ! SON, MEMBER
     = ,SYCO,SYIN,SYMA,SEPR  ! NEW SYMBOL
     = ,ACCU,ATTR,EOSY,EOS   ! MISCELLANEOUS
      COMMON /PRESEM/
     =  SEM      ! CONTAINS THE CODES 'ACCO...EOS'
     = ,SEMSYM  ! ADDITIONAL INFORMATION, MOSTLY A SYMBOL
&END
&(SEMWRI  )
        SUBROUTINE SEMWRI (POS,CODE,SYMB)
C       WRITE A SINGLE ACTION TO 'SEM'
C       GF 11.07.80
C
        %INCLUDE (PARS)
        %INCLUDE (SEMS)
        INTEGER I
     = ,CODE    ! TO BE WRITTEN
     = ,POS     ! DESIRED PLACE (= 0 : FSEM, +=1)
     = ,SYMB    ! TO BE WRITTEN IN 'SEMSYM'
C
        I = POS
        IF (I .NE. 0) GOTO 1
          I = FSEM
          IF (FSEM .GE. SEMHIB) GOTO 2
            FSEM = FSEM + 1
          GOTO 3
2         CONTINUE
            CALL ASSERT(91,FSEM,0)
C             INCREASE 'SEMHIB'
3         CONTINUE
1       CONTINUE
        SEM   (I) = CODE
        SEMSYM(I) = SYMB
        RETURN ! SEMWRI
        END
&END
&(SEPANT  )
      SUBROUTINE SEPANT (SEMNUM,ROOT,ANCH,TRAIN)
C     PERFORM A SPECIAL SEMANTIC ACTION
C     GF 07.08.80: COPY OF 'SEMANT', FOR USER-ACTIONS
C     GF 08.11.80: #47, #51 TO #53
C
      %INCLUDE (PARS)
      %INCLUDE (LINS)
      %INCLUDE (STAT1)
      %INCLUDE (SYMS)
      %INCLUDE (TRAS)
      INTEGER PARASK
      INTEGER I
     = ,A1      ! -> ELEMENT BEFORE 'ANCH'
     = ,ANCH    ! -> 'TRA'-RING COLLECTED SO FAR
     = ,INC     ! INCARNATION OF A SON OR ACCU
     = ,FIRST   ! FOR MOVING DOWNWARDS IN #19
     = ,ROOT    ! -> 1ST MEMBER OF THE META-PRODUCTION IN 'TRA'
     = ,SEMNUM  ! NUMBER OF THE SPECIAL SEMANTIC ACTION TO BE PERFORMED
     = ,SON     ! RESULT OF 'SEMLUP' IN #29
     = ,SYMB    ! A TEMPORARY SYMBOL
     = ,TRAIN   ! -> RING FOR THE INPUT NOT YET CONSUMED
      %INCLUDE (ENDS)
C
      I = SEMNUM - 39
      IF (I .LT. 1) GOTO 1001
      GOTO
     = (1040,1041,1042,1043,1044,1045,1046,1047,1048,1049
     = ,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059
     = ,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069
     = ), I
      GOTO 99 !--------------------------------------------------
1001  CONTINUE
C
      CALL ASSERT (139,SEMNUM,0)
C       INVALID ACTION @
      GOTO 99
C-----------------------------------------------------------
C     GET SYSTEM-PARAMETERS
C
1040  CONTINUE!
C     CALL PARADD
      GOTO 99
C-----------------------------------------------------------
C      DO POSTFIX-POLISH ARITHMETIC ON THE RING 'ANCH'
C
C      #41 = '+', #42 = '-', #43 = '*', #44 = '/'
C
1041  CONTINUE!
1042  CONTINUE!
1043  CONTINUE!
1044  CONTINUE!
      CALL SEMARI (ANCH,SEMNUM-40)
      GOTO 99
C-----------------------------------------------------------
C     GENERATE A NEW NUMBER
C
1045  CONTINUE!
      TRASYM(ANCH) = TNUMB
      TRAENT(ANCH) = - NEWNUM ! CODED NUMBER
      NEWNUM = NEWNUM + 1
      GOTO 99
C-------------------------------------------------------------
C     REPLACE THE PREVIOUS SYMBOL BY ITS LENGTH
C
1046  CONTINUE!
      TRASYM(ANCH) = TNUMB
      SYMB = TRAENT(ANCH)
      TRAENT(ANCH) = - (SYMEND(SYMB) - SYMPOS(SYMB) + 1)
      GOTO 99
C------------------------------------------------------------------
C     N M #47 -> M (AND A MESSAGE IF N # M)
C
1047  CONTINUE
      CALL SEMARI (ANCH,SEMNUM-40)
      GOTO 99
C--------------------------------------------------------------------
1048  CONTINUE!
1049  CONTINUE!
1050  CONTINUE
      GOTO 99
C--------------------------------------------------------------------
C     X Y #51 -> IF X IS NOT Y THEN ASSERT(62)
C
1051  CONTINUE
      A1 = TRA(ANCH)
10511 IF(TRA(A1) .EQ. ANCH) GOTO 10512
        A1 = TRA(A1)
      GOTO 10511
10512 CONTINUE
      IF (TRAENT(A1) .EQ. TRAENT(ANCH)) GOTO 10513
        CALL ASSERT (62,-TRAENT(A1),-TRAENT(ANCH))
10513 CONTINUE
      GOTO 99
C--------------------------------------------------------------------
C     SPLIT THE STRING IN 'TREXPA' IN '2HXX,2HYY,...'
C
1052  CONTINUE
      TRAENT(ANCH) = - ABS(TRAENT(ANCH))
      GOTO 99
C--------------------------------------------------------------------
C     GENERATE A COMMENT WITH THE SOURCE-LINE-NUMBER
C
1053  CONTINUE
      CALL TRAPIM (ANCH,TCOMT,- LINENO+1)
      GOTO 99
C-------------------------------------------------------------------
1054  CONTINUE
1055  CONTINUE
1056  CONTINUE
1057  CONTINUE
1058  CONTINUE
1059  CONTINUE
1060  CONTINUE
1061  CONTINUE
1062  CONTINUE
1063  CONTINUE
1064  CONTINUE
1065  CONTINUE
1066  CONTINUE
1067  CONTINUE
1068  CONTINUE
1069  CONTINUE
C     ABOVE ACTIONS ARE ALL UNDEFINED SO FAR
C
99    CONTINUE ! ESAC
      RETURN
      END
&END
&(SEPUSH  )
      SUBROUTINE SEPUSH (XMAR,X,XTAIL,XBIT)
C     PUSH AN ELEMENT IN A SET
C
      %INCLUDE (PARS)
      %INCLUDE (SETS)
      INTEGER PARASK
     = ,I
     = ,I1       ! -> THE ELEMENT BEFORE 'I2'
     = ,I2       ! -> CURRENT ELEMENT
     = ,POT2    ! A POWER OF 2 TO SET A BIT
     = ,X        ! ELEMENT,BE AMRKED
     = ,XBIT     ! THE BIT THAT IS MARKED
     = ,XHEAD    ! -> BEGIN AND
     = ,XMAR(1)  ! ARRAY THAT CONTAINS THE MARKINGS
     = ,XTAIL    ! APPEND,THIS SET
C
      IF (MOD(XMAR(X),XBIT+XBIT) .GE. XBIT) GOTO 3 ! NOT YET IN THE SET
        XMAR(X) = XMAR(X) + XBIT ! MARK THE VALUE
        IF (FSET .GE. SETHIB) GOTO 4
          SETELE(XTAIL) = X ! STORE THE VALUE
          SET   (XTAIL) = FSET
          XTAIL = FSET
          FSET = SET(FSET)
        GOTO 5 ! 'SET' NOT EXHAUSTED
4       CONTINUE
          CALL ASSERT(20,XTAIL,X)
5    CONTINUE
3     CONTINUE ! NOT MARKED
      RETURN ! SEPUSH
C------------------------------------------------------
      ENTRY SETALL (XHEAD,XTAIL,XBIT)
C     ALLOCATE A NEW SET
C
      XBIT = POT2
      POT2 = POT2 + POT2
      IF (FSET .GE. SETHIB) GOTO 1
        XHEAD = FSET
        XTAIL = XHEAD
        FSET = SET(FSET)
      GOTO 2 ! .GE. SETHIB
1     CONTINUE
        CALL ASSERT(5,FSET,SETHIB)
2     CONTINUE
      RETURN ! SETALL
C----------------------------------------------------------
      ENTRY SETBIN
C     RESET 'POT2' FOR SUCCESSIVE CALLS OF 'SETALL'
C
      POT2 = 1
      RETURN ! SETBIN
C----------------------------------------------------------
      ENTRY SETDEL (XMAR,X,XHEAD,XTAIL,XBIT)
C     DELETE A SINGLE ELEMENT OF A LIST/SET
C
      IF (MOD(XMAR(X),XBIT+XBIT)  .LT. XBIT) GOTO 8 ! 'X' IS MARKED
        XMAR(X) = XMAR(X) - XBIT
        SET(1) = XHEAD
        I1 = 1
        I2 = SET(I1)!
13      IF(I2 .EQ. XTAIL) GOTO 9
          IF (SETELE(I2) .NE. X) GOTO 10 ! RIGHT ELEMENT FOUND
            SET(I1) = SET(I2)
            SET(I2) = FSET
            FSET = I2!
            GOTO 100
10        CONTINUE ! FOUND
          I1 = I2
          I2 = SET(I1)!
        GOTO 13
9       CONTINUE ! ALL ELEMENTS
        ! 'X' WAS NOT FOUND HERE
        CALL ASSERT(13,X,XTAIL)
C
100     CONTINUE
        XHEAD = SET(1)
8     CONTINUE ! WAS MARKED
      RETURN ! SETDEL
C------------------------------------------------------------------
      ENTRY SETFRE (XMAR,XHEAD,XTAIL,XBIT)
C     DELETE AN ENTIRE SET AND UNMARK ALL ELEMENTS
C
14    IF(XHEAD .EQ. XTAIL) GOTO 12
        I1 = SETELE(XHEAD)
        XMAR(I1) = XMAR(I1) - XBIT
        I = XHEAD
        XHEAD = SET(XHEAD)
        SET(I) = FSET
        FSET = I!
      GOTO 14
12    CONTINUE ! WHILE NOT EMPTY
      RETURN ! SETFRE
C------------------------------------------------------------
      ENTRY SETPOP (XMAR,X,XHEAD,XBIT)
C     TAKE AN ELEMENT FROM THE HEAD OF A QUEUE
C
      X = SETELE(XHEAD)
      XMAR(X) = XMAR(X) - XBIT
      I = XHEAD
      XHEAD = SET(XHEAD)
      SET(I) = FSET
      FSET = I!
      RETURN ! SETPOP
      END
&END
&(SETINF  )
      SUBROUTINE SETINF (CHARN,CHARS,CHARE,XHEAD,XTAIL)
C     INFORM ABOUT A SINGLE SET/LIST/QUEUE
C
      %INCLUDE (PARS)
      %INCLUDE (SETS)
      INTEGER XHEAD,XTAIL,CHARS,CHARE,CHARN(1)
      EXTERNAL OUTSET
C
      CALL ZZWC(CHARN,CHARS,CHARE,0)
      CALL ZZWI(XHEAD,4)
      CALL ZZWI(XTAIL,4)
      CALL ZZWC(': ',1,2,0)
      CALL LITRAC(SET,XHEAD,XTAIL,OUTSET,1)
      CALL ZZWS (0)
      RETURN ! SETINF
      END
&END
&(SETINI  )
      SUBROUTINE SETINI
C     INITIALIZE ALL SETS
C     GF 24.08.80: 'SET' MINGLED UP WITH 'MEMNUC'
C
      %INCLUDE (PARS)
      %INCLUDE (MEMS)
      %INCLUDE (MEMSETS)
      INTEGER I
     = ,J  ! 'MEMNUC(J)' MAY BE USED AS 'SET(J)' (.NE. PROD-NO.)
C
      J = 1
      DO 1 I = 2,SETHIB
        IF (MEM(I) .EQ. EOP) GOTO 2
          J = I
          SET(J) = I + 1
        GOTO 3
2       CONTINUE
          SET(J) = I + 1
3       CONTINUE
1     CONTINUE
      I = 1
4     I = I + 1
      IF (MEM(I) .EQ. EOP) GOTO 4
      FSET = I
      SET(J) = SETHIB
      SET(SETHIB) = SETHIB
C
      CALL SETBIN
      CALL SETALL(EMITSH,EMITST,EMITSB)
      CALL SETALL(EMITTH,EMITTT,EMITTB)
      CALL SETALL(LAGARH,LAGART,LAGARB)
      CALL SETALL(LAGETH,LAGETT,LAGETB)
      CALL SETALL(LAPUTH,LAPUTT,LAPUTB)
      CALL SETALL(SPLITH,SPLITT,SPLITB)
      CALL SETALL(STAGAH,STAGAT,STAGAB)
      CALL SETALL(STAGBH,STAGBT,STAGBB)
      CALL SETALL(STASUH,STASUT,STASUB)
      CALL SETALL(TREOUH,TREOUT,TREOUB)
      CALL SETBIN
      CALL SETALL(PRODEH,PRODET,PRODEB) ! PROMAR
      CALL SETBIN
      CALL SETALL(STACLH,STACLT,STACLB) ! SYMMAR
      CALL SETALL(STAOPH,STAOPT,STAOPB) ! SYMMAR
      CALL SETALL(SYMINH,SYMINT,SYMINB) ! SYMMAR
      CALL SETALL(GRASYH,GRASYT,GRASYB) ! SYMMAR
      RETURN ! SETINI
      END
&END
&(SETS    )
C-------GF 28.08.80----------------------------------- S E T S
      INTEGER FSET,SETHIB
      INTEGER SET   (&SETH),SETELE(&SETH)
     = ,EMITSH,EMITST,EMITSB   ! STA: FOR EMITT, SOURCE
     = ,EMITTH,EMITTT,EMITTB   ! STA: FOR EMITT, TARGET
     = ,LAGARH,LAGART,LAGARB   ! STA: FOR LAGAR
     = ,LAGETH,LAGETT,LAGETB   ! STA: FOR LAGET
     = ,LAPUTH,LAPUTT,LAPUTB   ! STA: FOR LAPUT
     = ,SPLITH,SPLITT,SPLITB   ! STA: FOR SPLIT
     = ,STACLH,STACLT,STACLB   ! SYM: FOR STACLO
     = ,STAGAH,STAGAT,STAGAB   ! STA: FOR STAGAR, ILL STATES
     = ,STAGBH,STAGBT,STAGBB   ! STA: FOR STAGAR, SURVIVING STATES
     = ,STASUH,STASUT,STASUB   ! STA: FOR STASUC
     = ,SYMINH,SYMINT,SYMINB   ! SYM: FOR SYMINS
      COMMON /SETS/
     =  FSET
     = ,SETHIB
     = ,EMITSH,EMITST,EMITSB   ! STA: FOR EMITT, SOURCE
     = ,EMITTH,EMITTT,EMITTB   ! STA: FOR EMITT, TARGET
     = ,LAGARH,LAGART,LAGARB   ! STA: FOR LAGAR
     = ,LAGETH,LAGETT,LAGETB   ! STA: FOR LAGET
     = ,LAPUTH,LAPUTT,LAPUTB   ! STA: FOR LAPUT
     = ,SPLITH,SPLITT,SPLITB   ! STA: FOR SPLIT
     = ,STACLH,STACLT,STACLB   ! SYM: FOR STACLO
     = ,STAGAH,STAGAT,STAGAB   ! STA: FOR STAGAR, ILL STATES
     = ,STAGBH,STAGBT,STAGBB   ! STA: FOR STAGAR, SURVIVING STATES
     = ,STASUH,STASUT,STASUB   ! STA: FOR STASUC
     = ,SYMINH,SYMINT,SYMINB   ! SYM: FOR SYMINS
      COMMON /SETTRA/ SETELE
      COMMON /MEMSET/
     =  SET    ! -> NEXT ELEMENT
&END
&(SETSIN  )
      SUBROUTINE SETSIN
C     INFORM ABOUT ALL SETS
C
      %INCLUDE (PARS)
      %INCLUDE (SETS)
      INTEGER PARASK
      INTEGER I
     = ,ELEM
     = ,STATE     ! A STATE THAT CONTAINS A CONFLICT
     = ,SYMBOL    ! A SYMBOL THAT IS NOT ACCESSIBLE
C
      IF (PARASK('SETSIN',1,6,0) .EQ. 0) GOTO 1
        CALL SETINF('EMITS ',1,6,EMITSH,EMITST)
        CALL SETINF('EMITT ',1,6,EMITTH,EMITTT)
        CALL SETINF('LAGAR ',1,6,LAGARH,LAGART)
        CALL SETINF('LAGET ',1,6,LAGETH,LAGETT)
        CALL SETINF('LAPUT ',1,6,LAPUTH,LAPUTT)
        CALL SETINF('PRODEL',1,6,PRODEH,PRODET)
        CALL SETINF('SPLIT ',1,6,SPLITH,SPLITT)
        CALL SETINF('STACLO',1,6,STACLH,STACLT)
        CALL SETINF('STAGAR',1,6,STAGAH,STAGAT)
        CALL SETINF('STAGB ',1,6,STAGBH,STAGBT)
        CALL SETINF('STAOPC',1,6,STAOPH,STAOPT)
        CALL SETINF('STASUC',1,6,STASUH,STASUT)
        CALL SETINF('SYMINS',1,6,SYMINH,SYMINT)
        CALL SETINF('TREOUS',1,6,TREOUH,TREOUT)
1     CONTINUE ! SETSIN
      RETURN ! SETSIN
      END
&END
&(SETTRAS )
C-------GF 28.08.80------------------- S E T T R A S
C      STRUCTURE TREE, INTERNAL LISTS
      INTEGER FTRA,TRAHIB
      INTEGER TRA(&TRAH)
        INTEGER TRASYM(&TRAH)
        INTEGER TRAENT(&TRAH)
      INTEGER TVOID,TKEYW,TSPEC,TCALL,TCOMT
      INTEGER TGOTO,TIDEN,TNUMB,TSTRI
      COMMON /TRAS/
     =  FTRA      ! -> LAST ELEMENT OF FREE RING
     = ,TRAHIB      ! HIGH BOUND OF 'TRA'
      COMMON /TRAS/
     =  TVOID     ! 1 IGNORE ACCU
     = ,TKEYW     ! 2 KEYWORD
     = ,TSPEC   ! 3 PUNCTUATION CHARACTERS
     = ,TCALL   ! 4 COMBINED SYMBOL, PAGED CONTENTS
     = ,TCOMT     ! 5 COMMENT
     = ,TGOTO   ! 6 END OF COMBINED SYMBOL
     = ,TIDEN   ! 7 IDENTIFIER
     = ,TNUMB   ! 8 NUMBER
     = ,TSTRI   ! 9 STRIN
      %PARAMETER TRAH2=TRAH+1
      %PARAMETER TRAH3=TRAH2+TRAH
      EQUIVALENCE (SETELE(1),TRA(1))
      EQUIVALENCE (SETELE(&TRAH2),TRASYM(1))
      EQUIVALENCE (SETELE(&TRAH3),TRAENT(1))
&END
&(SHOMAP  )
      PROGRAM SHOMAP
C     SUPPRESS A LOT OF LINES IN A TKB-LISTING
C     GF 07.08.80
C
      %INCLUDE (PARS)
      INTEGER USOR,SORBUF(66)
      INTEGER ZZCR
      INTEGER I,L
      INTEGER N,J
      DATA N /0/
C
      UPAR = 5
      OPEN (UNIT=UPAR,NAME='TT:'
     = )
      WRITE (UPAR,12)
      USOR = 4
      OPEN (UNIT=USOR,NAME='DL1:[20,21]BOFOR.MAP',TYPE='OLD'
     = )
4     CONTINUE
      READ (USOR,5,END=7) L,(SORBUF(I),I=1,60)
5     FORMAT(Q,66A2)
      IF (ZZCR(SORBUF,46,46,'.',1,1) .EQ. 0
     = .AND. N .GT. 200
     =) GOTO 4
      DO 6 I = 1,L
        CALL ZZCI (SORBUF,I,J)
        IF (J .GE. 14 .OR. J .EQ. 9) GOTO 6
C       9=HT, 10=LF, 12=FF, 13=CR
        CALL ZZIC (0,SORBUF,I)
6     CONTINUE
      N = N + 1
      IF (MOD(N,65) .EQ. 0) WRITE (UPAR,12)
12      FORMAT(1H1)
      WRITE (UPAR,11) (SORBUF(I),I=1,60)
11    FORMAT(1X,66A2)
      GOTO 4
7     CONTINUE
      WRITE (UPAR,12)
      STOP
      END
&END
&(SHOMAPTB)
SHOMAP/CP/FP=BOFOR/LB:SHOMAP,BOFOR/LB
//
&END
&(SLOS    )
C-----GF 26.07.80---------------------------------------- S L O S
      INTEGER FSLO,SLOHIB,SLOT(&TREH,&SLOH)
      INTEGER SLOFUL(&SLOH)
      COMMON /SLOS/
     =  FSLO    ! NEXT SLOT TO BE ALLOCATED
     = ,SLOHIB  ! NUMBER OF SLOTS
     = ,SLOT    ! FILL THE 'TRE'-RECORDS IN THIS MATRIX
     = ,SLOFUL  ! = 0 (TREREF) IF SLOT IS EMPTY (OCCUPIED)
&END
&(SPAALL  )
      SUBROUTINE SPAALL (STATE,IHD,ITL)
C     PUT A 'STATE' IN 'SPAS'-RING
C     GF 08.11.80
C
      %INCLUDE (PARS)
      %INCLUDE (SPAS)
      INTEGER I2 ! -> SUCCESSIVE ELEMENTS IN 'SPAS'
     = ,IHD     ! -> FIRST ITEM OF 'STATE'
     = ,ITL     ! -> LAST  ...
     = ,STATE ! LOOK FOR THIS STATE
C
      I2 = SPA(SPATL)
      IF (I2 .NE. SPAHD) GOTO 1
        IF (SPAHD .EQ. SPATL) GOTO 99
        CALL SPAFRE
1     CONTINUE
C     THIS IS THE NEWEST
      SPASTA(I2) = STATE
      SPAIHD(I2) = IHD
      SPAITL(I2) = ITL
      SPATL = I2
      IF (SPATES .EQ. 1)
     =  WRITE (UPRI,7) I2,STATE,IHD,ITL
7     FORMAT(' ALLOC: ',4I5)
99    RETURN
      END
&END
&(SPAFRE  )
      SUBROUTINE SPAFRE
C     PUT A 'STATE' IN 'SPAS'-RING
C     GF 08.11.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (SPAS)
      INTEGER I2 ! -> SUCCESSIVE ELEMENTS IN 'SPAS'
     = ,IHD     ! -> FIRST ITEM OF 'STATE'
     = ,ITL     ! -> LAST  ...
     = ,STATE ! LOOK FOR THIS STATE
C
2     CONTINUE
        IF (SPAHD .EQ. SPATL) GOTO 99
C       THROW THE OLDEST
        SPAHD = SPA(SPAHD)
        IHD = SPAIHD(SPAHD)
        ITL = SPAITL(SPAHD)
        IF (SPATES .EQ. 1)
     =    WRITE (5,7) SPAHD,SPASTA(SPAHD),IHD,ITL
7         FORMAT(' FREED: ',4I5)
      IF (IHD .EQ. ITEHIB) GOTO 2
      ITE(ITL) = FITE
      FITE = IHD
99    RETURN
      END
&END
&(SPAINI  )
      SUBROUTINE SPAINI
C     INITIALIZE 'SPAS' DATA STRUCTURE
C     GF 08.11.80
C
      %INCLUDE (PARS)
      %INCLUDE (SPAS)
      INTEGER PARASK
      INTEGER I2
C
      SPAHD = 1
      SPATL = PARASK('AF',1,2,SPAHIB-1)
      SPATES = PARASK('SPATES',1,6,0)
      DO 1 I2 = SPAHD,SPATL
        SPA(I2) = I2 + 1
        SPASTA(I2) = 0
1     CONTINUE
      SPA(SPATL) = SPAHD
      SPATL = SPAHD
      RETURN
      END
&END
&(SPAS    )
C-----GF 08.11.80--------------------------------------------- S P A S
C     STATES WHICH ARE POSSIBLY AVAILABLE
      INTEGER SPAHD,SPATL,SPAHIB,SPATES
      INTEGER SPA(&SPAH)
      INTEGER SPASTA(&SPAH),SPAIHD(&SPAH),SPAITL(&SPAH)
      COMMON /SPAS/
     =  SPAHD   ! -> 1ST FREE ELEMENT IN 'SPA'-RING
     = ,SPATL   ! -> LAST ELEMENT OCCUPIED
     = ,SPAHIB  ! HIGH BOUND OF 'SPAS'
     = ,SPA     ! -> NEXT ELEMENT IN RING
     = ,SPASTA  ! NUMBER OF THE STATE WHICH IS AVAILABLE
     = ,SPAIHD  ! -> 1ST 'ITE'-ELEMENT OF 'STATE'
     = ,SPAITL  ! -> LAST ...
      EQUIVALENCE (SPATES,PARVAL(&PARH))
&END
&(SPASEA  )
      SUBROUTINE SPASEA (STATE)
C     LOOK WHETHER 'STATE' IS YET AVAILABLE
C     GF 08.11.80
C
      %INCLUDE (PARS)
      %INCLUDE (SPAS)
      %INCLUDE (STAS)
      INTEGER I1,I2 ! -> SUCCESSIVE ELEMENTS IN 'SPAS'
     = ,STATE ! LOOK FOR THIS STATE
C
      IF (SPAHD .EQ. SPATL) RETURN
      I1 = SPAHD
      I2 = SPA(I1)
1     CONTINUE
        IF (SPASTA(I2) .NE. STATE) GOTO 3
C       STATE WAS FOUND - DELETE IT FROM 'SPAS'
        STAITE(STATE) = SPAIHD(I2)
        IF (I2 .NE. SPATL) GOTO 5
          SPATL = I1
        GOTO 6
5       CONTINUE
          SPA(I1) = SPA(I2)
          SPA(I2) = SPA(SPATL)
          SPA(SPATL) = I2
6       CONTINUE
        IF (SPATES .EQ. 1)
     =    WRITE (UPRI,7) I2,STATE,SPAIHD(I2),SPAITL(I2),SPAHD,SPATL
7         FORMAT(' FOUND: ',6I5)
        GOTO 99
3     CONTINUE
      IF (I2 .EQ. SPATL) GOTO 4
        I1 = I2
        I2 = SPA(I1)
      GOTO 1
4     CONTINUE
99    RETURN
      END
&END
&(SPEINI  )
      SUBROUTINE SPEINI
C     INITIALIZE THE ACCESS TO SPECIAL CHARACTERS
C
      %INCLUDE (PARS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      INTEGER I
      INTEGER HIGH8(4)
      COMMON /SPES/ HIGH8
C
      SYMPOS(SYMHIB - 1) = STRHIB
      SYMPOS(SYMHIB) = STRHIB + 1
      DO 11 I=1,8
        CALL ZZIC (127,HIGH8,I)
11    CONTINUE
      CALL ZZIC (127,STRNG,STRHIB) ! A MAXIMAL ELEMENT
      SPEH = FSYM
      FSYM = FSYM + 1!
      SYMLNK(SPEH) = SYMHIB - 1
      SYMPOS(SPEH) = FSTR
      SYMPOS(FSYM) = FSTR + 1
      CALL ZZIC (0,STRNG,FSTR) ! A MINIMAL ELEMENT
      FSTR = FSTR + 1
      RETURN ! SPEINI
      END
&END
&(SPEINS  )
      SUBROUTINE SPEINS (CHARN,CHARS,CHARE,  SYMBOL)
C     INSERT AN ELEMENT IN THE LIST OF SPECIAL CHARACTERS
C     GF 19.07.80: 'FSYM > SYMHIB' DISABLES INSERTION
C
      %INCLUDE (PARS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      INTEGER ZZCR
      INTEGER I
     = ,CHARS,CHARE,CHARN(1) ! INSERT THIS STRING
     = ,I1      ! INSERT AFTER THIS SYMBOL
     = ,I2      ! INSERT BEFORE ...
     = ,POS     ! MOVE 'CHARN' HERE
     = ,POE
     = ,LNG     ! LENGTH OF STRING
     = ,SYMBOL  ! RESULT FOR CODE ASSIGNING
C
      POS = FSTR
      LNG = CHARE - CHARS + 1
      POE = POS + LNG - 1
      IF (FSTR + LNG .GE. STRHIB) GOTO 13
        FSTR = FSTR + LNG
        CALL ZZCC (CHARN,CHARS,CHARE,STRNG,POS,POE)
      GOTO 14 ! NO 'STR'-OVERFLOW
13    CONTINUE
        CALL ASSERT(28,FSTR,STRHIB)
        GOTO 101 ! DONINS
14    CONTINUE ! OVERFLOW
C
      I1 = SPEH ! THERE IS A MINIMAL ELEMENT, 'SPEH' ->
      I2 = SYMLNK(I1)
15    IF(I1 .GE. SYMHIB) GOTO 16
        IF (ZZCR (STRNG,POS,POE
     =           ,STRNG,SYMPOS(I2),SYMEND(I2)) .GE. 0)
     =  GOTO 17
          IF (FSYM .GE. SYMHIB) GOTO 19
            SYMBOL = FSYM
            FSYM = FSYM + 1!
            SYMPOS(FSYM) = FSTR
            SYMLNK(SYMBOL) = I2
            SYMLNK(I1) = SYMBOL
            SYMPOS(SYMBOL) = POS
C           SYMEND(SYMBOL) = POE
          GOTO 20 ! NO 'SYM'-OVERFLOW
19        CONTINUE
            IF (FSYM .NE. SYMHIB) GOTO 22
C             USUAL OVERFLOW OF 'SYMS'
              CALL ASSERT (8,SYMHIB,0)
            GOTO 23
22          CONTINUE
C             SPECIAL CASE WHEN CALLED BY 'SEMANT'
C             DO NOT INSERT IF NOT FOUND
              SYMBOL = 0 ! INDICATES "NOT FOUND"
23          CONTINUE
20        CONTINUE
          GOTO 101 !DONINS
17      CONTINUE
        IF (ZZCR (STRNG,POS,POE
     =           ,STRNG,SYMPOS(I2),SYMEND(I2)) .NE. 0)
     =  GOTO 21
          SYMBOL = I2
          FSTR = POS ! DELETE THE TAIL OF 'STRNG'
          GOTO 101 ! DONINS
21      CONTINUE ! =
18      CONTINUE
        ! CONTINUE.LE. : TRY NEXT ELEMENT OF THE LIST
        I1 = I2
        I2 = SYMLNK(I1)!
      GOTO 15
16    CONTINUE ! WHILE .GE. SYMHIB
C
101   CONTINUE !       DONINS:
      ! NO RESTORING OF 'SYMLNK(1)' BECAUSE 'SPEH' -> MINIMAL ELEMENT
      ! 'CODTAB' IS ALREADY INITIALIZED WITH 'SPEC'
      IF (FSYM .LE. SYMHIB) GOTO 24
C       REPAIR THE SPECIAL CALL BY 'SEMANT'
        FSYM = FSYM - SYMHIB
        FSTR = POS ! 'SYMBOL' IS NOT INSERTED
24    CONTINUE
      RETURN ! SPEINS
      END
&END
&(SPEMAP  )
      SUBROUTINE SPEMAP (SYMBOL)
C     EXTRACT A COMBINATION OF SPECIAL CHARACTERS AND RETURN A SYMBOL
C
      %INCLUDE (PARS)
      %INCLUDE (CODS)
      %INCLUDE (LINS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      INTEGER PARASK
      INTEGER ZZCR
      INTEGER I
     = ,LINK    ! -> CURRENT SYMBOL
     = ,LNG     ! LENGTH OF 'SYMBOL'
     = ,LINLNG  ! LENGTH OF SYMBOL 'LINK'
     = ,SYMBOL  ! RESULTING SCANNER-SYMBOL
     = ,SPECOM(4) ! COLLECT THE 'SYMBOL' HERE
      COMMON /SPES/ HIGH8
C
      LNG = 1
      FLIN = FLIN - 1 ! 'SCAN' ALREADY READ THE FIRST CHARACTER
      CALL ZZCC (LINE,FLIN,FLIN,  SPECOM,LNG,LNG)
      SYMBOL = SPEH ! 'SPEH' IS RETURNED FOR AN ILLEGAL COMBINATION
      LINK = SYMLNK(SYMBOL)
4     IF(LINK .GE. SYMHIB) GOTO 5
        LINLNG = SYMEND(LINK) - SYMPOS(LINK) + 1
        IF(PARASK('SPEMAP',1,6,0) .NE. 2) GOTO 12
          CALL ZZWC (' SPEREL =',1,9,0)
          CALL ZZWC (SPECOM,1,LNG,0)
          CALL ZZWC ('=?=',1,3,0)
          CALL PUTSYM(LINK)
          CALL ZZWS (0)
12      CONTINUE
        IF (ZZCR (SPECOM,1,LNG
     =           ,STRNG,SYMPOS(LINK),SYMEND(LINK)))
     =  19,20,21
19      CONTINUE
C         SPECOM(1:LNG) < STRNG(LINK)
          IF (LNG .GE. LINLNG) GOTO 100 ! DONE
          IF (ZZCR(SPECOM,1,LNG
     =            ,STRNG,SYMPOS(LINK),SYMPOS(LINK)+LNG-1) .NE. 0)
     =    GOTO 100
C         NOW 'LNG < LINLNG' AND 'SPECOM' IS A PREFIX
          GOTO 30 ! ADD
20      CONTINUE
C         SPECOM(1:LNG) = STRNG(LINK)
          SYMBOL = LINK
C
30        CONTINUE ! ADD:
          LNG = LNG + 1 ! LOOK WHETHER NEXT CHARACTER MATCHES TOO
          FLIN = FLIN + 1 ! THE ONE ON 'FLIN' MATCHED, NOW READ IT OFF
          CALL ZZCC(LINE,FLIN,FLIN,  SPECOM,LNG,LNG)
        GOTO 10 ! =
21      CONTINUE    ! > : TRY NEXT ELEMENT IN THE LIST
          LINK = SYMLNK(LINK)
10      CONTINUE
      GOTO 4
5     CONTINUE ! WHILE .GE. SYMHIB
C
100   CONTINUE !      DONMAP:
      IF (SYMBOL .EQ. SPEH)
     =  FLIN = FLIN + 1
      IF(PARASK('SPEMAP',1,6,0) .EQ. 0) GOTO 11
        CALL ZZWC(' SPEMAP: ',1,9,0)
        CALL PUTSYM (SYMBOL)
11    CONTINUE
      RETURN ! SPEMAP
      END
&END
&(STAALL  )
      SUBROUTINE STAALL(STATE,SYMBOL)
C     ALLOCATE A NEW STATE
C     GF 09.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (PRES)
      %INCLUDE (PROS)
      %INCLUDE (MEMSETS)
      %INCLUDE (STAS)
      %INCLUDE (SYMS)
      INTEGER I
     = ,STATE    ! THE NUMBER OF THE ALLOCATED STATE
     = ,SYMBOL   ! 'STATE' IS REACHED,THIS SYMBOL
     = ,I1       ! -> ONE ELEMENT BEFORE 'I2'
     = ,I2       ! -> CURRENT ELEMENT IN 'STARST'-LIST
     = ,POS
C
      IF (FSTA .GE. STAHIB) GOTO 1
        STATE = FSTA
        FSTA = STAPRE(FSTA)!
        STAITE(STATE) = ITEHIB
        STAPRE(STATE) = PREHIB
        STAMAR(STATE) = 0
        STASYM(STATE) = SYMBOL
        STARST(STATE) = SYMRST(SYMBOL)
        SYMRST(SYMBOL) = STATE
      GOTO 2 ! NO OVERFLOW
1     CONTINUE
        CALL ASSERT(12,STATE,SYMBOL)
2     CONTINUE ! OVERFLOW
      RETURN ! STAALL
C-----------------------------------------------------------------
      ENTRY STAFRE (STATE)
C     FREE A STATE, DELETE IT FROM ALL LISTS/SETS/QUEUES
C
      ! DELETE 'STATE' FROM 'STARST'-LIST
      SYMBOL = STASYM(STATE)
      STARST(1) = SYMRST(SYMBOL)
      I1 = 1
      I2 = STARST(I1)!
11    IF(I2 .GE. STAHIB) GOTO 12
        IF (I2 .NE. STATE) GOTO 3 ! 'STATE' IS FOUND
          STARST(I1) = STARST(I2)
          GOTO 100
3       CONTINUE ! 'STATE' FOUND
        I1 = I2
        I2 = STARST(I1)!
      GOTO 11
12    CONTINUE ! ALL IN 'STARST'-LIST
      ! 'STATE' WAS NOT FOUND HERE
      CALL ASSERT(27,STATE,SYMBOL)
C
100   CONTINUE ! DONE
      SYMRST(SYMBOL) = STARST(1)
C
      CALL LIFRE (ITE,FITE,STAITE(STATE),ITEHIB)
      CALL LIFRE (PRE,FPRE,STAPRE(STATE),PREHIB)
C
      ! DELETE REQUESTS FOR 'STASUC', 'LAGET', 'LAPUT', 'SPLIT'
      CALL SETDEL (STAMAR,STATE,STASUH,STASUT,STASUB)
      CALL SETDEL (STAMAR,STATE,LAGETH,LAGETT,LAGETB)
      CALL SETDEL (STAMAR,STATE,LAPUTH,LAPUTT,LAPUTB)
      CALL SETDEL (STAMAR,STATE,SPLITH,SPLITT,SPLITB)
C
      ! INSERT 'STATE' IN THE FREE LIST AND MARK IT "UNUSED"
      STAPRE(STATE) = FSTA
      FSTA = STATE
      STAITE(STATE) = 0
      RETURN! STAFRE
      END
&END
&(STACLO  )
      SUBROUTINE STACLO(STATE)
C     ADD THE CLOSURE OF A SET OF SYMBOLS TO A STATE
C     GF 09.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (PROS)
      %INCLUDE (SETS)
      %INCLUDE (SYMS)
      INTEGER I
     = ,ELEM     ! -> EVERY ELEMENT IN THE SET
     = ,ITEMEX   ! FOR CALL 'ITEINS', NOT USED
     = ,PROD     ! ALL PRODUCTIONS OF 'SYMBOL'
     = ,STATE    ! ADD,THIS STATE
     = ,SYMBOL   ! THE SYMBOL,BE CLOSED
     = ,SYMEX    ! .LE.0 IF (A SYMBOL WAS NOT YET IN 'STATE'
C
      ELEM = STACLH
21    IF(ELEM .EQ. STACLT) GOTO 22
        SYMBOL = SETELE(ELEM)
        PROD = SYMPRO(SYMBOL)
23      IF(PROD .GE. PROHIB) GOTO 24
          CALL ITEINS(STATE,PROMON(PROD),SYMEX,ITEMEX)
          IF (SYMEX .GT. 1)
     =      CALL SEPUSH(SYMMAR,SYMEX,STACLT,STACLB)
          PROD = PRO(PROD)
        GOTO 23
24      CONTINUE ! ALL PRODUCTIONS
        ELEM = SET(ELEM)
      GOTO 21
22    CONTINUE ! ALL SYMBOLS IN 'STACLO'-SET
      CALL SETFRE(SYMMAR,STACLH,STACLT,STACLB)
      RETURN! STACLO
      END
&END
&(STAGAR  )
      SUBROUTINE STAGAR
C     5GARBAGE COLLECTION FOR STATES THAT ARE NO MORE ACCESSIBLE
C     5'STAGAX' FOR ILL, 'STAGBX' FOR SURVIVING STATES
C     GF 12.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (PRES)
      %INCLUDE (SETS)
      %INCLUDE (STAS)
      INTEGER I
     = ,ELEM     ! -> AN ELEMENT OF THE SETS
     = ,GOT     ! RESULT OF 'ITEMA1/2', =1 IF STATE WAS READ
     = ,ITEM
     = ,MARKAB   ! ILL AND SURVIVING BITS OF A STATE
     = ,P1       ! -> ONE BEFORE 'P2'
     = ,P2       ! -> CURRENT PREDECESSOR
     = ,PRED
     = ,STATE    ! A DEAD STATE
     = ,STATEA   ! A PREDECESSOR OF AN ILL STATE
     = ,STATEB   ! A SUCCESSOR OF A SURVIVING STATE
C
      ! ALL SUCCESSORS OF ILL STATES GET ILL
      ELEM = STAGAH
1     IF(ELEM .EQ. STAGAT) GOTO 2
        CALL ITEMA1 (SETELE(ELEM),  ITEM,GOT)
3       IF(ITEM .GE. ITEHIB) GOTO 4
          IF (ITEACT(ITEM) .NE. SHIFT .OR. ITESYM(ITEM) .LE. 1) GOTO 23
            CALL SEPUSH(STAMAR,ITESUC(ITEM),STAGAT,STAGAB)
23        CONTINUE
          ITEM = ITE(ITEM)
        GOTO 3
4       CONTINUE ! ALL ITEMS
        CALL ITEMA8 (SETELE(ELEM),GOT)
        ELEM = SET(ELEM)
      GOTO 1
2     CONTINUE ! ALL ILL STATES
C
      ! ILL STATES THAT HAVE A SOUND PREDECESSOR WILL SURVIVE
      ELEM = STAGAH
5     IF(ELEM .EQ. STAGAT) GOTO 6
        STATE = SETELE(ELEM)
        PRED = STAPRE(STATE)
7       IF(PRED .GE. PREHIB) GOTO 8
          STATEA = PRESTA(PRED)
          IF (MOD(STAMAR(STATEA),STAGAB+STAGAB) .GE. STAGAB ) GOTO 9
            ! PREDECESSOR IS NOT ILL
            CALL SEPUSH(STAMAR,STATE,STAGBT,STAGBB)
            GOTO 100
9         CONTINUE ! NOT MARKED "SURVIVING"
          PRED = PRE(PRED)
        GOTO 7
8       CONTINUE ! ALL PREDECESSORS
C
100     CONTINUE ! LEAVE:
        ELEM = SET(ELEM)
      GOTO 5
6     CONTINUE ! ALL ILL STATES
C
      ! ALL (ILL) SUCCESSORS OF SURVIVING STATES WILL SURVIVE
      ELEM = STAGBH
10    IF(ELEM .EQ. STAGBT) GOTO 11
        CALL ITEMA1 (SETELE(ELEM),  ITEM,GOT)
12      IF(ITEM .GE. ITEHIB) GOTO 13
          IF (ITEACT(ITEM) .NE. SHIFT .OR. ITESYM(ITEM) .LE. 1) GOTO 15
            ! REQUESTS FOR 'STASUC' ARE ALL PROCESSED
            STATEB = ITESUC(ITEM)
            IF (MOD(STAMAR(STATEB),STAGAB+STAGAB).LT.STAGAB ) GOTO 14
              ! SUCCESSOR IS ILL
              CALL SEPUSH(STAMAR,STATEB,STAGBT,STAGBB)
14          CONTINUE ! IS MARKED ILL
15        CONTINUE ! SHIFT-ITEM
          ITEM = ITE(ITEM)
        GOTO 12
13      CONTINUE ! ALL ITEMS
        CALL ITEMA8 (SETELE(ELEM),GOT)
        ELEM = SET(ELEM)
      GOTO 10
11    CONTINUE ! ALL ILL STATES
C
      ! DELETE ALL STATES THAT DID NOT SURVIVE
      ELEM = STAGAH
16    IF(ELEM .EQ. STAGAT) GOTO 17
        ! NOT 'SETPOP', ILL BIT IS TESTED AFTER 'STAFRE' TOO
        STATE = SETELE(ELEM)
        IF (MOD(STAMAR(STATE),STAGBB+STAGBB) .GE. STAGBB) GOTO 18
          ! NOT SURVIVING
          CALL STAFRE(STATE)
        GOTO 19
18      CONTINUE ! CORRECT THE SET OF PREDECESSORS
          PRE(1) = STAPRE(STATE)
          P1 = 1
          P2 = PRE(1)!
20        IF(P2 .GE. PREHIB) GOTO 21
            MARKAB = STAMAR(PRESTA(P2))
            IF (MOD(MARKAB,STAGBB+STAGBB) .GE. STAGBB
     =        ! NOT SURVIVING , 'STAMAR' IS NOT CLEARED,'STAFRE'
     =      .OR.  MOD(MARKAB,STAGAB+STAGAB) .LT. STAGAB ! AND ILL
     =      ) GOTO 22
              PRE(P1) = PRE(P2)
              PRE(P2) = FPRE
              FPRE = P2!
              P2 = P1
22          CONTINUE ! NOT SURVIVING
            P1 = P2
            P2 = PRE(P1)!
          GOTO 20
21        CONTINUE ! ALL PREDECESSORS
          STAPRE(STATE) = PRE(1)
19      CONTINUE ! CORRECT
        ELEM = SET(ELEM)
      GOTO 16
17    CONTINUE ! ALL ILL STATES
C
      ! DELETE BOTH SETS
      CALL SETFRE(STAMAR,STAGAH,STAGAT,STAGAB)
      CALL SETFRE(STAMAR,STAGBH,STAGBT,STAGBB)
      RETURN! STAGAR
      END
&END
&(STAS    )
C-------GF 28.08.80--------------------------------- S T A S
      INTEGER FSTA,STAHIB,FNUM,STATE2
      INTEGER STAITE(&STAH),STAPRE(&STAH),STARST(&STAH)
      INTEGER STASYM(&STAH)
      INTEGER STAMAR(&STAH)
      COMMON /STAS/
     =  FSTA     ! 1ST FREE STATE
     = ,STAHIB   ! HIGH BOUND OF 'STAS'
     = ,FNUM     ! 1ST FREE TIME_STAMP FOR 'STASEA'
     = ,STATE2   ! THE PARSER STARTS IN THIS STATE
     = ,STAITE  ! -> FIRST ITEM, -> NEXT FREE STATE
      COMMON /STASTR/
     =  STAPRE  ! -> FIRST PREDECESSOR
     = ,STARST  ! -> NEXT STATE WITH SAME REACHING SYMBOL
     = ,STASYM  ! THE STATE WAS REACHED,THIS SYMBOL
     = ,STAMAR  ! VARIOUS MARKING BITS
&END
&(STASEA  )
      SUBROUTINE STASEA (STATEB,LIMIT,ITEMA)
C     SEARCH FOR A COMPATIBLE STATE
C     VERSION WITHOUT 'NUCS' DATA STRUCTURE
C     GF 30.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (PRES)
      %INCLUDE (STAS)
      %INCLUDE (SYMS)
      INTEGER I1,I2
     = ,GOT     ! RESULT OF 'ITEMA1/2', =1 IF STATE WAS READ
     = ,ITEMA   ! -> FIRST ITEM WITH SYMBOL 'SYMA' IN 'STATEA'
     = ,ITEMC   ! -> ... IN 'STATEC'
     = ,LIMIT   ! NOT USED IN THIS VERSION
     = ,PRED    ! -> LIST OF PREDECESSORS OF 'STATED'
     = ,STATEB  ! NEW AND RESULTING STATE
     = ,STATEC  ! A PREDECESSOR OF 'STATED'
     = ,STATED  ! A STATE WHICH IS PERHAPS COMPATIBLE WITH 'STATEB'
     = ,SYMA    ! 'STATEB' AND 'STATED' ARE REACHED BY THIS SYMBOL
C       STATEA    T H E  PREDECESSOR OF 'STATEB'
      %INCLUDE (ENDS)
C
      SYMA = ITESYM(ITEMA)
      STATED = SYMRST(SYMA)
1     IF(STATED .EQ. STAHIB) GOTO 2
        PRED = STAPRE(STATED)
        IF (PRED .EQ. PREHIB) GOTO 3
          STATEC = PRESTA(PRED)
          CALL ITEMA1 (STATEC,  ITEMC,GOT)
4         IF(ITESYM(ITEMC) .EQ. SYMA .OR. ITEMC .EQ. ITEHIB) GOTO 5
            ITEMC = ITE(ITEMC)
          GOTO 4
5         CONTINUE ! LOOK FOR 'SYMA'
          I1 = ITEMA
          I2 = ITEMC
6         IF(ITESYM(I1) .NE. SYMA  .OR. ITESYM(I2) .NE. SYMA .OR.
     =       ITEACT(I1) .NE. SHIFT .OR. ITEACT(I2) .NE. SHIFT .OR.
     =       ITEPOS(I1) .NE. ITEPOS(I2)
     =     ) GOTO 7
             I1 = ITE(I1)
             I2 = ITE(I2)
           GOTO 6
7          CONTINUE
          IF ((ITESYM(I1) .EQ. SYMA .AND. ITEACT(I1) .EQ. SHIFT) .OR.
     =        (ITESYM(I2) .EQ. SYMA .AND. ITEACT(I2) .EQ. SHIFT)
     =    ) GOTO 8
            STATEB = STATED
            CALL ITEMA8 (STATEC,GOT)
            RETURN
8         CONTINUE
          CALL ITEMA8 (STATEC,GOT)
3       CONTINUE ! .NE. PREHIB
        STATED = STARST(STATED)
      GOTO 1
2     CONTINUE ! WHILE .NE. STAHIB
      RETURN
      END
&END
&(STASTRS )
C-------GF 28.08.80------------------------------- S T A S T R S
      INTEGER FSTR,STRHIB,STRNG(&STRH)
      COMMON /STRS/
     =  FSTR      ! 1ST FREE POSITION IN 'STRNG'
     = ,STRHIB
      EQUIVALENCE (STAPRE(1),STRNG(1))
&END
&(STASUC  )
      SUBROUTINE STASUC
C     (RE)COMPUTE THE SUCCESSORS OF A STATE
C     ONLY FOR THOSE SYMBOLS THAT HAVE 'ITESUC .GE. 0'
C     GF 09.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (PROS)
      %INCLUDE (SETS)
      %INCLUDE (STAS)
      %INCLUDE (SYMS)
      INTEGER I
     = ,GOT     ! RESULT OF 'ITEMA1/2', =1 IF STATE WAS READ
     = ,ITEM     ! ITEM CURRENTLY INSPECTED
     = ,ITEMA    ! FIRST ITEM WITH SYMBOL'SYMA'
     = ,ITEMEX   ! FOR 'ITEINS'
     = ,POSIT
     = ,PRODZ    ! THE PRODUCTION FOUND,CALLS OF 'ALONG'
     = ,STATEA   ! RECOMPUTE THE SUCCESSORS OF THIS STATE
     = ,STATEB   ! ASSUME A NEW STATE AND CREATE 'STATEB'
     = ,STATEC   ! THE OLD SUCCESSOR FOR 'SYMA' , OR 0
     = ,STATED   ! THE STATE THAT IS FOUND INSTEAD OF 'STATEB'
     = ,STATEZ   ! THE STATE REACHED,CALLS OF 'ALONG'
     = ,SYMA     ! CURRENT MARKED SYMBOL
     = ,SYMEX    ! FOR 'ITEINS'
C
1     IF(STASUH .EQ. STASUT) GOTO 2
        CALL SETPOP(STAMAR,STATEA,STASUH,STASUB)
        CALL ITEMA2 (STATEA,  ITEM,ITEM,GOT)
        ITEMA = ITEM
        SYMA = ITESYM(ITEMA)!
4       IF(ITEM .GE. ITEHIB) GOTO 5
          IF (ITESYM(ITEM) .LE. 1) GOTO 6 ! NO DUMMY SYMBOL
          STATEC = ITESUC(ITEM)
          STATED = STAHIB
8         IF(ITESYM(ITEM) .NE. SYMA .OR. ITEACT(ITEM) .NE. SHIFT) GOTO 7
            STATEB = ITESUC(ITEM)
            IF (STATEB .GT. STATEC) STATEC = STATEB ! MAX
            IF (STATEB .LT. STATED) STATED = STATEB ! MIN
            ITEM = ITE(ITEM)
          GOTO 8
7         CONTINUE
          IF (STATED .GT. 0) STATEC = - STATEC
          ITEM = ITEMA
          IF (STATEC .LT. 0) GOTO 9 ! THIS SUCCESSOR MUST BE RECOMPUTED
            CALL STAALL(STATEB,SYMA) ! ALLOCATE A NEW STATE
            IF (STATEC .LE. 0) GOTO 10 ! THERE WAS A SUCCESSOR BEFORE
              CALL PREDEL(STATEA,STATEC) ! PRE(STATEC) -= STATEA
10          CONTINUE ! SUCCESSOR EXISTED
            ! STACLH = STACLT
12          IF(ITESYM(ITEM) .NE. SYMA .OR. ITEACT(ITEM) .NE. SHIFT)
     =      GOTO 11
              POSIT = ITEPOS(ITEM) + 1
              IF (ITESUC(ITEM) .EQ. 0) GOTO 13 ! OLD ITEM
                CALL ALONG(STATEC,POSIT,STATEZ,PRODZ)
                IF (STATEZ .GT. 0)
     =            CALL LADEL(0,STATEZ,PRODZ)
13            CONTINUE ! SUCCESSOR EXISTED
              ITESUC(ITEM) = STATEB ! ASSUME A NEW STATE
              CALL ITEINS(STATEB,POSIT,SYMEX,ITEMEX)
              IF (SYMEX .GT. 1)
     =          CALL SEPUSH(SYMMAR,SYMEX,STACLT,STACLB)
              ITEM = ITE(ITEM)
            GOTO 12
11          CONTINUE ! WHILE SYMA , ->
C
            STATED = STATEB
            CALL STASEA(STATEB,0,ITEMA)
C           ! LOOK FOR A STATE WITH THE SAME NUCL.
            CALL PREINS(STATEA,STATEB)
            IF (STATEB .NE. STATED) GOTO 15 ! REALLY A NEW SUCCESSOR
              CALL STACLO(STATEB)
              ITE(1) = STAITE(STATEB)
              CALL ITEMA9 (STATEB,1) ! 'GOT' BY 'STAALL'
            GOTO 16 ! NEW
15          CONTINUE ! OLD 'STATEB' FOUND
              CALL SETFRE(SYMMAR,STACLH,STACLT,STACLB)
              CALL STAFRE(STATED)
              CALL SEPUSH(STAMAR,STATEB,LAPUTT,LAPUTB)
              I = ITEMA
17            IF(I .EQ. ITEM) GOTO 18 ! RECTIFY 'ITESUC'
                ITESUC(I) = STATEB
                CALL ALONG(STATEB,ITEPOS(I) + 1,STATEZ,PRODZ)
                IF (STATEZ .LE. 0) GOTO 19
                  POSIT = PROMON(PRODZ) + PROLNG(PRODZ)
                  CALL ITEINS(STATEZ,POSIT,SYMEX,ITEMEX)
19              CONTINUE
                I = ITE(I)
              GOTO 17
18            CONTINUE ! ALL SHIFT-ITEMS
16          CONTINUE ! OLD SUCCESSOR
9         CONTINUE ! STATEC .LT. 0
6         CONTINUE ! NO DUMMY SYMBOL
20        IF(ITESYM(ITEM) .NE. SYMA) GOTO 21 ! SKIP REDUCE ITEMS
            ITEM = ITE(ITEM)
          GOTO 20
21        CONTINUE ! SKIP REDUCE
          ITEMA = ITEM
          SYMA = ITESYM(ITEMA)!
        GOTO 4
5       CONTINUE ! ALL ITEMS
        ITE(1) = STAITE(STATEA)
        CALL ITEMA9 (STATEA,GOT)
      GOTO 1
2     CONTINUE ! ALL ELEMENTS OF 'STASUC'-QUEUE
      RETURN! STASUC
      END
&END
&(STASYM  )
      INTEGER FUNCTION STASYM(STATE)
C     THE SYMBOL WHICH ACCESSES A STATE
C     REPLACES AN ARRAY SET BY 'STAALL'
C     GF 20.08.80
C
      %INCLUDE (PARS)
      %INCLUDE (ITES)
      %INCLUDE (MEMS)
      %INCLUDE (STAS)
      INTEGER ITEM
     = ,GOT
     = ,POS     ! POSITION FOR THE TEST FOR NUCLEUS-ITEM
     = ,SYMB    ! THE SYMBOL BEFORE 'POS'
     = ,STATE   ! INDEX FOR 'STASYM'
C
      CALL ITEMA1 (STATE,  ITEM,GOT)
1     IF(ITE(ITEM) .EQ. ITEHIB) GOTO 2
        POS = ITEPOS(ITEM)
        SYMB = MEM(POS - 1)
        IF (SYMB .EQ. EOP) GOTO 3
          STASYM = SYMB
          GOTO 4
3       CONTINUE
        ITEM = ITE(ITEM)
      GOTO 1
2     CONTINUE
C     HERE WAS NO NUCLEUS-ITEM FOUND
      CALL ASSERT (140,STATE,0)
C       CANNOT COMPUTE STASYM(@)
      STASYM = ITESYM(ITEM)
C
4     CONTINUE
      CALL ITEMA8 (STATE,GOT)
      RETURN
      END
&END
&(STAT1   )
C-------GF 01.08.80--------------------------------- S T A T 1
C       STATICS FOR 'SEMANT'
        INTEGER DESL,DESU,INGRAM,BULEFT,MEMPOS,BUMON,BUPROD,REIPOS
      INTEGER NEWNUM
        COMMON /STAT1/
     =  BULEFT    ! LEFT SIDE OF 'BUPROD'
     = ,BUMON     ! -> MEMBER NUMBER ONE OF THE PRODUCTION TO BE BUILT
     = ,BUPROD    ! THE NEW PRODUCTION BUILT BY 'PROCHA'
     = ,DESL    ! DESTINATION, LOWER ELEMENT
     = ,DESU    ! ... HIGH ELEMENT. DESU = DESL +0/+1
     = ,INGRAM  ! = 0 (1) IFF 'SOURCE_TEXT' ('GRAMMAR') IS PARSED
     = ,MEMPOS      ! TO DETERMINE 'REIPOS'
     = ,NEWNUM  ! FOR THE GENERATION OF FORTRAN STATEMENT-NUMBERS
     = ,REIPOS  ! THE POSITION OF THE '@'
&END
&(STKS    )
C-------GF 08.09.80--------------------------------------- S T K S
      INTEGER FSTK,STKHIB,STKSTA(&STKH),STKTRA(&STKH)
      INTEGER STKSYM(&STKH)
      COMMON / STKS/ ! PUSHDOWN-STORE OF THE PARSER
     =  FSTK     ! 1ST FREE 'STK' FOR THE STACK OF STATES
     = ,STKHIB   ! HIGH BOUND OF 'STKS'
     = ,STKSTA  ! STACK FOR STATES, HEAP OF STACKS FOR ACCUMULATORS
     = ,STKTRA  ! -> 1ST ELEMENT OF A NONT./ACCU IN 'TRE'
     = ,STKSYM  ! THE SYMBOL WHICH WAS SHIFTED
&END
&(STRS    )
C-------GF 28.08.80------------------------------- S T R S
      INTEGER FSTR,STRHIB,STRNG(&STRH)
      COMMON /STRS/
     =  FSTR      ! 1ST FREE POSITION IN 'STRNG'
     = ,STRHIB
      COMMON /STASTR/
     =  STRNG      ! ALL IDENTIFIERS, NUMBERS, STRINGS
&END
&(SYMEND  )
      INTEGER FUNCTION SYMEND(SYMBOL)
C     -> LAST CHARACTER OF A SYMBOL
C     REPLACES THE CORRESPONDING ARRAY (SET BY 'HAMAP','SPEINS')
C     GF 20.08.80
C
      %INCLUDE (PARS)
      INTEGER FSYM,SYMHIB
      INTEGER SYMLOB,SPEH,ERRSYM,SCOBEG,SCOEND
      INTEGER EOFILE,IDENT,NUMBER,STRIN
      INTEGER EOSTMT,AXIOM,GRAMAX
      INTEGER SYMPRO(&SYMH),SYMMAR(&SYMH),SYMRST(&SYMH)
      INTEGER SYMPOS(&SYMH),SYMLNK(&SYMH)
      COMMON /SYMS/
     =  FSYM    ! 1ST FREE ENTRY
     = ,SYMHIB  ! MAXIMUM OF POSSIBLE SYMBOLS
     = ,SYMLOB  ! LOW BOUND OF 'SYMS', = 1
     = ,SPEH    ! -> LIST OF COMBINATIONS OF SPECIAL CHARACTERS
     = ,ERRSYM  ! CODE FOR INVALID CHARACTERS
     = ,SCOBEG  ! BEGIN OF COMMENT
     = ,SCOEND  ! END   OF COMMENT, = 5
     = ,EOFILE  ! THE FOLLOWING 4 SYMBOLS DO  NOT  STAND FOR THEMSELF
     = ,IDENT
     = ,NUMBER
     = ,STRIN
     = ,EOSTMT  ! END-OF-STATEMENT SYMBOL
     = ,AXIOM   ! THE START-SYMBOL OF ALL GRAMMARS
     = ,GRAMAX  ! THE LAST SYMBOL BELONGING TO THE GRAMMAR
      COMMON /SYMS/
     =  SYMPRO  ! -> 1ST PRODUCTION IF NONTERMINAL
     = ,SYMPOS  ! -> 1ST CHARACTER IN 'STRNG'
     = ,SYMLNK  ! -> NEXT SYMBOL WITH SAME HASH-CODE
      EQUIVALENCE (SYMMAR(1),SYMLNK(1))
      EQUIVALENCE (SYMRST(1),SYMPOS(1))
      INTEGER SYMBOL
C
      SYMEND = SYMPOS(SYMBOL + 1) - 1
      RETURN
      END
&END
&(SYMINS  )
      SUBROUTINE SYMINS (CHANGE)
C     INSERT ALL (NEW) PRODUCTIONS OF A SYMBOL IN THE TABLE
C     GF 09.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (PRES)
      %INCLUDE (PROS)
      %INCLUDE (SETS)
      %INCLUDE (STAS)
      %INCLUDE (SYMS)
      INTEGER I
     = ,CHANGE   ! = 1 AS LONG AS THE PARSER CHANGED
     = ,I1       ! -> THE ELEMENT BEFORE THE ONE,BE DELETED
     = ,I2       ! -> THE ELEMENT,BE DELETED
     = ,ITEMEX   ! FOR CALL 'ITEINS', NOT USED
     = ,LEFT     ! INSERT PRODUCTIONS OF THIS SYMBOL
     = ,PRED     ! PREDECESSORS OF 'STATEB'
     = ,PROD     ! PRODUCTIONS OF 'LEFT'
     = ,STATEA   ! ALL STATES THAT SHIFT 'LEFT'
     = ,STATEB   ! ALL STATES THAT ARE REACHED,'LEFT
     = ,SYMEX    ! .LE.0 IF (A SYMBOL WAS NOT YET IN 'STATEA'
C
      SET(1) = SYMINH
      I1 = 1
      I2 = SET(I1)!
1     IF(I2 .EQ. SYMINT) GOTO 2
        LEFT = SETELE(I2)
        STATEB = SYMRST(LEFT)
        IF (STATEB .GE. STAHIB) GOTO 3 ! 'LEFT' REACHES SOME STATES
          ! DELETE 'LEFT' FROM THE QUEUE
          CHANGE = 1
          SET(I1) = SET(I2)
          SET(I2) = FSET
          FSET = I2!
          I2 = I1
          SYMMAR(LEFT) = SYMMAR(LEFT) - SYMINB
4         IF(STATEB .GE. STAHIB) GOTO 5
            PRED = STAPRE(STATEB)
6           IF(PRED .GE. PREHIB) GOTO 7
              STATEA = PRESTA(PRED)
              PROD = SYMPRO(LEFT)
8             IF(PROD .GE. PROHIB) GOTO 9
                CALL ITEINS(STATEA,PROMON(PROD),SYMEX,ITEMEX)
                IF (SYMEX .LE. 1) GOTO 10
                  ! STACLH = STACLT
                  CALL SEPUSH(SYMMAR,SYMEX,STACLT,STACLB)
10              CONTINUE ! SYMBOL DID NOT EXIST
                PROD = PRO(PROD)
              GOTO 8
9             CONTINUE ! ALL PRODUCTIONS
              CALL STACLO(STATEA)
              PRED = PRE(PRED)
            GOTO 6
7           CONTINUE ! ALL PREDECESSORS
            STATEB = STARST(STATEB)
          GOTO 4
5         CONTINUE ! ALL STATES REACHED,'LEFT'
3       CONTINUE ! 'LEFT' REACHES SOME STATES
        I1 = I2
        I2 = SET(I1)
      GOTO 1
2     CONTINUE ! ALL 'LEFT' IN 'SYMINS'-QUEUE
      SYMINH = SET(1)
      RETURN! SYMINS
      END
&END
&(SYMNUM  )
      SUBROUTINE SYMNUM (ENTITY,NUM)
C     CONVERT A SYMBOL 'ENTITY' TO AN INTEGER 'NUM'
C     GF 12.07.80
C     GF 19.07.80  BOTH PARAMETERS MAY BE IDENTICAL
C
      %INCLUDE (PARS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      %INCLUDE (ENDS)
      INTEGER I
     = ,DIGIT   ! THE CODE OF A DIGIT FROM THE SYMBOL
     = ,ENTITY  ! -> TO THE SYMBOL TO BE CONVERTED
     = ,NUM     ! THE RESULTING NUMBER
     = ,ZERO    ! THE CODE OF THE DIGIT '0'
     = ,S,E     ! START- AND END-POSITIONS IN 'ENTITY'
C
      IF (ENTITY .GT. 0) GOTO 2
        NUM = - ENTITY ! IT WAS A CODED NUMBER
        GOTO 99
2     CONTINUE
      S = SYMPOS(ENTITY)
      E = SYMEND(ENTITY)
      NUM = 0
      CALL ZZCI ('0',1,ZERO)
      DO 1 I = S,E
        CALL ZZCI (STRNG,I,DIGIT)
        NUM = NUM * 10 + DIGIT - ZERO
1     CONTINUE
99    CONTINUE
      RETURN
      END
&END
&(SYMS    )
C-------GF 28.12.80------------------------------- S Y M S
      INTEGER FSYM,SYMHIB
      INTEGER SYMLOB,SPEH,ERRSYM,SCOBEG,SCOEND
      INTEGER EOFILE,IDENT,NUMBER,STRIN
      INTEGER EOSTMT,AXIOM,GRAMAX
      INTEGER SYMPRO(&SYMH),SYMMAR(&SYMH),SYMRST(&SYMH)
      INTEGER SYMPOS(&SYMH),SYMEND,SYMLNK(&SYMH)
      INTEGER ARROW,BAR,EQUALS,MINUS,PERIOD
      INTEGER BUS,SUB,NUMSIG,SEMI,OPENP,CLOSP
      INTEGER PLUS,TIMES,DIVIDE
      COMMON /SYMS/
     =  FSYM    ! 1ST FREE ENTRY
     = ,SYMHIB  ! MAXIMUM OF POSSIBLE SYMBOLS
     = ,SYMLOB  ! LOW BOUND OF 'SYMS', = 1
     = ,SPEH    ! -> LIST OF COMBINATIONS OF SPECIAL CHARACTERS
     = ,ERRSYM  ! CODE FOR INVALID CHARACTERS
     = ,SCOBEG  ! BEGIN OF COMMENT
     = ,SCOEND  ! END   OF COMMENT, = 5
     = ,EOFILE  ! THE FOLLOWING 4 SYMBOLS DO  NOT  STAND FOR THEMSELF
     = ,IDENT
     = ,NUMBER
     = ,STRIN
     = ,EOSTMT  ! END-OF-STATEMENT SYMBOL
     = ,AXIOM   ! THE START-SYMBOL OF ALL GRAMMARS
     = ,GRAMAX  ! THE LAST SYMBOL BELONGING TO THE GRAMMAR
      COMMON /SYMS/
     =  SYMPRO  ! -> 1ST PRODUCTION IF NONTERMINAL
     = ,SYMPOS  ! -> 1ST CHARACTER IN 'STRNG'
     = ,SYMLNK  ! -> NEXT SYMBOL WITH SAME HASH-CODE
     = ,SYMMAR  ! MARKING AND -> 'TRAS'
      COMMON /SYMS/
     =  ARROW  ! =>
     = ,BAR    ! |
     = ,EQUALS ! =
     = ,MINUS  ! -
     = ,PERIOD ! .
     = ,BUS    ! ]
     = ,SUB    ! [
     = ,NUMSIG ! #
     = ,SEMI   ! ;
      COMMON /SYMS/
     =  OPENP  ! (
     = ,CLOSP  ! )
     = ,PLUS   ! +
     = ,TIMES  ! *   ('MINUS' SEE ABOVE)
     = ,DIVIDE ! /
      EQUIVALENCE (SYMRST(1),SYMPOS(1))
&END
&(TARGET  )
      SUBROUTINE TARGET
C     WRITE THE RESULT OF THE TRANSLATION ON A FILE
C     GF 27.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (STKS)
      %INCLUDE (TRAS)
      %INCLUDE (TRES)
      EXTERNAL TREPUT
      INTEGER I
     = ,ACT     ! -> 'TRA'
     = ,ANCH    ! AN ANCHOR FOR THE REST OF 'TRA'
C
C     STACK CONTENTS AFTER 'ACCEPT' IN 'PARSER'
C     1 = 0
C     2 = TRAHIB
C     3 -> EOSTMT
C     4...FSTK-2 -> REST OF 'TRA'
C
      ANCH = TRAHIB
      ACT = FSTK - 2
      DO 1 I = 4,ACT
        CALL TRAPEN (ANCH,STKTRA(I))
1     CONTINUE
      ACT = FTRE
      CALL TRADO (ANCH,TREPUT)
      CALL TRAPIM (ANCH,TGOTO,0)
      DO 2 I = 1,TREHIB
        CALL TREPUT (ANCH) ! PUSH OUT LAST BUFFER
2     CONTINUE
      CALL TREXPA (ACT)
      END
&END
&(TARS    )
      INTEGER FTAR,TARHIB,TARBUF(&TARH)
      COMMON /TARS/
     =  FTAR   ! 1ST FREE TARNT POSITION
     =, TARHIB ! LAST AVAILABLE TARNT POSITION
     =, TARBUF ! BUFFER WHICH COLLECTS STREAM TARNT-OUT
&END
&(TRACCU  )
      SUBROUTINE TRACCU (ASEM,  SYMB,INC,A1,A2)
C     ACCESS TO AN ACCUMULATOR
C     GF 16.07.80
C     GF 24.07.80: SIMPLER VERSION
C
C     1 <= A1 < A2 <= TRAHIB
C     A1 -> A2
C     A2 -> INC: FOUND, OR A2 = TRAHIB: NOT FOUND
C     INSERT BETWEEN 'A1,A2', RESULTING ANCHOR IS IN 'TRA(1)'
C     ASEM += 1
C
      %INCLUDE (PARS)
      %INCLUDE (SEMS)
      %INCLUDE (SYMS)
      %INCLUDE (TRAS)
      %INCLUDE (ENDS)
      INTEGER I
     = ,A1,A2   ! 2 SUCCEEDING POINTERS TO THE LIST OF ACCUS
     = ,ASEM    ! -> ACCU-ACTION IN 'SEM'
     = ,INC     ! THE INCARNATION OF 'SYMB'
     = ,SYMB    ! THE NAME OF THE ACCU
C
      SYMB = SEMSYM(ASEM)
      ASEM = ASEM + 1
      INC  = SEMSYM(ASEM)
      A1 = 1
      I = 1
      A2 = SYMMAR(SYMB)
      IF (A2 .EQ. 0) A2 = TRAHIB
      TRA(A1) = A2
1     IF(I .GE. INC .OR. A2 .EQ. TRAHIB) GOTO 2
        A1 = A2 ! LOOK AT NEXT IN THE LIST
        A2 = TRA(A1)
        I = I + 1 ! 'INC = 0' IS ALSO O.K.
      GOTO 1
2     CONTINUE
      RETURN ! TRACCU
      END
&END
&(TRACOP  )
      SUBROUTINE TRACOP (ANCH,LAST)
C     APPEND A COPY OF A RING (<- 'LAST') TO 'ANCH'
C     GF 16.07.80
C     GF 24.07.80: WITH 'TRAPIM'
C
      %INCLUDE (PARS)
      %INCLUDE (TRAS)
      INTEGER I
     = ,ACT      ! RESULT OF *TRALOC
     = ,ANCH     ! APPEND TO THIS RING
     = ,LAST     ! COPY THIS RING
     = ,TEMP    ! FOR EXCHANGING IN *TRAPEN
      %INCLUDE (ENDS)
C
      IF (LAST .EQ. TRAHIB) GOTO 1
        I = LAST
C
100     CONTINUE
        I = TRA(I)
        CALL TRAPIM (ANCH,TRASYM(I),TRAENT(I))
        IF (I .NE. LAST) GOTO 100
C
1     CONTINUE
      RETURN ! TRACOP
      END
&END
&(TRADO   )
      SUBROUTINE TRADO (ANCH,APPLY)
C     DO SOMETHING WITH ALL ELEMENTS OF RING 'ANCH'
C     GF 21.07.80
C
C     FOR THE ELEMENTS 'ACT' = 'TRA(ACT)' ... 'ANCH':
C
C       CALL APPLY(ACT)
C
C     IN ADDITION, INFINITE LOOPS ARE AVOIDED.
C
      %INCLUDE (PARS)
      %INCLUDE (TRAS)
      INTEGER LOOPCH
     = ,ACT     ! -> CURRENT ELEMENT
     = ,ANCH     ! -> ELEMENT IN THE RING
      %INCLUDE (ENDS)
C
      IF (ANCH .EQ. TRAHIB) RETURN
      LOOPCH = 0
      ACT = TRA(ANCH) ! -> 1ST
      CALL APPLY (ACT)
1     IF(ACT .EQ. ANCH) GOTO 2
        LOOPCH = LOOPCH + 1
        IF (LOOPCH .LE. TRAHIB) GOTO 3
          CALL ASSERT (138,ACT,FTRA)
          CALL TRADUM (0) ! DUMP THE ENTIRE 'TRA'-STRUCTURE
          RETURN
3       CONTINUE
        ACT = TRA(ACT)
        CALL APPLY (ACT)
      GOTO 1
2     CONTINUE
      RETURN
      END
&END
&(TRADUM  )
      SUBROUTINE TRADUM (ACT)
C     DUMP 'TRA' DATA STRUCTURE
C     GF 19.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (TRAS)
      INTEGER PARASK
      INTEGER I,J
     = ,ACT     ! PRINT THIS ELEMENT OR, IF 'ACT=0', ALL ELEMENTS
     = ,TLOW,THIGH ! FOR THE LOOP ON THE ELEMENTS
      %INCLUDE (ENDS)
C
      IF (PARASK('TRADUV',1,6,1) .EQ. 0) GOTO 3
        J = FTRA
        DO 2 I = 1,TRAHIB
          TRASYM(J) = 0
          J = TRA(J)
          IF (J .EQ. FTRA) GOTO 3
2       CONTINUE
      CALL ASSERT (138,J,FTRA)
3     CONTINUE
      IF (ACT .EQ. 0) GOTO 6
        TLOW = ACT
        THIGH = ACT
      GOTO 7
6     CONTINUE
        TLOW = 2
        THIGH = TRAHIB
7     CONTINUE
      DO 1 I = TLOW,THIGH
        IF (TRASYM(I) .EQ. 0) GOTO 1
        CALL ZZWI (I,4)
        CALL ZZWC ('->',1,2,0)
        CALL ZZWI (TRA(I),4)
        CALL ZZWC (': ',1,2,0)
        CALL TRAO1 (I)
        CALL ZZWS (0)
1     CONTINUE
      RETURN
      END
&END
&(TRAFOR  )
      SUBROUTINE TRAFOR (PROD,TRAIN,   REIPOS,LEFT,TRALEF)
C     TREE - TRANSFORMATOR
C     GF 14.07.80
C
C     'TRAFOR' IS CALLED WHEN 'PARSER' REDUCES TO 'PROD'.
C     THE CODES FOR THE SEMANTIC ACTIONS OF THIS PRODUCTION
C     ARE INTERPRETED IN SEQUENCE, AND THE CORRESPONDING
C     ACTIONS ('ACCO' ... 'EOS') ARE PERFORMED.
C
      %INCLUDE (PARS)
      %INCLUDE (PROS)
      %INCLUDE (SEMS)
      %INCLUDE (STKS)
      %INCLUDE (SYMS)
      %INCLUDE (TRAS)
      %INCLUDE (TRES)
      EXTERNAL TREPUT
      INTEGER PARASK
      INTEGER I
     = ,A1,A2   ! FOR CALLS OF 'TRACCU' AND 'TRATTR'
     = ,ACT     ! RESULT OF TRALOC
     = ,ANCH    ! APPEND 'ELEMENT'S TO THIS ANCHOR
     = ,ASEM    ! -> CURRENT 'SEM'-ENTRY
     = ,BANCH   ! COPY OF 'ANCH' DURING 'COMBINED_LIST'
     = ,INC     ! INCARNATION OF AN ACCU
     = ,LEFT    ! RESULTING LEFT SIDE OF 'PROD'
     = ,PROD    ! DO THE TRANSFORMATION FOR THIS PRODUCTION
     = ,REIPOS  ! POSITION OF ANY BACKSPACE-OPERATOR
     = ,SYMB    ! A TEMPORARY SYMBOL
     = ,TEMP    ! A TEMPORARY FOR EXCHANGING IN TRADEL, -PEN
     = ,TRAIN   ! ANCHOR FOR THE INPUT-STRING
     = ,TRALEF  ! ANCHOR FOR THE RESULTING SUBTREE FOR 'LEFT'
     = ,TREREF  ! -> COMBINED SYMBOL STORED BY 'TREPUT'
      COMMON /STAT2/
     =  A1,A2   ! FOR CALLS OF 'TRACCU' AND 'TRATTR'
     = ,ACT     ! RESULT OF TRALOC
     = ,ANCH    ! APPEND 'ELEMENT'S TO THIS ANCHOR
     = ,ASEM    ! -> CURRENT 'SEM'-ENTRY
     = ,BANCH   ! COPY OF 'ANCH' DURING 'COMBINED_LIST'
     = ,INC     ! INCARNATION OF AN ACCU
     = ,SYMB    ! A TEMPORARY SYMBOL
     = ,TEMP    ! A TEMPORARY FOR EXCHANGING IN TRADEL, -PEN
     = ,TREREF  ! -> COMBINED SYMBOL STORED BY 'TREPUT'
     %INCLUDE (ENDS)
C
      ANCH = TRAHIB ! EMPTY AT THE BEGINNING
      REIPOS = 0 ! NO '@'
      ASEM = PROSEM(PROD) - 1
      IF (PARASK ('TRAFOR',1,6,0) .LT. 1) GOTO 26
        CALL OUTPRO(PROD)
26    CONTINUE
C
99    CONTINUE ! ESAC:
      ASEM = ASEM + 1
      IF (PARASK  ('TRAFOR',1,6,0) .LT. 3) GOTO 21
        I = ASEM
        CALL ZZWC ('TRAFOR:',1,7,0)
        CALL OUTSEM(I)
        CALL ZZWS(0)
        CALL TRADUM (0)
21    CONTINUE
      I = SEM(ASEM)
      GOTO
     = (101,102,103,104 ! ACCO,IN,MA,TA
     = ,105,106,107,108 ! ATCO,IN,MA,SYAT
     = ,109,110,111,112 ! SOCO,REIN,UNCH,SOTA
     = ,113,114,115,116 ! SYCO,SYIN,SYMA,SEPR
     = ,117,118,119,120 ! ACCU,ATTR,EOSY,EOS
     = ),I
C----------------------------------------------------------
101   CONTINUE !  ACCO
C
      CALL TRACCU (ASEM,  SYMB,INC,A1,A2)
1011  CONTINUE
      IF (A2 .EQ. TRAHIB) GOTO 1 ! EXISTS
        CALL TRACOP (ANCH,TRAENT(A2))
      GOTO 2
1     CONTINUE
        CALL TRAPIM (ANCH,TIDEN,SYMB)
2     CONTINUE
      GOTO 99
C----------------------------------------------------------
102   CONTINUE !  ACIN
C
      CALL ASSERT  (127,PROD,ASEM)
C       ACIN IN PRODUCTION @, ASEM = @
      GOTO 99
C----------------------------------------------------------
103   CONTINUE ! ACMA
C
      IF (SEMSYM(ASEM) .NE. 0) GOTO 1031
C       HERE THE DESTINATION IS THE DELETE-ACCU
        ASEM = ASEM + 1
        CALL TRAPEN (FTRA,ANCH)
        ANCH = TRAHIB
      GOTO 99
1031  CONTINUE
      CALL TRACCU (ASEM,  SYMB,INC,A1,A2)
      IF (INC .LE. 0) GOTO 3
        IF (A2 .NE. TRAHIB) GOTO 4
          CALL ASSERT  (125,-SYMB,INC)
C           ASSIGNMENT TO NONEXISTING ACCU-INCARNATION @:@
4       CONTINUE
      GOTO 5
3     CONTINUE
        A2 = TRAHIB
5     CONTINUE
      INC = TVOID
      GOTO 1071 ! ATMA1
C----------------------------------------------------------
104   CONTINUE !  ACTA
C
      CALL TRACCU (ASEM,  SYMB,INC,A1,A2)
      IF (A2 .EQ. TRAHIB) GOTO 6 ! EXISTS
        CALL TRAPEN (ANCH,TRAENT(A2))
        TRA(A1) = TRA(A2) ! DEQUEUE INC.
        SYMMAR(SYMB) = TRA(1)
        TRA(A2) = A2
        CALL TRAPEN (FTRA,A2) ! DELETE INC.
      GOTO 8
6     CONTINUE
        CALL TRAPIM (ANCH,TIDEN,SYMB)
8     CONTINUE
      GOTO 99
C----------------------------------------------------------
105   CONTINUE !  ATCO
C
      CALL TRATTR (ASEM,  SYMB,INC,A1,A2)
      SYMB = INC
      GOTO 1011 ! ACCO1
C----------------------------------------------------------
106   CONTINUE !  ATIN
C
      CALL TRATTR (ASEM,  SYMB,INC,A1,A2)
      IF (A2 .EQ. TRAHIB) GOTO 12
      ACT = TRAENT(A2) ! -> CONTENT
      IF (ACT .EQ. TRAHIB) GOTO 12 ! -> LAST
        ACT = TRA(ACT) ! -> 1ST
        LEFT = TRAENT(ACT)
      GOTO 13
12    CONTINUE
        CALL ASSERT  (126,-SYMB, -INC)
C         ATIN AND ATTRIBUTE @$@ IS EMPTY OR DOES NOT EXIST
        LEFT = PROLEF(PROD)
13    CONTINUE
      TRALEF = ANCH
      IF (PARASK ('TRAFOR',1,6,0) .GE. 2)
     =  CALL TRAOUT (ASEM,LEFT,TRALEF)
      ANCH = TRAHIB
      GOTO 99
C----------------------------------------------------------
107   CONTINUE !  ATMA
C
      CALL TRATTR (ASEM,  SYMB,INC,A1,A2)
1071  CONTINUE ! ATMA1:
      IF (A2 .NE. TRAHIB) GOTO 14
        CALL TRAPIM (A2,INC,ANCH)
        TRA(A2) = TRA(1)
        SYMMAR(SYMB) = A2
      GOTO 30
14    CONTINUE
        CALL TRAPEN (FTRA,TRAENT(A2))
        TRAENT(A2) = ANCH
30    CONTINUE
      IF (PARASK ('TRAFOR',1,6,0) .GE. 2)
     =  CALL TRAOUT(ASEM,SYMB,TRAENT(A2))
      ANCH = TRAHIB
      GOTO 99
C---------------------------------------------------------
108   CONTINUE !  SYAT
C
      CALL TRATTR (ASEM,  SYMB,INC,A1,A2)
      IF (A2 .EQ. TRAHIB) GOTO 15
      ACT = TRAENT(A2) ! -> CONTENT
      IF (ACT .EQ. TRAHIB) GOTO 15 ! -> LAST
        ACT = TRA(ACT) ! -> 1ST
        SYMB = TRAENT(ACT)
      GOTO 16
15    CONTINUE
        CALL ASSERT  (128,-SYMB, -INC)
C         ATIN AND ATTRIBUTE @$@ IS EMPTY OR DOES NOT EXIST
        SYMB = TCOMT
16    CONTINUE
      GOTO 1151 ! COMSYM
C----------------------------------------------------------
109   CONTINUE !  SOCO
      I = FSTK + SEMSYM(ASEM) - 1
      GOTO 1092
C-----------------------------------------------------------
112   CONTINUE !  SOTA
C
      I = FSTK + SEMSYM(ASEM) - 1
      IF (STKSTA(I) .LT. 0) GOTO 1092
        CALL TRAPEN (ANCH,STKTRA(I))
        STKSTA(I) = - STKSTA(I) ! MARK IT "TAKEN"
      GOTO 1093
1092  CONTINUE ! WAS ALREADY TAKEN
        CALL TRACOP (ANCH,STKTRA(I))
1093  CONTINUE
      GOTO 99
C-----------------------------------------------------------
110   CONTINUE !  REIN
C
      REIPOS = SEMSYM(ASEM) ! NO REDUCTION IN 'PARSER'
      CALL TRAPEN (ANCH,TRAIN)
      TRAIN = ANCH ! PREFIX INPUT WITH ELEMENTS AFTER '@'
      IF (PARASK ('TRAFOR',1,6,0) .GE. 2)
     =  CALL TRAOUT (ASEM,ERRSYM,TRAIN)
      ANCH = TRAHIB
      GOTO 99
C-----------------------------------------------------------
111   CONTINUE !  UNCH
C
      I = FSTK
17    IF(I .GT. FSTK + PROLNG(PROD) - 1) GOTO 18
        IF (STKSTA(I) .LT. 0) GOTO 1112
          CALL TRAPEN (ANCH,STKTRA(I))
          STKSTA(I) = - STKSTA(I) ! MARK IT "TAKEN"
        GOTO 1113
1112    CONTINUE ! WAS ALREADY TAKEN
          CALL TRACOP (ANCH,STKTRA(I))
1113    CONTINUE
        I = I + 1
      GOTO 17
18    CONTINUE ! DO I
      LEFT = PROLEF(PROD)
      TRALEF = ANCH
      IF (PARASK ('TRAFOR',1,6,0) .GE. 2)
     =  CALL TRAOUT (ASEM,LEFT,TRALEF)
      ANCH = TRAHIB
      GOTO 1201
C-----------------------------------------------------------
113   CONTINUE !  SYCO
C
      CALL TRAPIM (ANCH,TKEYW,SEMSYM(ASEM))
      GOTO 99
C-----------------------------------------------------------
114   CONTINUE !  SYIN
C
      LEFT = SEMSYM(ASEM)
      TRALEF = ANCH
      IF (PARASK ('TRAFOR',1,6,0) .GE. 2)
     =  CALL TRAOUT (ASEM,LEFT,TRALEF)
      ANCH = TRAHIB
      GOTO 99
C-----------------------------------------------------------
115   CONTINUE !  SYMA
C
      SYMB = SEMSYM(ASEM)
1151  CONTINUE ! COMSYM:
      CALL TRAPIM (ANCH,TVOID,SYMB)
      BANCH = ANCH
      ANCH = TRAHIB
      GOTO 99
C-----------------------------------------------------------
116   CONTINUE !  SEPR
C
      I = SEMSYM(ASEM)
      IF (I .GE. 40) GOTO 1161
        CALL SEMANT (I,FSTK,ANCH,TRAIN)
      GOTO 99
1161  CONTINUE
        CALL SEPANT (I,FSTK,ANCH,TRAIN)
      GOTO 99
C-----------------------------------------------------------
117   CONTINUE !  ACCU
C
      CALL ASSERT  (131,PROD,ASEM)
      GOTO 99
C-----------------------------------------------------------
118   CONTINUE !  ATTR
C
      CALL ASSERT  (132,PROD,ASEM)
      GOTO 99
C-----------------------------------------------------------
119   CONTINUE !  EOSY
C
      IF (PARASK ('TRAFOR',1,6,0) .GE. 2)
     =  CALL TRAOUT (ASEM,TRASYM(BANCH),ANCH)
      ACT = ANCH
      ANCH = BANCH ! -> LAST
      TREREF = FTRE ! -> NEXT RECORD TO BE WRITTEN
      CALL TRADO (ACT,TREPUT)
      CALL TRAPEN (FTRA,ACT) ! DELETE THE CONTENTS OF THE COMB.SY
      CALL TRAPIM (ANCH,TGOTO,TREREF) ! INDICATES END OF COMB.SY
      CALL TREPUT (ANCH)
      TRASYM(ANCH) = TCALL
      GOTO 99
C-----------------------------------------------------------
120   CONTINUE !  EOS
C
      IF (SEMSYM(ASEM) .EQ. 1) GOTO 111 ! EOS,1 = UNCH
1201  CONTINUE
C
C     NOW DELETE ALL UNUSED SONS
      I = FSTK
22    IF (I .GT. FSTK + PROLNG(PROD) - 1) GOTO 23
        IF (STKSTA(I) .LT. 0) GOTO 1202
          CALL TRAPEN (FTRA,STKTRA(I)) ! DELETE UNMARKED SON
        GOTO 1203
1202    CONTINUE
          STKSTA(I) = - STKSTA(I) ! UNDO THE MARKING
1203    CONTINUE
        I = I + 1
      GOTO 22
23    CONTINUE
      IF (PARASK  ('TRADUM',1,6,0) .EQ. 0) GOTO 25
        CALL TRADUM (0) ! DUMP ALL
25    CONTINUE
C
C     DO   N O T   'GOTO ESAC', BUT LEAVE 'TRAFOR'
C
      RETURN
      END
&END
&(TRAO1   )
      SUBROUTINE TRAO1 (I)
C     OUTPUT OF ONE SINGLE 'TRA'-ELEMENT
C     GF 24.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (TRAS)
      INTEGER I,J
     = ,TMNEMO(18) ! MNEMO-CODES FOR THE CLASSES IN 'TRASYM'
      DATA TMNEMO
     = /'VO','ID',  'KE','YW',  'SP','EC',  'CA','LL'
     = ,'CO','MT',  'GO','TO',  'ID','EN',  'NU','MB'
     = ,'ST','RI'/
      %INCLUDE (ENDS)
C
      IF (TRASYM(I) .EQ. 0) GOTO 1
        J = TRASYM(I)
        CALL ZZWX(2)
        IF (J .GT. TSTRI .OR. J .LT. TVOID) GOTO 4
          CALL ZZWC(TMNEMO,4*J-3,4*J,5)
          CALL PUTSYM(TRAENT(I))
        GOTO 5
4       CONTINUE
          CALL PUTSYM (J)
          CALL ZZWI (TRAENT(I),4)
5       CONTINUE
1     CONTINUE
      RETURN
      END
&END
&(TRAOUT  )
      SUBROUTINE TRAOUT (ASEM,LEFT,TRALEF)
C     TEST PRINT-OUT FOR SIGNIFICANT ACTIONS IN 'TRAFOR'
C     GF 24.07.80
C
      INTEGER I
     = ,ASEM    ! -> SEMANTIC ACTION FOR THE DESTINATION
     = ,LEFT    ! THE SYMBOL WHICH IS ASSIGNED TO
     = ,TRALEF  ! THE RING WHICH IS ASSIGNED TO 'LEFT'
      EXTERNAL TRAO1
C
      I = ASEM
      CALL OUTSEM (I)
      CALL PUTSYM (LEFT)
      CALL ZZWC ('->',1,2,0)
      CALL TRADO (TRALEF,TRAO1) ! OUTPUT EVERY SINGLE ELEMENT
      CALL ZZWS (0)
      RETURN
      END
&END
&(TRAPEN  )
      SUBROUTINE TRAPEN (TARGET,SOURCE)
C     CONCATENATE RING 'TARGET' WITH RING 'SOURCE'
C     GF 24.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (TRAS)
      %INCLUDE (ENDS)
      INTEGER I
     = ,SOURCE  ! THIS RING IS APPENDED
     = ,TARGET  ! APPEND AT THE RIGHT OF THIS RING (RESULT)
C
      IF (SOURCE .EQ. TRAHIB) GOTO 1
        IF (TARGET .EQ. TRAHIB) GOTO 2
          I = TRA(TARGET) ! INTERCHANGE 2 POINTERS
          TRA(TARGET) = TRA(SOURCE)
          TRA(SOURCE) = I
2       CONTINUE ! TARGET NOT EMPTY
        TARGET = SOURCE ! NEW RESULT
1     CONTINUE ! SOURCE NOT EMPTY
      RETURN
      END
&END
&(TRAPIM  )
      SUBROUTINE TRAPIM (ANCH,SYM,ENT)
C     APPEND ONE IMMEDIATE 'TRA'-ELEMENT TO 'ANCH'
C     GF 24.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (TRAS)
      %INCLUDE (ENDS)
      INTEGER ACT
     = ,ANCH    ! APPEND TO THIS ANCHOR
     = ,ENT     ! THE NEW 'TRAENT'
     = ,SYM     ! THE NEW 'TRASYM'
C
      ACT = TRA(FTRA) ! GET A FREE ELEMENT
      IF (ACT .NE. FTRA) GOTO 1
        CALL ASSERT (129,TRAHIB,FTRA)
        CALL TRADUM (0)
1     CONTINUE
      TRA(FTRA) = TRA(ACT)
      TRASYM(ACT) = SYM
      TRAENT(ACT) = ENT
C
      IF (ANCH .EQ. TRAHIB) GOTO 2
        TRA(ACT) = TRA(ANCH)
        TRA(ANCH) = ACT
      GOTO 3
2     CONTINUE ! APPEND
        TRA(ACT) = ACT
3     CONTINUE
      ANCH = ACT
      RETURN
      END
&END
&(TRAS    )
C-------GF 28.08.80------------------------------ T R A S
C      STRUCTURE TREE, INTERNAL LISTS
      INTEGER FTRA,TRAHIB
      INTEGER TRA(&TRAH)
        INTEGER TRASYM(&TRAH)
        INTEGER TRAENT(&TRAH)
      INTEGER TVOID,TKEYW,TSPEC,TCALL,TCOMT
      INTEGER TGOTO,TIDEN,TNUMB,TSTRI
      COMMON /TRAS/
     =  FTRA      ! -> LAST ELEMENT OF FREE RING
     = ,TRAHIB      ! HIGH BOUND OF 'TRA'
      COMMON /TRAS/
     =  TVOID     ! 1 IGNORE ACCU
     = ,TKEYW     ! 2 KEYWORD
     = ,TSPEC   ! 3 PUNCTUATION CHARACTERS
     = ,TCALL   ! 4 COMBINED SYMBOL, PAGED CONTENTS
     = ,TCOMT     ! 5 COMMENT
     = ,TGOTO   ! 6 END OF COMBINED SYMBOL
     = ,TIDEN   ! 7 IDENTIFIER
     = ,TNUMB   ! 8 NUMBER
     = ,TSTRI   ! 9 STRIN
      COMMON /SETTRA/    !-SYMBOL--COMB.SY--ACCU/ATTR--
     =  TRA             !  RBRO     RBRO     FIRST
     = ,TRASYM          !  CLASS   SYMBOL   DEEPER
     = ,TRAENT          !  ENTIT   FILE-P   0/ATTR1
C               !----------------------------
&END
&(TRATTR  )
      SUBROUTINE TRATTR (ASEM,  SYMB,INC,A1,A2)
C     ACCESS TO AN ATTRIBUTE
C     GF 16.07.80
C     GF 24.07.80: SIMPLER VERSION
C
C     1 <= A1 < A2 <= TRAHIB
C     A1 -> A2
C     A2 -> INC: FOUND, OR A2 = TRAHIB: NOT FOUND
C     INSERT BETWEEN 'A1,A2', RESULTING ANCHOR IS IN 'TRA(1)'
C     ASEM += 1
C
      %INCLUDE (PARS)
      %INCLUDE (SEMS)
      %INCLUDE (STKS)
      %INCLUDE (SYMS)
      %INCLUDE (TRAS)
      INTEGER I
     = ,A1,A2   ! 2 SUCCEEDING POINTERS TO THE LIST OF ATTRIBUTES
     = ,ASEM    ! -> ATTRIBUTE-ACTION IN 'SEM'
     = ,INC     ! THE INCARNATION OF 'SYMB'
     = ,SYMB    ! THE NAME OF THE ATTRIBUTE
      %INCLUDE (ENDS)
C
      I = FSTK + SEMSYM(ASEM) - 1 ! ACCESS TO THE SON
      ASEM = ASEM + 1
      INC  = SEMSYM(ASEM)
      A1 = 1
      A2 = STKTRA(I)
      IF (A2 .NE. TRAHIB) GOTO 3
        CALL ASSERT (133,SEMSYM(ASEM-1),-INC)
C         EMPTY SON @, ATTRIBUTE @ IS UNDEFINED
        SYMB = ERRSYM
        TRA(A1) = A2
        GOTO 99
3     CONTINUE
      A2 = TRA(A2) ! -> 1ST
      IF (TRASYM(A2) .GE. TIDEN .AND. TRASYM(A2) .LE. TSTRI) GOTO 4
        CALL ASSERT (134,-TRASYM(A2),-INC)
C         @ IS NO ENTITY, ATTRIBUTE @ IS UNDEFINED
        A2 = TRAHIB
        SYMB = ERRSYM
        TRA(A1) = A2
        GOTO 99
4     CONTINUE
C
      SYMB = TRAENT(A2)
      A2 = SYMMAR(SYMB)
      IF (A2 .EQ. 0) A2 = TRAHIB
      TRA(A1) = A2
1     IF(TRASYM(A2) .EQ. INC .OR. A2 .EQ. TRAHIB) GOTO 2
        A1 = A2 ! LOOK AT NEXT IN THE LIST
        A2 = TRA(A1)
      GOTO 1
2     CONTINUE
99    RETURN ! TRATTR
      END
&END
&(TREFRE  )
      SUBROUTINE TREFRE (RECNO)
C     FREE A SLOT EXPLICITELY
C     GF 26.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (SLOS)
      INTEGER I
     = ,RECNO     ! FREE THE SLOT WHICH CONTAINS THIS RECORD
      %INCLUDE (ENDS)
C
      DO 4 I = 1,SLOHIB
        IF (SLOFUL(I) .NE. RECNO) GOTO 4
          SLOFUL(I) = 0
          GOTO 98
4     CONTINUE
98    RETURN
      END
&END
&(TREGET  )
      SUBROUTINE TREGET (REF,  COL,ROW)
C     GET A 'TRE'-RECORD FROM THE DIRECT-FILE
C     GF 26.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (SLOS)
      %INCLUDE (TRES)
      INTEGER I
     = ,COL     ! THE RECORD IS READ IN THIS COLUMN
     = ,RECNO ! -> RECORD WHICH CONTAINS ELEMENT NO. 'REF'
     = ,REF   ! A 'TRE'-ELEMENT TO BE ACCESSED
     = ,ROW   ! -> 'TRE', ELEMENT WITH LOGICAL NUMBER 'REF'
      %INCLUDE (ENDS)
C
      RECNO = (REF - 1) / TREHIB + 1
      ROW = REF - (RECNO - 1) * TREHIB
      COL = 0
      DO 1 I = 1,SLOHIB ! LOOK FOR 'RECNO' RESP. FREE SLOT
        IF (SLOFUL(I) .NE. RECNO) GOTO 2
          COL = I
          GOTO 99
2       CONTINUE
        IF (SLOFUL(I) .EQ. 0) COL = I
1     CONTINUE ! LOOK FOR 'RECNO'
C
      IF (COL .NE. 0) GOTO 3
        FSLO = MOD(FSLO,SLOHIB) + 1
        COL = FSLO
        TRECNO = SLOFUL(COL)
        WRITE (UTRE'TRECNO) (SLOT(I,COL),I=1,TREHIB)
3     CONTINUE
      SLOFUL(COL) = RECNO
      TRECNO = RECNO
      READ (UTRE'TRECNO) (SLOT(I,COL),I=1,TREHIB)
99    CONTINUE
      RETURN
      END
&END
&(TREPUT  )
      SUBROUTINE TREPUT (ACT)
C     PUT A COMBINED SYMBOL TO THE EXTERNAL TREE
C     GF 16.07.80  DUMMY VERSION
C
      %INCLUDE (PARS)
      %INCLUDE (TRAS)
      %INCLUDE (TRES)
      INTEGER PARASK
      INTEGER I
     = ,ACT     ! WRITE THIS 'TRA'-ELEMENT TO THE EXTERNAL TREE
      %INCLUDE (ENDS)
C
      IF (PARASK('TREPUT',1,6,1) .EQ. 0) RETURN
      IF (TRASYM(ACT) .EQ. TVOID) RETURN
      I = MOD(FTRE-1,TREHIB) + 1 ! E.G. TREHIB+1 -> 1
      TRE(I) = TRASYM(ACT)
      TRE(I+1) = TRAENT(ACT)
      FTRE = FTRE + 2
      IF (I+2 .LT. TREHIB) GOTO 1
        WRITE (UTRE'TRECNO) TRE ! TRECNO += 1
        FTRE = (TRECNO-1) * TREHIB + 1
1     CONTINUE
      RETURN
      END
&END
&(TRES    )
C-----GF 24.07.80-------------------------------------------- T R E S
      INTEGER FTRE,TRECNO,TREHIB,TRE(&TREH)
      COMMON /TRES/
     =  FTRE    ! 1ST FREE ELEMENT IN 'TRE'
     = ,TRECNO  ! NUMBER OF THE NEXT RECORD TO BE WRITTEN
     = ,TREHIB  ! HIGH BOUND OF 'TRE'
     = ,TRE     ! BUFFER FOR THE CONTENTS OF COMBINED SYMBOLS
&END
&(TREXPA  )
      SUBROUTINE TREXPA (TREREF)
C     EXPAND THE EXTERNAL TREE AND WRITE THE TARGET-PROGRAM
C     GF 26.07.80
C     GF 08.11.80: 'COMT', AND 'STRI' SPLIT RESP. DOUBLE QUOTES
C
      %INCLUDE (PARS)
      %INCLUDE (SLOS)
      %INCLUDE (STRS)
      %INCLUDE (SYMS)
      %INCLUDE (TRES)
      INTEGER INDEX
      INTEGER PARASK
      INTEGER I
     = ,COL     ! A COLUMN IN 'SLOT' WHICH CONTAINING THE ACTUAL RECORD
     = ,ENTITY  ! THE CURRENT SYMBOL TO BE WRITTEN
     = ,FATHER  ! -> PREVIOUS 'TCALL'-ELEMENT
     = ,LOOPCH  ! TO PROTECT AGAINST INFINITE LOOPS
     = ,POS     ! -> START IN 'STRNG'
     = ,POE     ! -> END   IN 'STRNG'
     = ,REF     ! NUMBER OF CURRENT 'TRE'-RECORD
     = ,ROW     ! CURRENT POSITION IN RECORD 'REF'
     = ,SYMBOL  ! THE SYMBOL-CLASS OF 'ENTITY'
     = ,TARLNG  ! FOR HANDLING OF FORTRAN COLUMN 1 - COLUMN 7
     = ,TREREF  ! -> THE OUTERMOST COMBINED SYMBOL
      %INCLUDE (ENDS)
C
      LOOPCH = 0
      TARLNG = 5 ! START WITH A NEW STATEMENT
      FATHER = 0 ! CRITERION FOR POP
      REF = TREREF ! START HERE
3       CONTINUE ! LOOP FOREVER
          CALL TREGET (REF,  COL,ROW)
4         IF(ROW .GE. TREHIB) GOTO 5
            SYMBOL = SLOT(ROW  ,COL)
            ENTITY = SLOT(ROW+1,COL)
            IF (PARASK('TREXPA',1,6,0) .EQ. 0) GOTO 11
              CALL ZZWC ('TREXPA: ',1,8,0)
              DO 12 I = 1,SLOHIB
                CALL ZZWI (SLOFUL(I),4)
12            CONTINUE
              CALL ZZWI (FATHER,8)
              CALL ZZWI (REF,8)
              CALL ZZWC ('-> SLOT(',1,8,0)
              CALL ZZWI (ROW,4)
              CALL ZZWC (',',1,1,0)
              CALL ZZWI (COL,4)
              CALL ZZWC (') =',1,3,0)
              CALL ZZWI (SYMBOL,4)
              CALL ZZWX (2)
              CALL PUTSYM (ENTITY)
              CALL ZZWS (0)
              LOOPCH = LOOPCH + 1
              IF (LOOPCH .GT. 256) RETURN
11          CONTINUE
C                VOID KEYW SPEC CALL COMT GOTO IDEN NUMB STRI
            GOTO(1001,1002,1003,1004,1005,1006,1007,1008,1009
     =      ),SYMBOL
C--------------------------------------------------------------
1001  CONTINUE ! VOID
C
      GOTO 99
C--------------------------------------------------------------
1002  CONTINUE ! KEYW
C
      IF (ENTITY .NE. EOSTMT) GOTO 1007 ! IDEN
        TARLNG = 5
        CALL ZZTS (-1) ! BEGIN A NEW FORTRAN-STATEMENT
      GOTO 99
C--------------------------------------------------------------
1003  CONTINUE ! SPEC
C
      CALL ZZTC (STRNG,SYMPOS(ENTITY),SYMEND(ENTITY),0)
      GOTO 99
C--------------------------------------------------------------
1004  CONTINUE ! CALL
C
      SLOT(ROW,COL) = FATHER ! REPLACE 'TCALL' BY BACK-CHAIN
      FATHER = REF
      REF = ENTITY
      GOTO 100 ! GET
C--------------------------------------------------------------
1005  CONTINUE ! COMT
C
      CALL ZZTS (-2) ! PLACE 'C ' AT START OF LINE
      IF (ENTITY .GE. 0) GOTO 10051
        CALL ZZTI (-ENTITY,6) ! IT IS A LINE-NUMBER IN CODED FORM
10051 CONTINUE
      GOTO 99
C--------------------------------------------------------------
1007  CONTINUE ! IDEN
C
      CALL ZZTX (TARLNG+1)
      TARLNG = 0
      CALL ZZTC (STRNG,SYMPOS(ENTITY),SYMEND(ENTITY),0)
      GOTO 99
C--------------------------------------------------------------
1008  CONTINUE ! NUMB
C
      IF (ENTITY .LE. 0) GOTO 8
        CALL ZZTC(STRNG,SYMPOS(ENTITY),SYMEND(ENTITY),TARLNG)
      GOTO 9
8     CONTINUE ! CODED NUMBER
        CALL ZZTI (-ENTITY,TARLNG)
9     CONTINUE
      TARLNG = 0
      GOTO 99
C--------------------------------------------------------------
1009  CONTINUE ! STRI
C
      IF (ENTITY .LT. 0) GOTO 10092
C       DO NOT SPLIT, BUT DOUBLE QUOTES
        POS = SYMPOS(ENTITY)
        POE = SYMEND(ENTITY)
        CALL ZZTS(POE-POS+5) ! F4P DISALLOWS STRING ON TWO CARDS
        CALL ZZTC ('''',1,1,0)
        I = POS  ! START AT THE BEGINNING
10093   CONTINUE
          POS = INDEX (STRNG,I,POE,'''') ! POSITION OF ANY QUOTE, OR 0
          IF (POS .NE. 0) GOTO 10094
C           NO INNER QUOTE FOUND
            CALL ZZTC (STRNG,I,POE,0) ! OUTPUT THE REST
            GOTO 10095
10094     CONTINUE
          CALL ZZTC (STRNG,I,POS-1,0) ! PUT THE PORTION BEFORE QUOTE
          CALL ZZTC ('''''',1,2,0)    ! PUT DOUBLED INNER QUOTE
          I = POS + 1 ! GO ON BEHIND THE QUOTE
        IF (I .LE. POE) GOTO 10093
10095   CONTINUE
        CALL ZZTC ('''',1,1,0)        ! PUT QUOTE AT THE END
        GOTO 99
10092 CONTINUE ! SPLIT IN '2HXX,2HYY,...'
        ENTITY = - ENTITY
        POS = SYMPOS(ENTITY)
        POE = SYMEND(ENTITY)
        CALL ZZTC ('2H',1,2,0)
10091 CONTINUE
        CALL ZZTC (STRNG,POS,POS+1,0)
        POS = POS + 2
        IF (POS .GT. POE) GOTO 10
          CALL ZZTC (',2H',1,3,0)
          GOTO 10091
10      CONTINUE
      GOTO 99
C--------------------------------------------------------------
99          CONTINUE ! ESAC
            ROW = ROW + 2
            REF = REF + 2
          GOTO 4
5         CONTINUE ! ROW < TREHIB
          SLOFUL(COL) = 0 ! FREE THIS SLOT - IT IS PROCESSED
C
100       CONTINUE ! GET:
        GOTO 3 ! INFINITE LOOP
C
1006    CONTINUE ! GOTO:
        REF = FATHER
        CALL TREGET (REF,  COL,ROW)
        FATHER = SLOT(ROW,COL)
        ROW = ROW + 2 ! BEHIND 'TCALL'
        REF = REF + 2
      IF (FATHER .NE. 0) GOTO 4
C
      RETURN ! TREXPA
      END
&END
&(ZZCC    )
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;
;     Z Z C C
;
;     BOFOR - DEC RSX11M - RUN TIME SYSTEM
;
;     ZZCC PROVIDES FOR COPY OPERATIONS ON SUBSTRINGS.
;
;          CALL ZZCC (SN, SS, SE, TN, TS, TE)
;
;     PERFORMS THE ASSIGNMENT  TN[TS:TE] := SN[SS:SE].
;     SN[SS:SE] IS TRUNCATED OR PADDED WITH BLANKS ON ASSIGNMENT
;     DEPENDING ON THE LENGTHS OF THE SUBSTRINGS.
;
;     PARAMETERS:     SN : SOURCE STRING
;                     SS : SUBSTRING STARTING POSITION
;                     SE : SUBSTRING ENDING POSITION
;                     TN : TARGET STRING
;                     TS : SUBSTRING STARTING POSITION
;                     TE : SUBSTRING ENDING POSITION
;
;     ALL PARAMETERS ARE OF INTEGER*2 TYPE
;
;     NOTE:           THE STRINGS MUST NOT OVERLAP.
;
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;
         .TITLE ZZCC
         .PSECT ZZ
;
SN       =      02.
SS       =      04.
SE       =      06.
TN       =      08.
TS       =      10.
TE       =      12.
;
;---  SOURCE SETUP
;
ZZCC::   MOV    SN(R5),R0            ;SOURCE BASE ADDR
         MOV    @SS(R5),R1           ;STARTING POSITION
         DEC    R1                   ;STARTING OFFSET
         ADD    R1,R0                ;SOURCE STARTING ADDR
         SUB    @SE(R5),R1           ;NEG LENGTH OF SOURCE
;
;---  TARGET SETUP
;
         MOV    TN(R5),R2            ;TARGET BASE ADDR
         MOV    @TS(R5),R3           ;STARTING POSITION
         DEC    R3                   ;STARTING OFFSET
         ADD    R3,R2                ;TARGET STARTING ADDR
         SUB    @TE(R5),R3           ;NEG LENGTH OF TARGET
;
;---  DETERMINE LENGTHS TO COPY AND PAD
;
         SUB    R3,R1                ;R1:=LEN(TGT)-LEN(SRC)
         BLE    10$                  ;NO TRUNCATION
         ADD    R1,R3                ;TRUE NEG LEN TO COPY
10$:     NEG    R3                   ;TRUE LENGTH
;
;---  COPY
;
         BLE    20$                  ;DONE FOR ZERO LENGTH
12$:     MOVB   (R0)+,(R2)+          ;COPY
         SOB    R3,12$               ;LOOP
;
;---  PAD
;
20$:     TST    R1                   ;PADDING REQ?
         BLE    30$                  ;NO: DONE
         MOV    #' ,R0               ;FAST BLANK
22$:     MOVB   R0,(R2)+             ;SET BLANK
         SOB    R1,22$               ;LOOP
;
30$:     RETURN
         .END
&END
&(ZZCCTE  )
        PROGRAM ZZCCTE
C       TEST OF BOFOR-RTS-ROUTINES 'ZZCC', 'ZZIC', 'ZZCI', 'ZZCR'
C       GF 09.07.80
C
        INTEGER U5,CODE,LS,LE,RS,RE,A(35)
        INTEGER I,ZZCR
        DATA U5/5/
C
        WRITE(U5,11)
11      FORMAT(' TYPE CODE(A2),START,END,START,END(4I2),TEXT(..A1)')
1       READ (U5,2,END=99,ERR=1) CODE,LS,LE,RS,RE,A
2       FORMAT(A2,4I2,35A2)
C
        IF(CODE .NE. 'CC') GOTO 3
          CALL ZZCC (A,LS,LE,A,RS,RE)
          WRITE (U5,4) A
4         FORMAT(' CC:       ',35A2)
          GOTO 1
C
3       CONTINUE
        IF(CODE .NE. 'IC') GOTO 5
          CALL ZZIC(LS,A,LE)
          WRITE (U5,6) A
6         FORMAT(' IC: ',35A2)
          GOTO 1
C
5       CONTINUE
        IF(CODE .NE. 'CI') GOTO 7
          CALL ZZCI(A,LS,LE)
          WRITE(U5,8) LE
8         FORMAT(' CI: ',I5)
          GOTO 1
C
7       CONTINUE
          I = ZZCR(A,LS,LE,A,RS,RE)
          WRITE(U5,10) I
10        FORMAT(' CR: ',I6)
          GOTO 1
99      STOP
        END
&END
&(ZZCI    )
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;
;     Z Z C I
;
;     BOFOR - DEC RSX11M - RUN TIME SYSTEM
;
;     ZZCI RETURNS THE INTEGER ASCII - VALUE OF A CHARACTER.
;
;          CALL ZZCI (SN, SP, TIN)
;
;     THE ASCII-VALUE OF THE SUBSTRING SN[SP:SP] IS RETURNED
;     IN TIN AS AN INTEGER.
;
;     PARAMETERS:     SN : SOURCE STRING
;                     SP : CHARACTER POSITION
;                     TIN: INTEGER VALUE RETURNED
;
;     ALL PARAMETERS ARE OF INTEGER*2 - TYPE.
;
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;
         .TITLE ZZCI
         .PSECT ZZ
;
SN       =      02.
SP1      =      04.
TIN      =      06.
;
ZZCI::   MOV    SN(R5),R0            ;SOURCE STRING BASE
         ADD    @SP1(R5),R0          ;1 BYTE AFTER CHAR TO USE
         MOV    TIN(R5),R1           ;TARGET WORD ADDR
         MOVB   -(R0),(R1)+          ;COPY CHAR
         CLRB   (R1)                 ;CLEAR HIGH ORDER PART
;
         RETURN
         .END
&END
&(ZZCR    )
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;
;     Z Z C R
;
;     BOFOR - DEC RSX11M - RUN TIME SYSTEM
;
;     ZZCR PROVIDES FOR COMPARISON OPERATIONS ON SUBSTRINGS.
;
;          I = ZZCR (LN, LS, LE, RN, RS, RE)
;
;     YIELDS AN INTEGER FUNCTION VALUE DEPENDING ON THE COMPARISON
;     OF THE SUBSTRINGS LN[LS:LE] AND RN[RS:RE] AS FOLLOWS:
;
;          -1  :  LN IS LOW
;           0  :  ARGUMENTS ARE EQUAL
;          +1  :  LN IS HIGH
;
;     IF THE ARGUMENTS ARE NOT OF EQUAL LENGTH AND ARE EQUAL TO
;     THEIR COMMON EXTENT, THE SHORTER ONE WILL BE LOW. (PADDING
;     BINARY ZEROES)
;
;     PARAMETERS:     LN : FIRST COMPARAND
;                     LS : SUBSTRING STARTING POSITION
;                     LE : SUBSTRING ENDING POSITION
;                     RN : SECOND COMPARAND
;                     RS : SUBSTRING STARTING POSITION
;                     RE : SUBSTRING ENDING POSITION
;
;     ALL PARAMETERS ARE OF INTEGER*2 TYPE.
;
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;
         .TITLE ZZCR
         .PSECT ZZ
;
LN       =      02.
LS       =      04.
LE       =      06.
RN       =      08.
RS       =      10.
RE       =      12.
;
;---  1ST COMPARAND SETUP
;
ZZCR::   MOV    LN(R5),R0            ;1ST COMPARAND BASE ADDR
         MOV    @LS(R5),R1           ;STARTING POSITION
         DEC    R1                   ;STARTING OFFSET
         ADD    R1,R0                ;1ST COMPARAND STARTING ADDR
         SUB    @LE(R5),R1           ;NEG LENGTH OF 1ST COMPERAND
         NEG    R1                   ;LENGTH OF 1ST COMPERAND
;
;---  2ND COMPERAND SETUP
;
         MOV    RN(R5),R2            ;2ND COMPERAND BASE ADDR
         MOV    @RS(R5),R3           ;STARTING POSITION
         DEC    R3                   ;STARTING OFFSET
         ADD    R3,R2                ;2ND COMPERAND STARTING ADDR
         SUB    @RE(R5),R3           ;NEG LENGTH OF 2ND COMPERAND
         NEG    R3                   ;LENGTH OF 2ND COMPERAND
;
;---  DETERMINE LENGTH TO COMPARE
;
         MOV    R1,R4                ;COMPUTE -
         SUB    R3,R4                ;  R4:=LEN(LS)-LEN(RS)
         BLE    10$                  ;R1 CONTAINS MINIMUM
         MOV    R3,R1                ;FORCE R1:=R3
;
;---  COMPARE
;
10$:     TST    R1                   ;NULL STRING ???
         BLE    20$                  ;YES: DONE
12$:     CMPB   (R0)+,(R2)+          ;COMPARE BYTE
         BHI    31$                  ;LN IS HIGH
         BLO    32$                  ;LN IS LOW
         SOB    R1,12$               ;LOOP
;
;---  COMPARED STRINGS ARE EQUAL
;
20$:     TST    R4                   ;TEST IF OF SAME LENGTH
         BGT    31$                  ;LN IS LONGER THUS HIGH
         BLT    32$                  ;LN IS SHORTER THUS LOW
;
;...  EQUAL
         CLR    R0                   ;YIELD ZERO
         BR     77$
;
;...  LN IS HIGH
31$:     MOV    #1,R0                ;YIELD +1
         BR     77$
;
;...  LN IS LOW
32$:     MOV    #-1,R0               ;YIELD -1
;
77$:     RETURN
         .END
&END
&(ZZIC    )
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;
;     Z Z I C
;
;     BOFOR - DEC RSX11M - RUN TIME SYSTEM
;
;     ZZIC INSERTS A CHARACTER WHOSE INTEGER ASCII-VALUE IS GIVEN
;     INTO A CHARACTER STRING.
;
;          CALL ZZIC (SIN, TN, TP)
;
;     THE INTEGER ASCII-VALUE CONTAINED IN SIN IS INSERTED IN
;     THE SUBSTRING TN[TP:TP].
;
;     PARAMETERS:     SIN: INTEGER ASCII-VALUE
;                     TN : TARGET STRING
;                     TP : TARGET CHARACTER POSITION
;
;     ALL PARAMETERS ARE OF INTEGER*2 - TYPE.
;
;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;
         .TITLE ZZIC
         .PSECT ZZ
;
SIN      =      02.
TN       =      04.
TP       =      06.
;
ZZIC::   MOV    TN(R5),R0            ;TARGET STRING BASE
         ADD    @TP(R5),R0           ;1 BYTE AFTER TARGET CHAR
         MOVB   @SIN(R5),-(R0)       ;INSERT CHAR
;
         RETURN
         .END
&END
&(ZZTC    )
      SUBROUTINE ZZTC(CHARN,CHARS,CHARE,WIDTH)
C     WRITE CHARACTERS TO STREAM-OUTPUT
C
      %INCLUDE (PARS)
      %INCLUDE (TARS)
      INTEGER CHARS,CHARE,CHARN(1),WIDTH
      INTEGER LNG
C
      LNG = WIDTH
      IF (LNG .EQ. 0)
     =    LNG = CHARE - CHARS + 1
      CALL ZZTS(LNG)
      CALL ZZCC(CHARN,CHARS,CHARE,TARBUF,FTAR,FTAR + LNG)
      FTAR = FTAR + LNG
      RETURN
      END
&END
&(ZZTI    )
      SUBROUTINE ZZTI (INT,WIDTH)
C         WRITE AN INTEGER TO STREAM OUTPUT
C
      %INCLUDE (PARS)
      %INCLUDE (TARS)
      INTEGER I
     = ,INT      ! THE NUMBER TO BE ENCODED
     = ,WIDTH      ! WRITE SO MUCH CHARACTERS
     = ,LNG      ! TO DETERMINE THE WIDTH IF 'WIDTH=0'
     = ,IBUF(10)! ENCODE IN THIS ARRAY
      INTEGER*4 LNG4      ! TO DETERMINE 'LNG', <= 100000
C
      LNG = WIDTH
      IF (LNG .NE. 0) GOTO 5
        LNG4 = 1
        DO 6 I = 1,5
          LNG4 = LNG4 * 10
          IF (ABS(INT) .GE. LNG4) GOTO 8
            LNG = I + 1 ! ALLOW FOR MINUS-SIGN
             GOTO 5
8         CONTINUE
6       CONTINUE
5     CONTINUE
C
      ENCODE(LNG,4,IBUF) INT
4      FORMAT(I<LNG>)
      CALL ZZTC (IBUF,1,LNG,0)
      RETURN
      END
&END
&(ZZTS    )
      SUBROUTINE ZZTS (LNG)
C     CONDITIONALLY WRITE 'SKIP' TO STREAM OUTPUT
C     GF 26.07.80
C     GF 08.11.80: ONLY 6 BLANKS, AND 'LNG=-2' MEANS COMMENT
C
      %INCLUDE (PARS)
      %INCLUDE (TARS)
      INTEGER I
     = ,BL2     ! 2 BLANKS
     = ,BLEQ    ! BLANK AND EQUAL-SIGN
     = ,CBL     ! 'C' AND BLANK
     = ,LEN     ! =1000 IF 'LNG=0'
     = ,LNG      ! SKIP IF NO MORE 'LNG' CHARACTERS FREE
      DATA BL2/'  '/,BLEQ/' ='/,CBL/'C '/
C
      LEN = LNG
      IF (LEN) 9,10,11
9     CONTINUE
      IF (LEN .NE. -2) GOTO 8
C       -2 = COMMENT STARTS
        TARBUF(1) = CBL
        FTAR = 3
        GOTO 99
8     CONTINUE
      LEN = FTAR / 2
      WRITE (UTAR,2) (TARBUF(I),I=1,LEN)
      FTAR = 1
        GOTO 99
10    LEN = 1000
11    IF (FTAR + LEN - 1 .LE. TARHIB) GOTO 99
      LEN = FTAR / 2
      WRITE (UTAR,2) (TARBUF(I),I=1,LEN)
2     FORMAT(40A2)
      TARBUF(1) = BL2
      TARBUF(2) = BL2
      TARBUF(3) = BLEQ
      FTAR = 7
99    CONTINUE
      RETURN
      END
&END
&(ZZTT    )
      SUBROUTINE ZZTT (POS)
C     TABULATE TO POSITION 'POS' IN STREAM-OUTPUT
C     GF 16.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (TARS)
      INTEGER POS
C
      IF (FTAR .LE. POS) GOTO 1
        CALL ZZTS(0)
1     CONTINUE
      IF (FTAR .EQ. POS) GOTO 2
        CALL ZZTX (POS - FTAR)
2     CONTINUE
      RETURN
      END
&END
&(ZZTTE   )
      PROGRAM ZZTTE
C     TEST 'ZZT'-MODULES
C
      %INCLUDE (PARS)
      INTEGER I,J,K
      INTEGER T1(4),T2(6)
      DATA T1/2H1.,2H Z,2HEI,2HLE/
      DATA T2/2H K,2HOM,2HMT,2H ',2HRA,2HUS/
C
      DO 1 I=1,20
        CALL ZZTC(T1,1,8,0)
        CALL ZZTX(10)
        CALL ZZTC(T2,1,11,20)
        CALL ZZTS(0)
1     CONTINUE
        CALL ZZTS(-1)
      DO 2 I = 1,30
        CALL ZZTI(12345,10)
        CALL ZZTI(67,0)
2     CONTINUE
        CALL ZZTS(0)
      STOP
      END
&END
&(ZZTX    )
      SUBROUTINE ZZTX (LNG)
C     WRITE 'LNG' BLANKS TO STREAM OUTPUT
C
      %INCLUDE (PARS)
      %INCLUDE (TARS)
      INTEGER BLANKS(&TARH)
     = ,LNG      ! SKIP IF NO MORE 'LNG' CHARACTERS FREE
      DATA BLANKS/&TARH * 2H  /
C
      CALL ZZTC(BLANKS,1,LNG,0)
99    RETURN
      END
&END
&(ZZUC    )
      SUBROUTINE ZZUC(CHARN,CHARS,CHARE,WIDTH)
C     WRITE CHARACTERS TO STREAM-OUTPUT
C
      %INCLUDE (PARS)
      %INCLUDE (PRIS)
      INTEGER CHARS,CHARE,CHARN(1),WIDTH
      INTEGER LNG
C
      LNG = WIDTH
      IF (LNG .EQ. 0)
     =    LNG = CHARE - CHARS + 1
      CALL ZZUS(LNG)
      CALL ZZCC(CHARN,CHARS,CHARE,PRIBUF,FPRI,FPRI + LNG)
      FPRI = FPRI + LNG
      RETURN
      END
C------------------------------------------------------------------
      SUBROUTINE ZZUS (LNG)
C     CONDITIONALLY WRITE 'SKIP' TO STREAM OUTPUT
C
      %INCLUDE (PARS)
      %INCLUDE (PRIS)
      INTEGER I
     = ,LEN     ! =1000 IF 'LNG=0'
     = ,LNG      ! SKIP IF NO MORE 'LNG' CHARACTERS FREE
C
      LEN = LNG
      IF (LEN .EQ. 0) LEN = 1000
      IF (FPRI + LEN - 1 .LE. PRIHIB) GOTO 99
        LEN = FPRI / 2  ! WORDS
        WRITE (UPRI) (PRIBUF(I), I=1,LEN)
        FPRI = 2 ! POSITION 1 = CARRIAGE CONTROL
99    CONTINUE
      RETURN
      END
&END
&(ZZUTE   )
      PROGRAM ZZUTE
      INTEGER TEXT(5)
      INTEGER I,J,K
      DATA TEXT /'AB','CD','EF','GH','IJ'/
C
      DO 1 I = 1 ,10
        CALL ZZUC (TEXT,1,I,0)
        CALL ZZUS (0)
1     CONTINUE
      STOP
      END
&END
&(ZZUTETB )
ZZUTE=BOFOR/LB:ZZUTE:BLODAT,BOFOR/LB
&END
&(ZZWC    )
      SUBROUTINE ZZWC(CHARN,CHARS,CHARE,WIDTH)
C     WRITE CHARACTERS TO STREAM-OUTPUT
C
      %INCLUDE (PARS)
      %INCLUDE (PRIS)
      INTEGER CHARS,CHARE,CHARN(1),WIDTH
      INTEGER LNG
C
      LNG = WIDTH
      IF (LNG .EQ. 0)
     =    LNG = CHARE - CHARS + 1
      CALL ZZWS(LNG)
      CALL ZZCC(CHARN,CHARS,CHARE,PRIBUF,FPRI,FPRI + LNG)
      FPRI = FPRI + LNG
      RETURN
      END
&END
&(ZZWI    )
      SUBROUTINE ZZWI (INT,WIDTH)
C         WRITE AN INTEGER TO STREAM OUTPUT
C
      %INCLUDE (PARS)
      %INCLUDE (PRIS)
      INTEGER I
     = ,INT      ! THE NUMBER TO BE ENCODED
     = ,WIDTH      ! WRITE SO MUCH CHARACTERS
     = ,LNG      ! TO DETERMINE THE WIDTH IF 'WIDTH=0'
     = ,IBUF(10)! ENCODE IN THIS ARRAY
      INTEGER*4 LNG4      ! TO DETERMINE 'LNG', <= 100000
C
      LNG = WIDTH
      IF (LNG .NE. 0) GOTO 5
        LNG4 = 1
        DO 6 I = 1,5
          LNG4 = LNG4 * 10
          IF (ABS(INT) .GE. LNG4) GOTO 8
            LNG = I + 1 ! ALLOW FOR MINUS-SIGN
             GOTO 5
8         CONTINUE
6       CONTINUE
5     CONTINUE
C
      ENCODE(LNG,4,IBUF) INT
4      FORMAT(I<LNG>)
      CALL ZZWC (IBUF,1,LNG,0)
      RETURN
      END
&END
&(ZZWS    )
      SUBROUTINE ZZWS (LNG)
C     CONDITIONALLY WRITE 'SKIP' TO STREAM OUTPUT
C
      %INCLUDE (PARS)
      %INCLUDE (PRIS)
      INTEGER I
     = ,LEN     ! =1000 IF 'LNG=0'
     = ,LNG      ! SKIP IF NO MORE 'LNG' CHARACTERS FREE
C
      LEN = LNG
      IF (LEN .EQ. 0) LEN = 1000
      IF (FPRI + LEN - 1 .LE. PRIHIB) GOTO 99
        LEN = FPRI / 2  ! WORDS
        WRITE (UPRI,2) (PRIBUF(I), I=1,LEN)
2         FORMAT(&PRIH A2)
        FPRI = 2 ! POSITION 1 = CARRIAGE CONTROL
99    CONTINUE
      RETURN
      END
&END
&(ZZWT    )
      SUBROUTINE ZZWT (POS)
C     TABULATE TO POSITION 'POS' IN STREAM-OUTPUT
C     GF 16.07.80
C
      %INCLUDE (PARS)
      %INCLUDE (PRIS)
      INTEGER POS
C
      IF (FPRI .LE. POS) GOTO 1
        CALL ZZWS(0)
1     CONTINUE
      IF (FPRI .EQ. POS) GOTO 2
        CALL ZZWX (POS - FPRI)
2     CONTINUE
      RETURN
      END
&END
&(ZZWTE   )
      PROGRAM ZZWTE
C     TEST 'ZZW'-MODULES
C
      %INCLUDE (PARS)
      INTEGER T1(4),T2(6)
      DATA T1/2H1.,2H Z,2HEI,2HLE/
      DATA T2/2H K,2HOM,2HMT,2H ',2HRA,2HUS/
C
      CALL ZZWC(T1,1,8,0)
      CALL ZZWX(10)
      CALL ZZWC(T2,1,11,20)
      CALL ZZWS(0)
      CALL ZZWS(0)
      CALL ZZWI(12345,10)
      CALL ZZWI(67,0)
      CALL ZZWS(0)
      STOP
      END
&END
&(ZZWX    )
      SUBROUTINE ZZWX (LNG)
C     WRITE 'LNG' BLANKS TO STREAM OUTPUT
C
      %INCLUDE (PARS)
      %INCLUDE (PRIS)
      INTEGER BLANKS(&PRIH)
     = ,LNG      ! SKIP IF NO MORE 'LNG' CHARACTERS FREE
      DATA BLANKS/&PRIH * 2H  /
C
      CALL ZZWC(BLANKS,1,LNG,0)
99    RETURN
      END
&END

